{"componentChunkName":"component---node-modules-gatsby-plugin-bluewings-src-templates-post-query-js","path":"/build-your-own-react/","result":{"data":{"site":{"siteMetadata":{"title":[["ko","아빠는 개발자"],["en","Dev Dad"]],"social":[{"name":"GitHub","url":"https://github.com/bluewings"},{"name":"GitHub","url":"https://github.com/gatsbyjs"}]}},"blogPost":{"id":"d1a1f32d-dcff-56ce-83c8-e82aa1065fd9","excerpt":"이 글은  Rodrigo Pombo 의  Build your own React 의 한국어 버전입니다. 번역은  나만의 리액트 라이브러리 만들기 를 참고하였으며, 사용을 허락해주신  godori…","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"나만의 리액트 라이브러리 만들기\",\n  \"date\": \"2020-04-05T05:12:53.991Z\",\n  \"max_width\": \"58rem\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"\\uC774 \\uAE00\\uC740 \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://pomb.us/\"\n  }), \"Rodrigo Pombo\"), \"\\uC758 \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://pomb.us/build-your-own-react/\"\n  }), \"Build your own React\"), \"\\uC758 \\uD55C\\uAD6D\\uC5B4 \\uBC84\\uC804\\uC785\\uB2C8\\uB2E4.\"), mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"\\uBC88\\uC5ED\\uC740 \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://velog.io/@godori/build-your-own-react\"\n  }), \"\\uB098\\uB9CC\\uC758 \\uB9AC\\uC561\\uD2B8 \\uB77C\\uC774\\uBE0C\\uB7EC\\uB9AC \\uB9CC\\uB4E4\\uAE30\"), \"\\uB97C \\uCC38\\uACE0\\uD558\\uC600\\uC73C\\uBA70, \\uC0AC\\uC6A9\\uC744 \\uD5C8\\uB77D\\uD574\\uC8FC\\uC2E0 \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://velog.io/@godori\"\n  }), \"godori\"), \"\\uB2D8\\uAED8 \\uAC10\\uC0AC\\uB4DC\\uB9BD\\uB2C8\\uB2E4.\")), mdx(\"hr\", null), mdx(\"p\", null, \"\\uC6B0\\uB9AC\\uB294 \\uB9AC\\uC561\\uD2B8\\uB97C \\uCC98\\uC74C\\uBD80\\uD130 \\uC9C1\\uC811 \\uB9CC\\uB4E4\\uC5B4 \\uBCFC \\uAC83\\uC785\\uB2C8\\uB2E4. \\uCD5C\\uC801\\uD654\\uB098 \\uD544\\uC218\\uC801\\uC774\\uC9C0 \\uC54A\\uC740 \\uAE30\\uB2A5\\uB4E4\\uC740 \\uC81C\\uC678\\uD558\\uACE0, \\uC2E4\\uC81C \\uB9AC\\uC561\\uD2B8 \\uCF54\\uB4DC \\uAD6C\\uC870\\uB97C \\uAE30\\uBC18\\uC73C\\uB85C \\uD55C \\uB2E8\\uACC4\\uC529 \\uB530\\uB77C\\uAC00 \\uBD05\\uC2DC\\uB2E4.\"), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://engineering.hexacta.com/didact-learning-how-react-works-by-building-it-from-scratch-51007984e5c5\"\n  }), \"\\uC774\\uC804\\uC5D0 \\uC62C\\uB9B0 \\u201Cbuild your own React\\u201D \\uD3EC\\uC2A4\\uD2B8\"), \"\\uB4E4\\uACFC\\uB294 \\uB2EC\\uB9AC \\uC774\\uBC88 \\uD3EC\\uC2A4\\uD2B8\\uC5D0\\uC11C\\uB294 \\uB9AC\\uC561\\uD2B8 16.8 \\uBC84\\uC804\\uC744 \\uAE30\\uBC18\\uC73C\\uB85C \\uD558\\uACE0 \\uC788\\uC2B5\\uB2C8\\uB2E4. \\uC774\\uC81C \\uD6C5\\uC744 \\uC0AC\\uC6A9\\uD560 \\uC218 \\uC788\\uC73C\\uBA70, \\uD074\\uB798\\uC2A4\\uC640 \\uAD00\\uB828\\uB41C \\uCF54\\uB4DC\\uB97C \\uC81C\\uAC70\\uD560 \\uC218 \\uC788\\uC2B5\\uB2C8\\uB2E4.\"), mdx(\"p\", null, \"\\uC774\\uC804\\uC758 \\uC624\\uB798\\uB41C \\uBE14\\uB85C\\uADF8 \\uD3EC\\uC2A4\\uD2B8\\uC640 \\uCF54\\uB4DC\\uC758 \\uD788\\uC2A4\\uD1A0\\uB9AC\\uB294 \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/pomber/didact\"\n  }), \"Didact repo\"), \"\\uC5D0\\uC11C \\uD655\\uC778\\uD560 \\uC218 \\uC788\\uC2B5\\uB2C8\\uB2E4. \\uB610, \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://youtu.be/8Kc2REHdwnQ\"\n  }), \"\\uB3D9\\uC77C\\uD55C \\uB0B4\\uC6A9\\uC744 \\uB2E4\\uB8E8\\uB294 \\uCF58\\uD150\\uCE20\"), \"\\uB3C4 \\uC788\\uC9C0\\uB9CC, \\uC774\\uB294 \\uADF8\\uC640 \\uB3C5\\uB9BD\\uC801\\uC778 \\uD3EC\\uC2A4\\uD2B8\\uC785\\uB2C8\\uB2E4.\"), mdx(\"p\", null, \"\\uC6B0\\uB9AC\\uAC00 \\uC0C8\\uB86D\\uAC8C \\uB9CC\\uB4E4 \\uBC84\\uC804\\uC758 \\uB9AC\\uC561\\uD2B8\\uC5D0 \\uB4E4\\uC5B4\\uAC08 \\uB0B4\\uC6A9\\uB4E4\\uC744 \\uD558\\uB098\\uC529 \\uC18C\\uAC1C\\uD569\\uB2C8\\uB2E4:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Step I\"), \": \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"createElement\"), \" \\uD568\\uC218\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Step II\"), \": \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"render\"), \" \\uD568\\uC218\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Step III\"), \": \\uB3D9\\uC2DC\\uC131 \\uBAA8\\uB4DC (Concurrent Mode)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Step IV\"), \": Fibers\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Step V\"), \": \\uB80C\\uB354\\uC640 \\uCEE4\\uBC0B \\uB2E8\\uACC4 (Render and Commit Phases)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Step VI\"), \": \\uC7AC\\uC870\\uC815 (Reconciliation)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Step VII\"), \": \\uD568\\uC218\\uD615 \\uCEF4\\uD3EC\\uB10C\\uD2B8 (Function Components)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Step VIII\"), \": \\uD6C5 (Hooks)\")), mdx(CodeWave, {\n    mdxType: \"CodeWave\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\"\n  }), \"const element = <h1 title=\\\"foo\\\">Hello</h1>\\nconst container = document.getElementById(\\\"root\\\")\\nReactDOM.render(element, container)\\n\")), mdx(\"h2\", {\n    \"id\": \"step-zero-review\"\n  }, \"Step Zero: Review\"), mdx(\"p\", null, \"\\uBA3C\\uC800 \\uAE30\\uBCF8 \\uAC1C\\uB150\\uC744 \\uBCF5\\uC2B5\\uD574 \\uBCF4\\uACA0\\uC2B5\\uB2C8\\uB2E4. React, JSX, DOM \\uC5D8\\uB9AC\\uBA3C\\uD2B8\\uAC00 \\uB3D9\\uC791\\uD558\\uB294 \\uBC29\\uC2DD\\uC744 \\uC774\\uBBF8 \\uC798 \\uC54C\\uACE0 \\uC788\\uB2E4\\uBA74 \\uC774 \\uB2E8\\uACC4\\uB294 \\uAC74\\uB108 \\uB6F0\\uC5B4\\uB3C4 \\uB429\\uB2C8\\uB2E4.\"), mdx(\"p\", null, \"\\uC774 3\\uC904\\uC9DC\\uB9AC \\uCF54\\uB4DC\\uB85C \\uB41C \\uB9AC\\uC561\\uD2B8 \\uC571\\uC744 \\uC0AC\\uC6A9\\uD560 \\uAC83\\uC785\\uB2C8\\uB2E4. \\uCCAB \\uBC88\\uC9F8 \\uC904\\uC740 \\uB9AC\\uC561\\uD2B8 \\uC5D8\\uB9AC\\uBA3C\\uD2B8\\uB97C \\uC815\\uC758\\uD569\\uB2C8\\uB2E4. \\uADF8\\uB2E4\\uC74C DOM\\uC73C\\uB85C\\uBD80\\uD130 \\uB178\\uB4DC\\uB97C \\uC5BB\\uC2B5\\uB2C8\\uB2E4. \\uB9C8\\uC9C0\\uB9C9\\uC73C\\uB85C, \\uCEE8\\uD14C\\uC774\\uB108 \\uC548\\uC5D0 \\uB9AC\\uC561\\uD2B8 \\uC5D8\\uB9AC\\uBA3C\\uD2B8\\uB97C \\uC0DD\\uC131\\uD569\\uB2C8\\uB2E4.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"\\uC774\\uC81C \\uB9AC\\uC561\\uD2B8 \\uD2B9\\uC720\\uC758 \\uCF54\\uB4DC\\uB97C \\uBAA8\\uB450 \\uC81C\\uAC70\\uD558\\uACE0 \\uC774\\uB97C \\uC21C\\uC218\\uD55C \\uBC14\\uB2D0\\uB77C \\uC790\\uBC14\\uC2A4\\uD06C\\uB9BD\\uD2B8\\uB85C \\uAD50\\uCCB4\\uD574 \\uBD05\\uC2DC\\uB2E4.\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"1\": true,\n    \"className\": \"language-jsx\",\n    \"metastring\": \"1\"\n  }), \"const element = <h1 title=\\\"foo\\\">Hello</h1>\\nconst container = document.getElementById(\\\"root\\\")\\nReactDOM.render(element, container)\\n\")), mdx(\"p\", null, \"\\uB9E8 \\uCCAB \\uC904\\uC5D0, JSX\\uB85C \\uC815\\uC758\\uB41C \\uC5D8\\uB9AC\\uBA3C\\uD2B8\\uAC00 \\uC788\\uC2B5\\uB2C8\\uB2E4. \\uC774\\uB294 \\uC790\\uBC14\\uC2A4\\uD06C\\uB9BD\\uD2B8\\uC5D0\\uC11C \\uC720\\uD6A8\\uD55C \\uBB38\\uBC95\\uC774 \\uC544\\uB2C8\\uBBC0\\uB85C \\uBC14\\uB2D0\\uB77C JS\\uB85C \\uAD50\\uCCB4\\uD558\\uAE30 \\uC704\\uD574\\uC11C\\uB294 \\uC720\\uD6A8\\uD55C JS \\uCF54\\uB4DC\\uAC00 \\uD544\\uC694\\uD569\\uB2C8\\uB2E4.\"), mdx(\"p\", null, \"JSX\\uB294 \\uBC14\\uBCA8\\uACFC \\uAC19\\uC740 \\uBE4C\\uB4DC \\uD234\\uC5D0 \\uC758\\uD574 JS \\uCF54\\uB4DC\\uB85C \\uBCC0\\uD658\\uB429\\uB2C8\\uB2E4. \\uBCC0\\uD658\\uC740 \\uB300\\uCCB4\\uB85C \\uAC04\\uB2E8\\uD569\\uB2C8\\uB2E4. \\uD0DC\\uADF8 \\uC774\\uB984, props, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"children\"), \"\\uB97C \\uB9E4\\uAC1C\\uBCC0\\uC218\\uB85C \\uB118\\uAE30\\uB294 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"createElement\"), \" \\uD568\\uC218\\uB97C \\uD638\\uCD9C\\uD558\\uC5EC \\uD0DC\\uADF8 \\uB0B4\\uBD80\\uC758 \\uCF54\\uB4DC\\uB97C \\uBC14\\uAFB8\\uBA74 \\uB429\\uB2C8\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\"\n  }), \"const element = React.createElement(\\n  \\\"h1\\\",\\n  { title: \\\"foo\\\" },\\n  \\\"Hello\\\"\\n)\\n\\nconst container = document.getElementById(\\\"root\\\")\\nReactDOM.render(element, container)\\n\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React.createElement\"), \"\\uB294 \\uC778\\uC790 \\uAC12\\uB4E4\\uB85C \\uAC1D\\uCCB4\\uB97C \\uC0DD\\uC131\\uD569\\uB2C8\\uB2E4. \\uBA87 \\uAC00\\uC9C0 \\uC720\\uD6A8\\uC131 \\uAC80\\uC0AC\\uB97C \\uC81C\\uC678\\uD558\\uACE0\\uB294 \\uC774\\uAC8C \\uC804\\uBD80\\uC785\\uB2C8\\uB2E4. \\uB530\\uB77C\\uC11C \\uC548\\uC804\\uD558\\uAC8C \\uD568\\uC218 \\uD638\\uCD9C \\uBD80\\uBD84\\uC744 \\uADF8 \\uACB0\\uACFC\\uBB3C\\uB85C \\uBC14\\uAFC0 \\uC218 \\uC788\\uC2B5\\uB2C8\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\"\n  }), \"const element = {\\n  type: \\\"h1\\\",\\n  props: {\\n    title: \\\"foo\\\",\\n    children: \\\"Hello\\\",\\n  },\\n}\\n\\nconst container = document.getElementById(\\\"root\\\")\\nReactDOM.render(element, container)\\n\")), mdx(\"p\", null, \"\\uADF8\\uB9AC\\uACE0 \\uBC14\\uB85C \\uC774 element\\uAC00 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"type\"), \"\\uACFC \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"props\"), \"\\uB97C \\uAC1D\\uCCB4 \\uC18D\\uC131 \\uAC12\\uC73C\\uB85C \\uAC00\\uC9C0\\uB294 \\uAC1D\\uCCB4\\uC785\\uB2C8\\uB2E4. (\\uC0AC\\uC2E4 \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/facebook/react/blob/f4cc45ce962adc9f307690e1d5cfa28a288418eb/packages/react/src/ReactElement.js#L111\"\n  }), \"\\uC2E4\\uC81C\\uB85C\\uB294 \\uB354 \\uB9CE\\uC740 \\uC18D\\uC131\"), \"\\uC774 \\uC788\\uC9C0\\uB9CC, \\uC5EC\\uAE30\\uC11C\\uB294 \\uB450 \\uAC00\\uC9C0\\uB9CC \\uC2E0\\uACBD \\uC4F0\\uB3C4\\uB85D \\uD569\\uB2C8\\uB2E4)\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"type\"), \"\\uC740 \\uC6B0\\uB9AC\\uAC00 \\uC0DD\\uC131\\uD558\\uB824\\uB294 DOM \\uB178\\uB4DC\\uC758 \\uD0C0\\uC785\\uC744 \\uC9C0\\uC815\\uD558\\uB294 \\uBB38\\uC790\\uC5F4\\uC785\\uB2C8\\uB2E4. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"tagName\"), \"\\uC740 HTML \\uC5D8\\uB9AC\\uBA3C\\uD2B8\\uB97C \\uC0DD\\uC131\\uD560 \\uB54C \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"document.createElement\"), \"\\uC5D0 \\uC804\\uB2EC\\uD558\\uB294 \\uAC12\\uC785\\uB2C8\\uB2E4. \\uC774 \\uBD80\\uBD84\\uC740 7\\uB2E8\\uACC4\\uC5D0\\uC11C \\uBCF4\\uB3C4\\uB85D \\uD558\\uACA0\\uC2B5\\uB2C8\\uB2E4.\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"props\"), \"\\uB294 JSX \\uC18D\\uC131\\uC758 key\\uC640 value\\uB97C \\uD3EC\\uD568\\uD558\\uACE0 \\uC788\\uB294 \\uB610 \\uD558\\uB098\\uC758 \\uAC1D\\uCCB4\\uC785\\uB2C8\\uB2E4. \\uC774 \\uC5ED\\uC2DC \\uD2B9\\uBCC4\\uD55C \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"children\"), \"\\uC774\\uB77C\\uB294 \\uD2B9\\uBCC4\\uD55C \\uC18D\\uC131\\uC744 \\uAC00\\uC9D1\\uB2C8\\uB2E4.\"), mdx(\"p\", null, \"\\uC774 \\uC608\\uC81C\\uC5D0\\uC11C \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"children\"), \"\\uC740 \\uBB38\\uC790\\uC5F4\\uC785\\uB2C8\\uB2E4. \\uD558\\uC9C0\\uB9CC \\uC77C\\uBC18\\uC801\\uC73C\\uB85C \\uB354 \\uB9CE\\uC740 \\uC5D8\\uB9AC\\uBA3C\\uD2B8\\uC758 \\uBC30\\uC5F4\\uC758 \\uD615\\uD0DC\\uC785\\uB2C8\\uB2E4. \\uC774\\uAC83\\uC774 \\uC5D8\\uB9AC\\uBA3C\\uD2B8\\uB4E4\\uC774 \\uD2B8\\uB9AC \\uD615\\uD0DC\\uC778 \\uC774\\uC720\\uC785\\uB2C8\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"10\": true,\n    \"className\": \"language-jsx\",\n    \"metastring\": \"10\"\n  }), \"const element = {\\n  type: \\\"h1\\\",\\n  props: {\\n    title: \\\"foo\\\",\\n    children: \\\"Hello\\\",\\n  },\\n}\\n\\nconst container = document.getElementById(\\\"root\\\")\\nReactDOM.render(element, container)\\n\")), mdx(\"p\", null, \"\\uAD50\\uCCB4\\uD574\\uC57C \\uD560 \\uB9AC\\uC561\\uD2B8 \\uCF54\\uB4DC\\uC758 \\uB2E4\\uB978 \\uBD80\\uBD84\\uC740 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ReactDOM.render\"), \"\\uB77C\\uACE0 \\uBD80\\uB974\\uB294 \\uAC83\\uC785\\uB2C8\\uB2E4.\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"render\"), \"\\uB294 \\uB9AC\\uC561\\uD2B8\\uAC00 DOM\\uC744 \\uBCC0\\uACBD\\uD558\\uB294 \\uC9C0\\uC810\\uC73C\\uB85C, \\uC774\\uC81C \\uC6B0\\uB9AC\\uAC00 \\uC9C1\\uC811 \\uC5C5\\uB370\\uC774\\uD2B8\\uB97C \\uD560 \\uC218 \\uC788\\uAC8C \\uD574 \\uBD05\\uC2DC\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"1,2,4,7,11,12\",\n    \"1,2,4,7,11,12\": true\n  }), \"const element = {\\n  type: \\\"h1\\\",\\n  props: {\\n    title: \\\"foo\\\",\\n    children: \\\"Hello\\\",\\n  },\\n}\\n\\nconst container = document.getElementById(\\\"root\\\")\\n\\nconst node = document.createElement(element.type)\\nnode[\\\"title\\\"] = element.props.title\\n\\nconst text = document.createTextNode(\\\"\\\")\\ntext[\\\"nodeValue\\\"] = element.props.children\\n\\nnode.appendChild(text)\\ncontainer.appendChild(node)\\n\")), mdx(\"p\", null, \"\\uBA3C\\uC800 \\uC5D8\\uB9AC\\uBA3C\\uD2B8\\uC758 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"type\"), \"\\uC744 \\uC774\\uC6A9\\uD574 \\uB178\\uB4DC\\uB97C \\uC0DD\\uC131\\uD569\\uB2C8\\uB2E4. \\uC774 \\uACBD\\uC6B0 \\uD0C0\\uC785\\uC740 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"h1\"), \"\\uC785\\uB2C8\\uB2E4.\"), mdx(\"p\", null, \"\\uADF8\\uB9AC\\uACE0 \\uBAA8\\uB4E0 \\uC5D8\\uB9AC\\uBA3C\\uD2B8 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"props\"), \"\\uB4E4\\uC744 \\uB178\\uB4DC\\uC5D0 \\uD560\\uB2F9\\uD569\\uB2C8\\uB2E4. \\uC9C0\\uAE08\\uC740 title \\uBFD0\\uC785\\uB2C8\\uB2E4.\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"*\", \" \\uC5EC\\uAE30\\uC11C \\u201C\\uC5D8\\uB9AC\\uBA3C\\uD2B8\\u201D\\uB294 \\uB9AC\\uC561\\uD2B8 \\uC5D8\\uB9AC\\uBA3C\\uD2B8\\uB97C, \\u201C\\uB178\\uB4DC\\u201D\\uB294 DOM \\uC5D8\\uB9AC\\uBA3C\\uD2B8\\uB97C \\uC758\\uBBF8\\uD569\\uB2C8\\uB2E4.\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\",\n    \"metastring\": \"1,5,7,14,15\",\n    \"1,5,7,14,15\": true\n  }), \"const element = {\\n  type: \\\"h1\\\",\\n  props: {\\n    title: \\\"foo\\\",\\n    children: \\\"Hello\\\",\\n  },\\n}\\n\\nconst container = document.getElementById(\\\"root\\\")\\n\\nconst node = document.createElement(element.type)\\nnode[\\\"title\\\"] = element.props.title\\n\\nconst text = document.createTextNode(\\\"\\\")\\ntext[\\\"nodeValue\\\"] = element.props.children\\n\\nnode.appendChild(text)\\ncontainer.appendChild(node)\\n\")), mdx(\"p\", null, \"\\uB2E4\\uC74C\\uC73C\\uB85C, \\uC790\\uC2DD \\uB178\\uB4DC\\uB4E4\\uC744 \\uC0DD\\uC131\\uD569\\uB2C8\\uB2E4. \\uD604\\uC7AC \\uC790\\uC2DD \\uB178\\uB4DC\\uB294 \\uBB38\\uC790\\uC5F4 \\uD558\\uB098\\uBFD0\\uC774\\uBBC0\\uB85C, \\uD14D\\uC2A4\\uD2B8 \\uB178\\uB4DC \\uD558\\uB098\\uB97C \\uC0DD\\uC131\\uD569\\uB2C8\\uB2E4.\"), mdx(\"p\", null, \"\\uC774\\uB54C \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"innterText\"), \"\\uB97C \\uC124\\uC815\\uD558\\uB294 \\uB300\\uC2E0 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"textNode\"), \"\\uB97C \\uC0AC\\uC6A9\\uD558\\uBA74 \\uBAA8\\uB4E0 \\uC5D8\\uB9AC\\uBA3C\\uD2B8\\uB4E4\\uC744 \\uC774\\uD6C4\\uC5D0 \\uB3D9\\uC77C\\uD55C \\uBC29\\uC2DD\\uC73C\\uB85C \\uB2E4\\uB8F0 \\uC218 \\uC788\\uC2B5\\uB2C8\\uB2E4. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"h1\"), \"\\uC5D0 title\\uC744 \\uD560\\uB2F9\\uD55C \\uAC83\\uC744 \\uCC38\\uACE0\\uD558\\uC5EC \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"nodeValue\"), \"\\uC758 \\uAC12\\uC744 \\uC124\\uC815\\uD569\\uB2C8\\uB2E4. \\uC774\\uB294 \\uBB38\\uC790\\uC5F4\\uC774 \\uB9C8\\uCE58 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"props: {nodeValue: \\\"hello\\\"}\"), \" \\uAC12\\uC744 \\uAC00\\uC9C0\\uB294 \\uAC83\\uACFC \\uBE44\\uC2B7\\uD569\\uB2C8\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\",\n    \"metastring\": \"9,17,18\",\n    \"9,17,18\": true\n  }), \"const element = {\\n  type: \\\"h1\\\",\\n  props: {\\n    title: \\\"foo\\\",\\n    children: \\\"Hello\\\",\\n  },\\n}\\n\\nconst container = document.getElementById(\\\"root\\\")\\n\\nconst node = document.createElement(element.type)\\nnode[\\\"title\\\"] = element.props.title\\n\\nconst text = document.createTextNode(\\\"\\\")\\ntext[\\\"nodeValue\\\"] = element.props.children\\n\\nnode.appendChild(text)\\ncontainer.appendChild(node)\\n\")), mdx(\"p\", null, \"\\uB9C8\\uC9C0\\uB9C9\\uC73C\\uB85C \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"textNode\"), \"\\uB97C \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"h1\"), \"\\uC5D0 \\uCD94\\uAC00\\uD558\\uACE0, \\uC774 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"h1\"), \"\\uC744 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"container\"), \"\\uC5D0 \\uCD94\\uAC00\\uD569\\uB2C8\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\",\n    \"metastring\": \"1:18\",\n    \"1:18\": true\n  }), \"const element = {\\n  type: \\\"h1\\\",\\n  props: {\\n    title: \\\"foo\\\",\\n    children: \\\"Hello\\\",\\n  },\\n}\\n\\nconst container = document.getElementById(\\\"root\\\")\\n\\nconst node = document.createElement(element.type)\\nnode[\\\"title\\\"] = element.props.title\\n\\nconst text = document.createTextNode(\\\"\\\")\\ntext[\\\"nodeValue\\\"] = element.props.children\\n\\nnode.appendChild(text)\\ncontainer.appendChild(node)\\n\")), mdx(\"p\", null, \"\\uC790, \\uC774\\uC81C \\uB9AC\\uC561\\uD2B8\\uB97C \\uC0AC\\uC6A9\\uD558\\uC9C0 \\uC54A\\uACE0 \\uADF8\\uAC83\\uACFC \\uB3D9\\uC77C\\uD55C \\uC571\\uC744 \\uC644\\uC131\\uD588\\uC2B5\\uB2C8\\uB2E4.\")), mdx(CodeWave, {\n    mdxType: \"CodeWave\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./00.jsx\",\n    \"file\": \"./00.jsx\"\n  }), \"const element = (\\n  <div id=\\\"foo\\\">\\n    <a>bar</a>\\n    <b />\\n  </div>\\n)\\nconst container = document.getElementById(\\\"root\\\")\\nReactDOM.render(element, container)\\n\")), mdx(\"h2\", {\n    \"id\": \"step-i-createelement-함수\"\n  }, \"Step I: createElement \\uD568\\uC218\"), mdx(\"p\", null, \"\\uB2E4\\uC2DC \\uB2E4\\uB978 \\uC571\\uC73C\\uB85C \\uC2DC\\uC791\\uD574 \\uBD05\\uC2DC\\uB2E4. \\uC5EC\\uAE30\\uC11C\\uB294 \\uB9AC\\uC561\\uD2B8 \\uCF54\\uB4DC\\uB97C \\uC6B0\\uB9AC\\uAC00 \\uC9C1\\uC811 \\uB9CC\\uB4E0 \\uBC84\\uC804\\uC73C\\uB85C \\uAD50\\uCCB4\\uD574 \\uBCFC \\uAC83\\uC785\\uB2C8\\uB2E4.\"), mdx(\"p\", null, \"\\uC6B0\\uB9AC\\uAC00 \\uB9CC\\uB4E0 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"createElement\"), \"\\uB97C \\uC785\\uB825\\uD558\\uB294 \\uAC83\\uBD80\\uD130 \\uC2DC\\uC791\\uD574 \\uBD05\\uC2DC\\uB2E4.\"), mdx(\"p\", null, \"JSX\\uB97C JS\\uB85C \\uBCC0\\uD658\\uD558\\uBA74 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"createElement\"), \"\\uB97C \\uD638\\uCD9C\\uD558\\uB294 \\uAC83\\uC744 \\uBCFC \\uC218 \\uC788\\uC2B5\\uB2C8\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./01.jsx\",\n    \"file\": \"./01.jsx\"\n  }), \"const element = React.createElement(\\n  \\\"div\\\",\\n  { id: \\\"foo\\\" },\\n  React.createElement(\\\"a\\\", null, \\\"bar\\\"),\\n  React.createElement(\\\"b\\\")\\n)\\nconst container = document.getElementById(\\\"root\\\")\\nReactDOM.render(element, container)\\n\")), mdx(\"p\", null, \"\\uC774\\uC804 \\uB2E8\\uACC4\\uC5D0\\uC11C \\uBCF4\\uC558\\uB358 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"type\"), \"\\uACFC \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"props\"), \"\\uB97C \\uAC00\\uC9C4 \\uAC1D\\uCCB4 \\uC5D8\\uB9AC\\uBA3C\\uD2B8\\uC785\\uB2C8\\uB2E4. \\uC6B0\\uB9AC\\uAC00 \\uB9CC\\uB4E4 \\uD568\\uC218\\uAC00 \\uD558\\uB294 \\uC77C\\uC740 \\uAC1D\\uCCB4\\uB97C \\uC0DD\\uC131\\uD558\\uB294 \\uAC83 \\uBFD0\\uC785\\uB2C8\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./02.jsx\",\n    \"file\": \"./02.jsx\"\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children,\\n    },\\n  }\\n}\\n\\nconst element = React.createElement(\\n  \\\"div\\\",\\n  { id: \\\"foo\\\" },\\n  React.createElement(\\\"a\\\", null, \\\"bar\\\"),\\n  React.createElement(\\\"b\\\")\\n)\\nconst container = document.getElementById(\\\"root\\\")\\nReactDOM.render(element, container)\\n\")), mdx(\"p\", null, \"\\uC6B0\\uB9AC\\uB294 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"props\"), \"\\uC5D0 \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"\\uC2A4\\uD504\\uB808\\uB4DC \\uC5F0\\uC0B0\\uC790\"), \"(\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"spread operator\"), \")\\uB97C \\uC0AC\\uC6A9\\uD558\\uACE0, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"children\"), \"\\uC5D0 \\uB098\\uBA38\\uC9C0 \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"\\uD30C\\uB77C\\uBBF8\\uD130 \\uAD6C\\uBB38\"), \"(\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"rest parameter syntax\"), \")\\uC744 \\uC801\\uC6A9\\uD558\\uBA74, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"children\"), \"\\uC774 \\uD56D\\uC0C1 \\uBC30\\uC5F4 \\uD615\\uD0DC\\uAC00 \\uB429\\uB2C8\\uB2E4.\"), mdx(\"div\", null, mdx(\"p\", null, \"\\uC608\\uB97C \\uB4E4\\uC5B4, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"createElement(\\\"div\\\")\"), \"\\uC740 \\uB2E4\\uC74C\\uC744 \\uBC18\\uD658\\uD569\\uB2C8\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-json\"\n  }), \"{\\n  \\\"type\\\": \\\"div\\\",\\n  \\\"props\\\": { \\\"children\\\": [] }\\n}\\n\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"createElement(\\\"div\\\", null, a)\"), \"\\uC758 \\uACB0\\uACFC\\uB294 \\uB2E4\\uC74C\\uACFC \\uAC19\\uC2B5\\uB2C8\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-json\"\n  }), \"{\\n  \\\"type\\\": \\\"div\\\",\\n  \\\"props\\\": { \\\"children\\\": [a] }\\n}\\n\")), mdx(\"p\", null, \"\\uADF8\\uB9AC\\uACE0 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"createElement(\\\"div\\\", null, a, b)\"), \"\\uC758 \\uACB0\\uACFC\\uB294 \\uB2E4\\uC74C\\uACFC \\uAC19\\uC2B5\\uB2C8\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-json\"\n  }), \"{\\n  \\\"type\\\": \\\"div\\\",\\n  \\\"props\\\": { \\\"children\\\": [a, b] }\\n}\\n\"))), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./03.jsx\",\n    \"file\": \"./03.jsx\"\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children: children.map(child =>\\n        typeof child === \\\"object\\\"\\n          ? child\\n          : createTextElement(child)\\n      ),\\n    },\\n  }\\n}\\n\\nfunction createTextElement(text) {\\n  return {\\n    type: \\\"TEXT_ELEMENT\\\",\\n    props: {\\n      nodeValue: text,\\n      children: [],\\n    },\\n  }\\n}\\n\\nconst element = React.createElement(\\n  \\\"div\\\",\\n  { id: \\\"foo\\\" },\\n  React.createElement(\\\"a\\\", null, \\\"bar\\\"),\\n  React.createElement(\\\"b\\\")\\n)\\nconst container = document.getElementById(\\\"root\\\")\\nReactDOM.render(element, container)\\n\")), mdx(\"p\", null, \"\\uB610\\uD55C \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"children\"), \" \\uBC30\\uC5F4\\uC740 string\\uC774\\uB098 number\\uACFC \\uAC19\\uC740 \\uAE30\\uBCF8 \\uD0C0\\uC785\\uC758 \\uAC12\\uB4E4\\uC744 \\uD3EC\\uD568\\uD560 \\uC218 \\uC788\\uC2B5\\uB2C8\\uB2E4. \\uB530\\uB77C\\uC11C \\uC6B0\\uB9AC\\uB294 \\uAC1D\\uCCB4\\uAC00 \\uC544\\uB2CC \\uBAA8\\uB4E0 \\uAC83\\uB4E4\\uC744 \\uAC10\\uC2F8\\uC11C \\uC790\\uCCB4 \\uC5D8\\uB9AC\\uBA3C\\uD2B8 \\uC548\\uC5D0 \\uB123\\uACE0, \\uC774\\uB97C \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TEXT_ELEMENT\"), \"\\uB77C\\uB294 \\uD2B9\\uBCC4\\uD55C \\uD0C0\\uC785\\uC73C\\uB85C \\uC0DD\\uC131\\uD560 \\uC218 \\uC788\\uC2B5\\uB2C8\\uB2E4.\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"\\uC2E4\\uC81C \\uB9AC\\uC561\\uD2B8\\uC5D0\\uC11C\\uB294 \", mdx(\"inlineCode\", {\n    parentName: \"em\"\n  }, \"children\"), \"\\uC774 \\uC544\\uB2D0 \\uACBD\\uC6B0\\uC5D4 \\uAE30\\uBCF8 \\uD0C0\\uC785\\uC758 \\uAC12\\uB4E4\\uC744 \\uB798\\uD551\\uD558\\uAC70\\uB098 \\uBE48 \\uBC30\\uC5F4\\uC744 \\uC0DD\\uC131\\uD558\\uC9C0 \\uC54A\\uC2B5\\uB2C8\\uB2E4. \\uD558\\uC9C0\\uB9CC \\uCF54\\uB4DC\\uB97C \\uAC04\\uACB0\\uD558\\uAC8C \\uB9CC\\uB4E4\\uACE0, \\uC6B0\\uB9AC\\uC758 \\uB77C\\uC774\\uBE0C\\uB7EC\\uB9AC\\uC758 \\uBAA9\\uC801\\uC740 \\uC131\\uB2A5\\uC774 \\uAC1C\\uC120\\uB41C \\uCF54\\uB4DC\\uBCF4\\uB2E4\\uB294 \\uAC04\\uB2E8\\uD55C \\uCF54\\uB4DC\\uB97C \\uB9CC\\uB4DC\\uB294 \\uB370 \\uC788\\uC73C\\uBBC0\\uB85C \\uADF8\\uB0E5 \\uC9C4\\uD589\\uD558\\uB3C4\\uB85D \\uD569\\uB2C8\\uB2E4.\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./03.jsx  25,28,29,30\",\n    \"file\": \"./03.jsx\",\n    \"\": true,\n    \"25,28,29,30\": true\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children: children.map(child =>\\n        typeof child === \\\"object\\\"\\n          ? child\\n          : createTextElement(child)\\n      ),\\n    },\\n  }\\n}\\n\\nfunction createTextElement(text) {\\n  return {\\n    type: \\\"TEXT_ELEMENT\\\",\\n    props: {\\n      nodeValue: text,\\n      children: [],\\n    },\\n  }\\n}\\n\\nconst element = React.createElement(\\n  \\\"div\\\",\\n  { id: \\\"foo\\\" },\\n  React.createElement(\\\"a\\\", null, \\\"bar\\\"),\\n  React.createElement(\\\"b\\\")\\n)\\nconst container = document.getElementById(\\\"root\\\")\\nReactDOM.render(element, container)\\n\")), mdx(\"p\", null, \"\\uC544\\uC9C1\\uAE4C\\uC9C0\\uB294 \\uACC4\\uC18D \\uB9AC\\uC561\\uD2B8\\uC758 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"createElement\"), \"\\uB97C \\uC0AC\\uC6A9\\uD558\\uACE0 \\uC788\\uB294 \\uC0C1\\uD0DC\\uC785\\uB2C8\\uB2E4.\"), mdx(\"p\", null, \"\\uC774\\uC81C \\uC774\\uB97C \\uAD50\\uCCB4\\uD558\\uAE30 \\uC704\\uD574, \\uC6B0\\uB9AC\\uC758 \\uB77C\\uC774\\uBE0C\\uB7EC\\uB9AC\\uC5D0 \\uC774\\uB984\\uC744 \\uBD80\\uC5EC\\uD569\\uB2C8\\uB2E4. \\uB9AC\\uC561\\uD2B8\\uAC19\\uC774 \\uB4E4\\uB9AC\\uC9C0\\uB9CC \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"\\uAD50\\uC721\\uC801\\uC778\"), \"(\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"didactic\"), \") \\uBAA9\\uC801\\uC774 \\uB4DC\\uB7EC\\uB098\\uB294 \\uC774\\uB984\\uC774 \\uD544\\uC694\\uD569\\uB2C8\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./04.jsx\",\n    \"file\": \"./04.jsx\"\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children: children.map(child =>\\n        typeof child === \\\"object\\\"\\n          ? child\\n          : createTextElement(child)\\n      ),\\n    },\\n  }\\n}\\n\\nfunction createTextElement(text) {\\n  return {\\n    type: \\\"TEXT_ELEMENT\\\",\\n    props: {\\n      nodeValue: text,\\n      children: [],\\n    },\\n  }\\n}\\n\\nconst Didact = {\\n  createElement,\\n}\\n\\nconst element = Didact.createElement(\\n  \\\"div\\\",\\n  { id: \\\"foo\\\" },\\n  Didact.createElement(\\\"a\\\", null, \\\"bar\\\"),\\n  Didact.createElement(\\\"b\\\")\\n)\\nconst container = document.getElementById(\\\"root\\\")\\nReactDOM.render(element, container)\\n\")), mdx(\"p\", null, \"\\uC774\\uC81C \\uC774\\uB97C \\u201C\\uB514\\uC561\\uD2B8(Didact)\\u201C\\uB77C\\uACE0 \\uBD80\\uB974\\uB3C4\\uB85D \\uD569\\uC2DC\\uB2E4.\"), mdx(\"p\", null, \"\\uD558\\uC9C0\\uB9CC \\uC5EC\\uAE30\\uC11C\\uB3C4 JSX\\uB294 \\uACC4\\uC18D \\uC0AC\\uC6A9\\uD558\\uACE0 \\uC2F6\\uC2B5\\uB2C8\\uB2E4. \\uC5B4\\uB5BB\\uAC8C \\uBC14\\uBCA8\\uC5D0\\uAC8C \\uB9AC\\uC561\\uD2B8 \\uB300\\uC2E0 \\uC6B0\\uB9AC\\uAC00 \\uB9CC\\uB4E0 \\uB514\\uC561\\uD2B8\\uC758 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"createElement\"), \"\\uB97C \\uC0AC\\uC6A9\\uD558\\uB3C4\\uB85D \\uD560 \\uC218 \\uC788\\uC744\\uAE4C\\uC694?\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./05.jsx\",\n    \"file\": \"./05.jsx\"\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children: children.map(child =>\\n        typeof child === \\\"object\\\"\\n          ? child\\n          : createTextElement(child)\\n      ),\\n    },\\n  }\\n}\\n\\nfunction createTextElement(text) {\\n  return {\\n    type: \\\"TEXT_ELEMENT\\\",\\n    props: {\\n      nodeValue: text,\\n      children: [],\\n    },\\n  }\\n}\\n\\nconst Didact = {\\n  createElement,\\n}\\n\\n/** @jsx Didact.createElement */\\nconst element = (\\n  <div id=\\\"foo\\\">\\n    <a>bar</a>\\n    <b />\\n  </div>\\n)\\nconst container = document.getElementById(\\\"root\\\")\\nReactDOM.render(element, container)\\n\")), mdx(\"p\", null, \"\\uCF54\\uBA58\\uD2B8\\uB97C \\uC704\\uC640 \\uAC19\\uC774 \\uCD94\\uAC00\\uD558\\uBA74 \\uBC14\\uBCA8\\uC774 JSX\\uB97C \\uD2B8\\uB79C\\uC2A4\\uD30C\\uC77C \\uD560 \\uB54C \\uC6B0\\uB9AC\\uAC00 \\uC815\\uC758\\uD55C \\uD568\\uC218\\uB97C \\uC0AC\\uC6A9\\uD560 \\uC218 \\uC788\\uAC8C \\uB429\\uB2C8\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"37\": true,\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./05.jsx 37\",\n    \"file\": \"./05.jsx\"\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children: children.map(child =>\\n        typeof child === \\\"object\\\"\\n          ? child\\n          : createTextElement(child)\\n      ),\\n    },\\n  }\\n}\\n\\nfunction createTextElement(text) {\\n  return {\\n    type: \\\"TEXT_ELEMENT\\\",\\n    props: {\\n      nodeValue: text,\\n      children: [],\\n    },\\n  }\\n}\\n\\nconst Didact = {\\n  createElement,\\n}\\n\\n/** @jsx Didact.createElement */\\nconst element = (\\n  <div id=\\\"foo\\\">\\n    <a>bar</a>\\n    <b />\\n  </div>\\n)\\nconst container = document.getElementById(\\\"root\\\")\\nReactDOM.render(element, container)\\n\")), mdx(\"h2\", {\n    \"id\": \"step-ii-render-함수\"\n  }, \"Step II: render \\uD568\\uC218\"), mdx(\"p\", null, \"\\uB2E4\\uC74C\\uC73C\\uB85C \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ReactDOM.render\"), \" \\uD568\\uC218\\uB97C \\uC6B0\\uB9AC \\uBC84\\uC804\\uC73C\\uB85C \\uBC14\\uAFD4 \\uBD05\\uC2DC\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./06.jsx 25:27,29,31,32,42\",\n    \"file\": \"./06.jsx\",\n    \"25:27,29,31,32,42\": true\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children: children.map(child =>\\n        typeof child === \\\"object\\\"\\n          ? child\\n          : createTextElement(child)\\n      ),\\n    },\\n  }\\n}\\n\\nfunction createTextElement(text) {\\n  return {\\n    type: \\\"TEXT_ELEMENT\\\",\\n    props: {\\n      nodeValue: text,\\n      children: [],\\n    },\\n  }\\n}\\n\\nfunction render(element, container) {\\n  // TODO create dom nodes\\n}\\n\\nconst Didact = {\\n  createElement,\\n  render,\\n}\\n\\n/** @jsx Didact.createElement */\\nconst element = (\\n  <div id=\\\"foo\\\">\\n    <a>bar</a>\\n    <b />\\n  </div>\\n)\\nconst container = document.getElementById(\\\"root\\\")\\nDidact.render(element, container)\\n\")), mdx(\"p\", null, \"\\uC9C0\\uAE08\\uAE4C\\uC9C0\\uB294 DOM\\uC5D0 \\uC5B4\\uB5A4 \\uAC83\\uB4E4\\uC744 \\uCD94\\uAC00\\uD558\\uB294 \\uAC83\\uC5D0\\uB9CC \\uC9D1\\uC911\\uD588\\uB2E4\\uBA74, \\uC774\\uC81C \\uAC31\\uC2E0\\uACFC \\uC0AD\\uC81C\\uB97C \\uB2E4\\uB8E8\\uC5B4\\uBCF4\\uACA0\\uC2B5\\uB2C8\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./07.jsx 25:29\",\n    \"file\": \"./07.jsx\",\n    \"25:29\": true\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children: children.map(child =>\\n        typeof child === \\\"object\\\"\\n          ? child\\n          : createTextElement(child)\\n      ),\\n    },\\n  }\\n}\\n\\nfunction createTextElement(text) {\\n  return {\\n    type: \\\"TEXT_ELEMENT\\\",\\n    props: {\\n      nodeValue: text,\\n      children: [],\\n    },\\n  }\\n}\\n\\nfunction render(element, container) {\\n  const dom = document.createElement(element.type)\\n\\n  container.appendChild(dom)\\n}\\n\\nconst Didact = {\\n  createElement,\\n  render,\\n}\\n\\n/** @jsx Didact.createElement */\\nconst element = (\\n  <div id=\\\"foo\\\">\\n    <a>bar</a>\\n    <b />\\n  </div>\\n)\\nconst container = document.getElementById(\\\"root\\\")\\nDidact.render(element, container)\\n\")), mdx(\"p\", null, \"\\uC5D8\\uB9AC\\uBA3C\\uD2B8 \\uD0C0\\uC785\\uC744 \\uC774\\uC6A9\\uD558\\uC5EC DOM \\uB178\\uB4DC\\uB97C \\uC0DD\\uC131\\uD558\\uB294 \\uAC83\\uBD80\\uD130 \\uC2DC\\uC791\\uD558\\uACA0\\uC2B5\\uB2C8\\uB2E4. \\uADF8 \\uB2E4\\uC74C \\uC0C8\\uB86D\\uAC8C \\uB9CC\\uB4E4\\uC5B4\\uC9C4 \\uB178\\uB4DC\\uB97C \\uCEE8\\uD14C\\uC774\\uB108\\uC5D0 \\uCD94\\uAC00\\uD569\\uB2C8\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./08.jsx 25,28:30,33\",\n    \"file\": \"./08.jsx\",\n    \"25,28:30,33\": true\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children: children.map(child =>\\n        typeof child === \\\"object\\\"\\n          ? child\\n          : createTextElement(child)\\n      ),\\n    },\\n  }\\n}\\n\\nfunction createTextElement(text) {\\n  return {\\n    type: \\\"TEXT_ELEMENT\\\",\\n    props: {\\n      nodeValue: text,\\n      children: [],\\n    },\\n  }\\n}\\n\\nfunction render(element, container) {\\n  const dom = document.createElement(element.type)\\n\\n  element.props.children.forEach(child =>\\n    render(child, dom)\\n  )\\n\\n  container.appendChild(dom)\\n}\\n\\nconst Didact = {\\n  createElement,\\n  render,\\n}\\n\\n/** @jsx Didact.createElement */\\nconst element = (\\n  <div id=\\\"foo\\\">\\n    <a>bar</a>\\n    <b />\\n  </div>\\n)\\nconst container = document.getElementById(\\\"root\\\")\\nDidact.render(element, container)\\n\")), mdx(\"p\", null, \"\\uC774 \\uACFC\\uC815\\uC744 \\uAC01\\uAC01\\uC758 \\uC790\\uC2DD\\uB4E4 \\uBAA8\\uB450\\uC5D0\\uAC8C \\uC7AC\\uADC0\\uC801\\uC73C\\uB85C \\uC218\\uD589\\uD569\\uB2C8\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./09.jsx\",\n    \"file\": \"./09.jsx\"\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children: children.map(child =>\\n        typeof child === \\\"object\\\"\\n          ? child\\n          : createTextElement(child)\\n      ),\\n    },\\n  }\\n}\\n\\nfunction createTextElement(text) {\\n  return {\\n    type: \\\"TEXT_ELEMENT\\\",\\n    props: {\\n      nodeValue: text,\\n      children: [],\\n    },\\n  }\\n}\\n\\nfunction render(element, container) {\\n  const dom =\\n    element.type == \\\"TEXT_ELEMENT\\\"\\n      ? document.createTextNode(\\\"\\\")\\n      : document.createElement(element.type)\\n\\n  element.props.children.forEach(child =>\\n    render(child, dom)\\n  )\\n\\n  container.appendChild(dom)\\n}\\n\\nconst Didact = {\\n  createElement,\\n  render,\\n}\\n\\n/** @jsx Didact.createElement */\\nconst element = (\\n  <div id=\\\"foo\\\">\\n    <a>bar</a>\\n    <b />\\n  </div>\\n)\\nconst container = document.getElementById(\\\"root\\\")\\nDidact.render(element, container)\\n\")), mdx(\"p\", null, \"\\uB610\\uD55C \\uD14D\\uC2A4\\uD2B8 \\uC5D8\\uB9AC\\uBA3C\\uD2B8\\uB3C4 \\uCC98\\uB9AC\\uD574\\uC57C \\uD569\\uB2C8\\uB2E4. \\uB9CC\\uC57D \\uD0C0\\uC785\\uC774 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TEXT_ELEMENT\"), \"\\uC778 \\uACBD\\uC6B0, \\uC77C\\uBC18\\uC801\\uC778 \\uB178\\uB4DC \\uB300\\uC2E0 \\uD14D\\uC2A4\\uD2B8 \\uB178\\uB4DC\\uB97C \\uC0DD\\uC131\\uD558\\uB3C4\\uB85D \\uD569\\uB2C8\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./10.jsx\",\n    \"file\": \"./10.jsx\"\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children: children.map(child =>\\n        typeof child === \\\"object\\\"\\n          ? child\\n          : createTextElement(child)\\n      ),\\n    },\\n  }\\n}\\n\\nfunction createTextElement(text) {\\n  return {\\n    type: \\\"TEXT_ELEMENT\\\",\\n    props: {\\n      nodeValue: text,\\n      children: [],\\n    },\\n  }\\n}\\n\\nfunction render(element, container) {\\n  const dom =\\n    element.type == \\\"TEXT_ELEMENT\\\"\\n      ? document.createTextNode(\\\"\\\")\\n      : document.createElement(element.type)\\n\\n  const isProperty = key => key !== \\\"children\\\"\\n  Object.keys(element.props)\\n    .filter(isProperty)\\n    .forEach(name => {\\n      dom[name] = element.props[name]\\n    })\\n\\n  element.props.children.forEach(child =>\\n    render(child, dom)\\n  )\\n\\n  container.appendChild(dom)\\n}\\n\\nconst Didact = {\\n  createElement,\\n  render,\\n}\\n\\n/** @jsx Didact.createElement */\\nconst element = (\\n  <div id=\\\"foo\\\">\\n    <a>bar</a>\\n    <b />\\n  </div>\\n)\\nconst container = document.getElementById(\\\"root\\\")\\nDidact.render(element, container)\\n\")), mdx(\"p\", null, \"\\uB9C8\\uC9C0\\uB9C9\\uC73C\\uB85C \\uD574\\uC57C \\uD560 \\uAC83\\uC740 \\uB178\\uB4DC\\uC5D0 \\uC5D8\\uB9AC\\uBA3C\\uD2B8 \\uC18D\\uC131\\uB4E4\\uC744 \\uBD80\\uC5EC\\uD558\\uB294 \\uAC83\\uC785\\uB2C8\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./10.jsx 1:58\",\n    \"file\": \"./10.jsx\",\n    \"1:58\": true\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children: children.map(child =>\\n        typeof child === \\\"object\\\"\\n          ? child\\n          : createTextElement(child)\\n      ),\\n    },\\n  }\\n}\\n\\nfunction createTextElement(text) {\\n  return {\\n    type: \\\"TEXT_ELEMENT\\\",\\n    props: {\\n      nodeValue: text,\\n      children: [],\\n    },\\n  }\\n}\\n\\nfunction render(element, container) {\\n  const dom =\\n    element.type == \\\"TEXT_ELEMENT\\\"\\n      ? document.createTextNode(\\\"\\\")\\n      : document.createElement(element.type)\\n\\n  const isProperty = key => key !== \\\"children\\\"\\n  Object.keys(element.props)\\n    .filter(isProperty)\\n    .forEach(name => {\\n      dom[name] = element.props[name]\\n    })\\n\\n  element.props.children.forEach(child =>\\n    render(child, dom)\\n  )\\n\\n  container.appendChild(dom)\\n}\\n\\nconst Didact = {\\n  createElement,\\n  render,\\n}\\n\\n/** @jsx Didact.createElement */\\nconst element = (\\n  <div id=\\\"foo\\\">\\n    <a>bar</a>\\n    <b />\\n  </div>\\n)\\nconst container = document.getElementById(\\\"root\\\")\\nDidact.render(element, container)\\n\")), mdx(\"p\", null, \"\\uB05D\\uC785\\uB2C8\\uB2E4. \\uC774\\uC81C JSX\\uB97C DOM\\uC73C\\uB85C \\uB80C\\uB354\\uB9C1 \\uD560 \\uC218 \\uC788\\uB294 \\uB77C\\uC774\\uBE0C\\uB7EC\\uB9AC\\uB97C \\uB9CC\\uB4E4\\uC5C8\\uC2B5\\uB2C8\\uB2E4.\"), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://codesandbox.io/s/didact-2-k6rbj\"\n  }), \"codesandbox\"), \"\\uC5D0\\uC11C \\uD14C\\uC2A4\\uD2B8 \\uD560 \\uC218 \\uC788\\uC2B5\\uB2C8\\uB2E4.\")), mdx(\"h2\", {\n    \"id\": \"step-iii-동시성-모드-concurrent-mode\"\n  }, \"Step III: \\uB3D9\\uC2DC\\uC131 \\uBAA8\\uB4DC (Concurrent Mode)\"), mdx(\"p\", null, \"\\uB2E4\\uB978 \\uCF54\\uB4DC\\uB97C \\uCD94\\uAC00\\uD558\\uAE30 \\uC804\\uC5D0, \\uC57D\\uAC04 \\uB9AC\\uD329\\uD1A0\\uB9C1\\uC774 \\uD544\\uC694\\uD569\\uB2C8\\uB2E4.\"), mdx(CodeWave, {\n    mdxType: \"CodeWave\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./10.jsx 25,38:40,43\",\n    \"file\": \"./10.jsx\",\n    \"25,38:40,43\": true\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children: children.map(child =>\\n        typeof child === \\\"object\\\"\\n          ? child\\n          : createTextElement(child)\\n      ),\\n    },\\n  }\\n}\\n\\nfunction createTextElement(text) {\\n  return {\\n    type: \\\"TEXT_ELEMENT\\\",\\n    props: {\\n      nodeValue: text,\\n      children: [],\\n    },\\n  }\\n}\\n\\nfunction render(element, container) {\\n  const dom =\\n    element.type == \\\"TEXT_ELEMENT\\\"\\n      ? document.createTextNode(\\\"\\\")\\n      : document.createElement(element.type)\\n\\n  const isProperty = key => key !== \\\"children\\\"\\n  Object.keys(element.props)\\n    .filter(isProperty)\\n    .forEach(name => {\\n      dom[name] = element.props[name]\\n    })\\n\\n  element.props.children.forEach(child =>\\n    render(child, dom)\\n  )\\n\\n  container.appendChild(dom)\\n}\\n\\nconst Didact = {\\n  createElement,\\n  render,\\n}\\n\\n/** @jsx Didact.createElement */\\nconst element = (\\n  <div id=\\\"foo\\\">\\n    <a>bar</a>\\n    <b />\\n  </div>\\n)\\nconst container = document.getElementById(\\\"root\\\")\\nDidact.render(element, container)\\n\")), mdx(\"p\", null, \"\\uC7AC\\uADC0 \\uD638\\uCD9C\\uC774 \\uBB38\\uC81C\\uC785\\uB2C8\\uB2E4.\"), mdx(\"p\", null, \"\\uC6B0\\uB9AC\\uAC00 \\uB80C\\uB354\\uB9C1\\uC744 \\uC2DC\\uC791\\uD558\\uBA74, \\uBAA8\\uB4E0 \\uC5D8\\uB9AC\\uBA3C\\uD2B8 \\uD2B8\\uB9AC\\uB97C \\uB80C\\uB354\\uB9C1 \\uD558\\uB294 \\uAC83\\uC744 \\uB9C8\\uCE58\\uAE30 \\uC804\\uAE4C\\uC9C0\\uB294 \\uC774\\uB97C \\uBA48\\uCD9C \\uC218 \\uC5C6\\uC2B5\\uB2C8\\uB2E4. \\uB9CC\\uC57D \\uC5D8\\uB9AC\\uBA3C\\uD2B8 \\uD2B8\\uB9AC\\uAC00 \\uD06C\\uB2E4\\uBA74 \\uBA54\\uC778 \\uC2A4\\uB808\\uB4DC\\uC758 \\uB3D9\\uC791\\uC774 \\uB108\\uBB34 \\uC624\\uB7AB\\uB3D9\\uC548 \\uBA48\\uCD9C \\uAC83\\uC785\\uB2C8\\uB2E4. \\uADF8\\uB9AC\\uACE0 \\uBE0C\\uB77C\\uC6B0\\uC800\\uAC00 \\uC720\\uC800\\uC758 \\uC785\\uB825\\uC774\\uB098 \\uC560\\uB2C8\\uBA54\\uC774\\uC158\\uC744 \\uBD80\\uB4DC\\uB7FD\\uAC8C \\uD558\\uB294 \\uAC83\\uC5D0 \\uB192\\uC740 \\uC6B0\\uC120\\uC21C\\uC704\\uB97C \\uB450\\uACE0 \\uC788\\uB2E4\\uBA74, \\uC774 \\uC791\\uC5C5\\uB4E4\\uC740 \\uB80C\\uB354\\uB9C1\\uC774 \\uB05D\\uB098\\uAE30 \\uC804\\uAE4C\\uC9C0 \\uB300\\uAE30\\uD574\\uC57C \\uD569\\uB2C8\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./11.jsx\",\n    \"file\": \"./11.jsx\"\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children: children.map(child =>\\n        typeof child === \\\"object\\\"\\n          ? child\\n          : createTextElement(child)\\n      ),\\n    },\\n  }\\n}\\n\\nfunction createTextElement(text) {\\n  return {\\n    type: \\\"TEXT_ELEMENT\\\",\\n    props: {\\n      nodeValue: text,\\n      children: [],\\n    },\\n  }\\n}\\n\\nfunction render(element, container) {\\n  const dom =\\n    element.type == \\\"TEXT_ELEMENT\\\"\\n      ? document.createTextNode(\\\"\\\")\\n      : document.createElement(element.type)\\n\\n  const isProperty = key => key !== \\\"children\\\"\\n  Object.keys(element.props)\\n    .filter(isProperty)\\n    .forEach(name => {\\n      dom[name] = element.props[name]\\n    })\\n\\n  element.props.children.forEach(child =>\\n    render(child, dom)\\n  )\\n\\n  container.appendChild(dom)\\n}\\n\\nlet nextUnitOfWork = null\\n\\nfunction workLoop(deadline) {\\n  let shouldYield = false\\n  while (nextUnitOfWork && !shouldYield) {\\n    nextUnitOfWork = performUnitOfWork(\\n      nextUnitOfWork\\n    )\\n    shouldYield = deadline.timeRemaining() < 1\\n  }\\n  requestIdleCallback(workLoop)\\n}\\n\\nrequestIdleCallback(workLoop)\\n\\nfunction performUnitOfWork(nextUnitOfWork) {\\n  // TODO\\n}\\n\\nconst Didact = {\\n  createElement,\\n  render,\\n}\\n\\n/** @jsx Didact.createElement */\\nconst element = (\\n  <div id=\\\"foo\\\">\\n    <a>bar</a>\\n    <b />\\n  </div>\\n)\\nconst container = document.getElementById(\\\"root\\\")\\nDidact.render(element, container)\\n\")), mdx(\"p\", null, \"\\uB530\\uB77C\\uC11C \\uC791\\uC5C5\\uC744 \\uB354 \\uC791\\uC740 \\uB2E8\\uC704\\uB85C \\uB098\\uB208 \\uB2E4\\uC74C, \\uAC01\\uAC01\\uC758 \\uB2E8\\uC704\\uB9C8\\uB2E4 \\uBE0C\\uB77C\\uC6B0\\uC800\\uAC00 \\uC5B4\\uB5A4 \\uC791\\uC5C5\\uC774 \\uD544\\uC694\\uD55C \\uACBD\\uC6B0 \\uB80C\\uB354\\uB9C1 \\uB3C4\\uC911\\uC5D0 \\uB07C\\uC5B4\\uB4E4 \\uC218 \\uC788\\uB3C4\\uB85D \\uD560 \\uAC83\\uC785\\uB2C8\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./11.jsx 47,55,56,58\",\n    \"file\": \"./11.jsx\",\n    \"47,55,56,58\": true\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children: children.map(child =>\\n        typeof child === \\\"object\\\"\\n          ? child\\n          : createTextElement(child)\\n      ),\\n    },\\n  }\\n}\\n\\nfunction createTextElement(text) {\\n  return {\\n    type: \\\"TEXT_ELEMENT\\\",\\n    props: {\\n      nodeValue: text,\\n      children: [],\\n    },\\n  }\\n}\\n\\nfunction render(element, container) {\\n  const dom =\\n    element.type == \\\"TEXT_ELEMENT\\\"\\n      ? document.createTextNode(\\\"\\\")\\n      : document.createElement(element.type)\\n\\n  const isProperty = key => key !== \\\"children\\\"\\n  Object.keys(element.props)\\n    .filter(isProperty)\\n    .forEach(name => {\\n      dom[name] = element.props[name]\\n    })\\n\\n  element.props.children.forEach(child =>\\n    render(child, dom)\\n  )\\n\\n  container.appendChild(dom)\\n}\\n\\nlet nextUnitOfWork = null\\n\\nfunction workLoop(deadline) {\\n  let shouldYield = false\\n  while (nextUnitOfWork && !shouldYield) {\\n    nextUnitOfWork = performUnitOfWork(\\n      nextUnitOfWork\\n    )\\n    shouldYield = deadline.timeRemaining() < 1\\n  }\\n  requestIdleCallback(workLoop)\\n}\\n\\nrequestIdleCallback(workLoop)\\n\\nfunction performUnitOfWork(nextUnitOfWork) {\\n  // TODO\\n}\\n\\nconst Didact = {\\n  createElement,\\n  render,\\n}\\n\\n/** @jsx Didact.createElement */\\nconst element = (\\n  <div id=\\\"foo\\\">\\n    <a>bar</a>\\n    <b />\\n  </div>\\n)\\nconst container = document.getElementById(\\\"root\\\")\\nDidact.render(element, container)\\n\")), mdx(\"p\", null, \"\\uBC18\\uBCF5\\uBB38\\uC744 \\uB9CC\\uB4E4\\uAE30 \\uC704\\uD574 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"requestIdleCallback\"), \" \\uD568\\uC218\\uB97C \\uC0AC\\uC6A9\\uD569\\uB2C8\\uB2E4. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"requestIdleCallback\"), \"\\uC740 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"setTimeout\"), \" \\uAC19\\uC740 \\uAC83\\uC73C\\uB85C \\uC0DD\\uAC01\\uD558\\uBA74 \\uB429\\uB2C8\\uB2E4. \\uD558\\uC9C0\\uB9CC \\uC5B8\\uC81C \\uC2E4\\uD589\\uD574\\uC57C \\uD560\\uC9C0\\uB97C \\uC54C\\uB824\\uC8FC\\uB294 \\uB300\\uC2E0, \\uBA54\\uC778 \\uC2A4\\uB808\\uB4DC\\uAC00 \\uB300\\uAE30 \\uC0C1\\uD0DC\\uC77C \\uB54C \\uBE0C\\uB77C\\uC6B0\\uC800\\uAC00 \\uCF5C\\uBC31\\uC744 \\uC2E4\\uD589\\uD560 \\uAC83\\uC785\\uB2C8\\uB2E4.\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"\\uB9AC\\uC561\\uD2B8\\uB294 \", mdx(\"a\", _extends({\n    parentName: \"em\"\n  }, {\n    \"href\": \"https://github.com/facebook/react/issues/11171#issuecomment-417349573\"\n  }), mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"requestIdleCallback\"), \"\\uC744 \\uB354 \\uC774\\uC0C1 \\uC0AC\\uC6A9\\uD558\\uC9C0 \\uC54A\\uACE0\"), \" \\uB300\\uC2E0, \", mdx(\"a\", _extends({\n    parentName: \"em\"\n  }, {\n    \"href\": \"https://github.com/facebook/react/tree/master/packages/scheduler\"\n  }), \"scheduler package\"), \"\\uB97C \\uC0AC\\uC6A9\\uD569\\uB2C8\\uB2E4. \\uAC1C\\uB150\\uC801\\uC73C\\uB85C\\uB294 \\uB3D9\\uC77C\\uD569\\uB2C8\\uB2E4.\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./11.jsx 47,48,49,53,54,56\",\n    \"file\": \"./11.jsx\",\n    \"47,48,49,53,54,56\": true\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children: children.map(child =>\\n        typeof child === \\\"object\\\"\\n          ? child\\n          : createTextElement(child)\\n      ),\\n    },\\n  }\\n}\\n\\nfunction createTextElement(text) {\\n  return {\\n    type: \\\"TEXT_ELEMENT\\\",\\n    props: {\\n      nodeValue: text,\\n      children: [],\\n    },\\n  }\\n}\\n\\nfunction render(element, container) {\\n  const dom =\\n    element.type == \\\"TEXT_ELEMENT\\\"\\n      ? document.createTextNode(\\\"\\\")\\n      : document.createElement(element.type)\\n\\n  const isProperty = key => key !== \\\"children\\\"\\n  Object.keys(element.props)\\n    .filter(isProperty)\\n    .forEach(name => {\\n      dom[name] = element.props[name]\\n    })\\n\\n  element.props.children.forEach(child =>\\n    render(child, dom)\\n  )\\n\\n  container.appendChild(dom)\\n}\\n\\nlet nextUnitOfWork = null\\n\\nfunction workLoop(deadline) {\\n  let shouldYield = false\\n  while (nextUnitOfWork && !shouldYield) {\\n    nextUnitOfWork = performUnitOfWork(\\n      nextUnitOfWork\\n    )\\n    shouldYield = deadline.timeRemaining() < 1\\n  }\\n  requestIdleCallback(workLoop)\\n}\\n\\nrequestIdleCallback(workLoop)\\n\\nfunction performUnitOfWork(nextUnitOfWork) {\\n  // TODO\\n}\\n\\nconst Didact = {\\n  createElement,\\n  render,\\n}\\n\\n/** @jsx Didact.createElement */\\nconst element = (\\n  <div id=\\\"foo\\\">\\n    <a>bar</a>\\n    <b />\\n  </div>\\n)\\nconst container = document.getElementById(\\\"root\\\")\\nDidact.render(element, container)\\n\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"requestIdleCallback\"), \"\\uC740 \\uB370\\uB4DC\\uB77C\\uC778 \\uB9E4\\uAC1C \\uBCC0\\uC218\\uB97C \\uC81C\\uACF5\\uD569\\uB2C8\\uB2E4. \\uC774\\uB97C \\uC774\\uC6A9\\uD558\\uC5EC \\uB2E4\\uC2DC \\uBE0C\\uB77C\\uC6B0\\uC800\\uC5D0\\uC11C \\uC81C\\uC5B4\\uB97C \\uAC00\\uC838\\uAC08 \\uB54C\\uAE4C\\uC9C0 \\uC5BC\\uB9C8\\uB098 \\uAC78\\uB9AC\\uB294\\uC9C0\\uB97C \\uCCB4\\uD06C\\uD560 \\uC218 \\uC788\\uC2B5\\uB2C8\\uB2E4.\"), mdx(\"div\", null, mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"2019\\uB144 11\\uC6D4 \\uD604\\uC7AC, \\uB3D9\\uC2DC\\uC131 \\uBAA8\\uB4DC\\uB294 \\uC544\\uC9C1 \\uB9AC\\uC561\\uD2B8\\uC758 \\uC548\\uC815\\uC801\\uC778 \\uBC84\\uC804\\uC5D0 \\uD3EC\\uD568\\uB418\\uC9C0 \\uC54A\\uC558\\uC2B5\\uB2C8\\uB2E4. \\uC548\\uC815 \\uBC84\\uC804\\uC5D0\\uC11C\\uC758 \\uBC18\\uBCF5\\uBB38\\uC740 \\uB2E4\\uC74C\\uACFC \\uAC19\\uC2B5\\uB2C8\\uB2E4.\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"while (nextUnitOfWork) {    \\n  nextUnitOfWork = performUnitOfWork(   \\n    nextUnitOfWork  \\n  ) \\n}   \\n\"))), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./11.jsx 45,47,50:52,56,60:62\",\n    \"file\": \"./11.jsx\",\n    \"45,47,50:52,56,60:62\": true\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children: children.map(child =>\\n        typeof child === \\\"object\\\"\\n          ? child\\n          : createTextElement(child)\\n      ),\\n    },\\n  }\\n}\\n\\nfunction createTextElement(text) {\\n  return {\\n    type: \\\"TEXT_ELEMENT\\\",\\n    props: {\\n      nodeValue: text,\\n      children: [],\\n    },\\n  }\\n}\\n\\nfunction render(element, container) {\\n  const dom =\\n    element.type == \\\"TEXT_ELEMENT\\\"\\n      ? document.createTextNode(\\\"\\\")\\n      : document.createElement(element.type)\\n\\n  const isProperty = key => key !== \\\"children\\\"\\n  Object.keys(element.props)\\n    .filter(isProperty)\\n    .forEach(name => {\\n      dom[name] = element.props[name]\\n    })\\n\\n  element.props.children.forEach(child =>\\n    render(child, dom)\\n  )\\n\\n  container.appendChild(dom)\\n}\\n\\nlet nextUnitOfWork = null\\n\\nfunction workLoop(deadline) {\\n  let shouldYield = false\\n  while (nextUnitOfWork && !shouldYield) {\\n    nextUnitOfWork = performUnitOfWork(\\n      nextUnitOfWork\\n    )\\n    shouldYield = deadline.timeRemaining() < 1\\n  }\\n  requestIdleCallback(workLoop)\\n}\\n\\nrequestIdleCallback(workLoop)\\n\\nfunction performUnitOfWork(nextUnitOfWork) {\\n  // TODO\\n}\\n\\nconst Didact = {\\n  createElement,\\n  render,\\n}\\n\\n/** @jsx Didact.createElement */\\nconst element = (\\n  <div id=\\\"foo\\\">\\n    <a>bar</a>\\n    <b />\\n  </div>\\n)\\nconst container = document.getElementById(\\\"root\\\")\\nDidact.render(element, container)\\n\")), mdx(\"p\", null, \"\\uBC18\\uBCF5\\uBB38\\uC744 \\uC2DC\\uC791\\uD558\\uB824\\uBA74 \\uCCAB \\uBC88\\uC9F8 \\uC791\\uC5C5 \\uB2E8\\uC704\\uB97C \\uC124\\uC815\\uD574\\uC57C \\uD569\\uB2C8\\uB2E4. \\uADF8\\uB9AC\\uACE0 \\uADF8 \\uC791\\uC5C5\\uC744 \\uC218\\uD589\\uD558\\uB294 \\uAC83 \\uBFD0\\uB9CC \\uC544\\uB2C8\\uB77C \\uB2E4\\uC74C \\uC791\\uC5C5 \\uB2E8\\uC704\\uB97C \\uBC18\\uD658\\uD558\\uAE30 \\uC704\\uD574 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"performUnitOfWork\"), \" \\uD568\\uC218\\uB97C \\uC791\\uC131\\uD569\\uB2C8\\uB2E4.\")), mdx(\"h2\", {\n    \"id\": \"step-iv-fibers\"\n  }, \"Step IV: Fibers\"), mdx(\"p\", null, \"\\uC791\\uC5C5 \\uB2E8\\uC704\\uB4E4\\uC744 \\uAD6C\\uC870\\uD654\\uD558\\uAE30 \\uC704\\uD574\\uC11C\\uB294 fiber tree\\uB77C\\uB294 \\uC790\\uB8CC\\uAD6C\\uC870\\uAC00 \\uD544\\uC694\\uD569\\uB2C8\\uB2E4.\"), mdx(\"p\", null, \"\\uC5D8\\uB9AC\\uBA3C\\uD2B8\\uB9C8\\uB2E4 \\uD558\\uB098\\uC758 fiber\\uB97C \\uAC00\\uC9C0\\uBA70, \\uAC01\\uAC01\\uC758 fiber\\uB294 \\uD558\\uB098\\uC758 \\uC791\\uC5C5 \\uB2E8\\uC704\\uAC00 \\uB429\\uB2C8\\uB2E4.\"), mdx(\"p\", null, \"\\uB2E4\\uC74C\\uC758 \\uC608\\uC2DC\\uB97C \\uBCF4\\uACA0\\uC2B5\\uB2C8\\uB2E4.\"), mdx(ImageWaveLocal, {\n    background: \"#232129\",\n    mdxType: \"ImageWaveLocal\"\n  }, mdx(\"p\", null, mdx(\"span\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"274px\"\n    }\n  }), \"\\n      \", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"116.05839416058394%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAXCAYAAAALHW+jAAAACXBIWXMAAAsTAAALEwEAmpwYAAAC90lEQVQ4y51US08UQRCe2UVh5eFCgAUEVsSQVWPk6MGIr3AxJh48GG/+Dg968c7Fi8aDJsao0QSQxJsXFRMVQQWqe7p7llkSMCaGh48QiePXPbPrLAzJwiSVru7p/rrqq6/asjZ8rqCyseDNWUqwKu2/e//a2vanBNnh2A27ADsLOxmu7QgwHFk1/DZYM6xhx4D6k/nZMG2RdCXLKMlSBlCynUQYHFKcJVzBWzDvBlDDtgA1b6pUjODQtMuSAOvDvE0ovkevzTvcevSTKuMsWtnil3eo4Ysn7OJ8ZLnyCHOweiMTTia1e2tULxQdmnMoO7pETXf/UFL/f7sQgILbrSkA2BVYj/Y9J5DNkx900FF0CfNTL75T/y2fqkuZSFY2xgGeg7Von6utOWIuq3Il3xUF2xQlFmqVpBMANNLIhzxOeqbKaRzcLyXrCAtWj0IdjZyN5V5HeNiVVFcmbM4TiKYVllaCN0X2pnBJt3KdCJdkzpUKDOcyrDfaelOekU0OB9KOYukgemaHEdVhX7v2n62S/ckLztxfIy2NGQ1yEdalF1FV+4b/P4WxJWdLTj/MU0lSo4ufSzzUAOw8rFbPJ8JNwyt0gFwagBb7n65SD6qc/DvBbexvA5f7MPaEaujCvkFEfXxsifo0BwmAZWFGFuMLQXRIJTOTpxwizjz8Ra3DK8zoEF2DYrEaFMrQgH/Ns3k6hrXcyDJ1xr6FjyPtpVXgP+eJ0NcFSZd++jE6NFWK9DK5waapOUQueQtu7hWKNYayqYEdAfBu09ucmUJM58lGwcoCiX1t4HdAMq0ATm0IIlt80nCZ9eorWR8LZN1ZjwGERIJRamGzXtheqYKIii+R65DmvVn71yKKQCHj5RAXuj/OrJe+sNw8s9U3EXTTfAWvTxFsyKfaN4t0Zsqj0w9+U9bwWoDYJc8g0k6knNNrN31KIeWByQIN3l6nzCZA/YD6Q8HNkEMnHovMdZ9MlScKTHNru2hLIQIZWUgZndLIXWq/in3/AJCPTz/cEX4IAAAAAElFTkSuQmCC')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  })), \"\\n  \", mdx(\"img\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"Fiber Tree 0\",\n    \"title\": \"Fiber Tree 0\",\n    \"src\": \"/static/de664d437c94d478778b965c66c91f99/d3fa7/fiber0.png\",\n    \"srcSet\": [\"/static/de664d437c94d478778b965c66c91f99/d3fa7/fiber0.png 274w\"],\n    \"sizes\": \"(max-width: 274px) 100vw, 274px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\"\n  })), \"\\n    \")), mdx(\"p\", null, \"\\uB2E4\\uC74C\\uACFC \\uAC19\\uC774 \\uC0DD\\uAE34 \\uD2B8\\uB9AC\\uB97C \\uB80C\\uB354\\uB9C1 \\uD558\\uACE0 \\uC2F6\\uB2E4\\uACE0 \\uD569\\uC2DC\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\"\n  }), \"Didact.render(\\n  <div>\\n    <h1>\\n      <p />\\n      <a />\\n    </h1>\\n    <h2 />\\n  </div>,\\n  container\\n)\\n\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"render\"), \" \\uD568\\uC218 \\uB0B4\\uBD80\\uC5D0 \\uB8E8\\uD2B8 fiber\\uB97C \\uC0DD\\uC131\\uD558\\uACE0, \\uC774\\uB97C \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"nextUnitOfWork\"), \"\\uB85C \\uC124\\uC815\\uD569\\uB2C8\\uB2E4. \\uB0A8\\uC740 \\uC791\\uC5C5\\uB4E4\\uC740 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"performUnitOfWork\"), \" \\uD568\\uC218\\uC5D0\\uC11C \\uC77C\\uC5B4\\uB098\\uB294\\uB370, \\uAC01\\uAC01\\uC758 fiber\\uC5D0\\uC11C\\uB294 \\uB2E4\\uC74C 3\\uAC00\\uC9C0 \\uC791\\uC5C5\\uC744 \\uD569\\uB2C8\\uB2E4.\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"DOM\\uC5D0 \\uC5D8\\uB9AC\\uBA3C\\uD2B8\\uB97C \\uCD94\\uAC00\\uD558\\uAE30\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"\\uAC01 \\uC5D8\\uB9AC\\uBA3C\\uD2B8\\uC758 children\\uC5D0 \\uB300\\uD574 fiber\\uB97C \\uC0DD\\uC131\\uD558\\uAE30\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"\\uB2E4\\uC74C \\uC791\\uC5C5 \\uB2E8\\uC704\\uB97C \\uC120\\uD0DD\\uD558\\uAE30\")), mdx(\"p\", null, mdx(\"span\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"274px\"\n    }\n  }), \"\\n      \", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"116.05839416058394%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAXCAYAAAALHW+jAAAACXBIWXMAAAsTAAALEwEAmpwYAAAEX0lEQVQ4y4VUb2xTVRQ/fd3YyjbocFs3HBtjOCcGhfhFxcDwzzAxGj8YI0YTNGEJiewfyubWpRNZgAWTGXQfgAjDoFMcZIMRiInEKANNxDl5r/e17+21K3Udk73X0q19tX3X2/vWbnNdvMkv595z7/vd88753QPwnyEJaIG94xFgVEBpiX18zAhz8zTAnxN8RtCdDikH+dgwa0sIXpYE+3PEbtUv4XSi3rWABzcv+hZ761IQigK1oihkiG5vIc9P5DkdYyviPt/lDrqndcJyfBQsBCYS8WP4GLOV4EVYavRjrN8IYMT+dy1YfctE14FG6g+Eu41Bny1j2tWYpp4qWhn+an2++nV5kf/eoYxFZGrPw9RGvn+BiXVCfuxuc0nMf5BGiJVm/aLArgwc3P0Ant6diUMfbsbh/VU40vQE9u97Kpm30dkiRE6VU6tc2mKMfWqsiHn3FUZmOpfTNIwfp3vVv+H0V27h7B3EnhaGiw/YJyvaOLmsyR7OhQTR/Momk7wXVuC7YEisz8m/UtvMhZZ9wKnm/Zyasec23riXxVW1LH66jsVbEhFWEuTE52OCCJ7hi9ATEXKQ994jLqdYOqA4Vn0RtVO9DP19acncn3dfT0rlTYIySujQZXMuiNY7Re41t5OvujLFb+rGbDLhN7wXYOcwhkY2CvWsBiQyQz3BfO09T5AfnzskfskIZpSDaVhpSdcLZKW+y9IPUD+iq4KQxnXHZ42K6BlCSKXhuf0j3Ry/VcNoLWDWJpvXRv3tqymJ3Jqjya0bkzlWWnUrWxe9jg2SiLIp4chVXbwDGxjtMBRof9WbtYBtVZJEbjVpirVE8+skMdkGgtNFi5ssMJm8QUD14uau01xMXN1hjHVBJXbVmNXgITPV6FQ73QtOdWSrUx8VxeeDoSHDiIel/jMqIXQ5uTjhqwRr9KKwhobZl0IjurlkSkENtScLcdH3Z+Lt8pmE7CWCrPj61h2eHuoP8OuQS9jmFtCmvvuorBezxvduRgzv2/8pbOBiD9ZymKriuyBagyRUTTT85KCCKkASeYaQlRJQWdwY16t8/j5v4dzOShF5LWenpYJroWt63xrAjI33ZzZwGk1D7wzKs7vQ45LAVw74UXHKXvjl/F8O7swir4XRq9piwoFac2LPOu/cHInIL3jLct92an2/7GKihyGfyKY8Evg4l1ZetmYSPBqR25fRC6aa4HRoDFgXMrgEHr6dRosv0GY7r9a3jtE+gdWar7FACx4wLTgjW0tjchv1RZU2+MnngN89CE5EUxCqJ2gwEO59iMFdUI7HalZG1aN6RErTbPvaw5BWlhefvx6e++3+AEothwuTV1K097cBjmA46eIM0KOTiMpJ+N+RyEMXRllDPvTsHx60/WwIlcZ9ttGgsY7DFlLhYiKdyrjvCLabfp5A24Y9qPp4FFkWEX5DCHGXLh0ih2LHKLLYMKJV7pD88e5iIN2FaeRiuowwCyNjKNchoaJ3yLl/Aa71hnZuCFccAAAAAElFTkSuQmCC')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  })), \"\\n  \", mdx(\"img\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"Fiber Tree 1\",\n    \"title\": \"Fiber Tree 1\",\n    \"src\": \"/static/a88a3ec01855349c14302f6da28e2b0c/d3fa7/fiber1.png\",\n    \"srcSet\": [\"/static/a88a3ec01855349c14302f6da28e2b0c/d3fa7/fiber1.png 274w\"],\n    \"sizes\": \"(max-width: 274px) 100vw, 274px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\"\n  })), \"\\n    \")), mdx(\"p\", null, \"\\uC774 \\uC790\\uB8CC\\uAD6C\\uC870\\uC758 \\uBAA9\\uC801 \\uC911 \\uD558\\uB098\\uB294 \\uB2E4\\uC74C\\uC5D0 \\uD544\\uC694\\uD55C \\uC791\\uC5C5 \\uB2E8\\uC704\\uB97C \\uCC3E\\uAE30 \\uC27D\\uB3C4\\uB85D \\uD558\\uB294 \\uAC83\\uC785\\uB2C8\\uB2E4. \\uADF8\\uB798\\uC11C \\uAC01\\uAC01\\uC758 fiber\\uB294 \\uCCAB \\uBC88\\uC9F8 \\uC790\\uC2DD(\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"child\"), \")\\uACFC \\uD615\\uC81C\\uC790\\uB9E4(\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sibling\"), \"), \\uBD80\\uBAA8(\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"parent\"), \")\\uC758 \\uB9C1\\uD06C\\uB97C \\uAC00\\uC9D1\\uB2C8\\uB2E4.\"), mdx(\"p\", null, mdx(\"span\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"274px\"\n    }\n  }), \"\\n      \", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"116.05839416058394%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAXCAYAAAALHW+jAAAACXBIWXMAAAsTAAALEwEAmpwYAAAEM0lEQVQ4y4VUb2xTVRS/r+3WlW7OMmZpsrnNEQIaFeIX/wUm4tSgxoSYGD/pB2IMDoZGkERCxESJ0cjo+l7b19fVsrB1g8WOocxIxITiJ+dW1va+/nttN3WEMOnYslbmrufd9j0718Wb/HLOO/fe3z3vd869CP1nSHG8wqbTEkrGRZ0yT6xa9K+vQ8QG6AawFajsSMYxU7T3A14GPAvYQWOxSIGovxmRi9tX7SW/HVxNKCVExepTyahlOpOsz6TitXIse+UTOrf8OVpHvkBmgAEyfoRYNTsAL6C1xlJ+XvU7Dhwy7Nr9Iv1Ph7NAOJdjtfMzx/ULqfd0+R5Lbe7spvp8X6sle+sz/SqywQEftf19ZxlBEIw876x1CwJdeO3Sp4Vfm3tTT+b31ZGFfVVk8eh2kjvcRv468hjJvv+EqluyWARffx+1/LCP4Xm+TnC5qp3eHqr4Uc9VOtf+C6l4ZYxUPw/WEx9vOBG5uflY+M+WI5GcCSlEpZVVRqOlVVv63ZUpzH8YXqz8IJy/93A4r39nkjzcESJtB0LkyYMh8pSS4RZAjexPx0QUDl9HZ/JijZSOPZSJR5tGsuJ6111MyW3jY2tqP5QOqK3yBqBF9jOxQtsMzuNNsQTem4mJbaOz4jbrckQV/OPRCdQhEtQ5+TfqDC0jyIzpBJT23m5AvexHJXHNDBx9Xg3bbdPIPsdxNPbRDwnUGSTUB1IgS4jGZAI/DYQGOTg1+ROdHPv2bQ3hUJ3X8aXJ5nJTOVgbW8ly3H3KASzLolLy0gwflBK4mhIGR2nsJtfMEBZtHOCOGbo4d5WyFjZXAGoVEpeLR+lUjBZXLTA4rwNa6d0NB6gW0tBzWsLpto7Y9hu+8p6jhOxpq0JaCaAJeGeDaDwdoXu8eSBMxcIy4auARlqUaIg5RIiafTNae3BX/Kp/YeZ6MbuEWAVkewBGqt20SE/zz4kP4HRiZyqGt52/g1vOEEn7rkxit1eDdjWcw26S151bEBuxhNuhhx+/eBtvlh8BDZA1AWhb/PxHQYehO9gcSUW2/i7FNw7moubeWxO0uvYeFwOEOjvvoDL0L4obIin8qBQXtwxncUPZt/C7vKTGXtr7mnpbICsdkKkF8pdIs+K5Kr3L578fofbrHy8wgtttdDoc6+09gqHYJjooRj1Yeoj1xEnkuxtHoRRmUnERDSzgMkLbC+3A2jkGNtcAjADdijXQNmwx1u1yoMANEf06hRG/VIbQ4XUXXpteDwONbLJ2ndY7BV5bbGyFUD5snewPk1l1r38Ol28HTza4KnZ7vw15YgF6K5Qbwl/+Bv3v8BV1OEWwMTCDd01k8DO9i7hJjvVc9mtkCYDwHijQBjl2koiGqzfwzvEp3O5cwuayhORU4YGAdmiIJrH5OInQlvFeu6RkyNgFvvC6kCgKZrApKmHLWwRr/gEl21c705TikgAAAABJRU5ErkJggg==')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  })), \"\\n  \", mdx(\"img\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"Fiber Tree 2\",\n    \"title\": \"Fiber Tree 2\",\n    \"src\": \"/static/c1105e4f7fc7292d91c78caee258d20d/d3fa7/fiber2.png\",\n    \"srcSet\": [\"/static/c1105e4f7fc7292d91c78caee258d20d/d3fa7/fiber2.png 274w\"],\n    \"sizes\": \"(max-width: 274px) 100vw, 274px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\"\n  })), \"\\n    \")), mdx(\"p\", null, \"\\uB9CC\\uC57D \\uC5B4\\uB5A4 fiber\\uC5D0\\uC11C \\uC791\\uC5C5 \\uC218\\uD589\\uC744 \\uB05D\\uB9C8\\uCCE4\\uC744 \\uB54C, fiber\\uC5D0\\uAC8C \\uC790\\uC2DD\\uC774 \\uC788\\uB2E4\\uBA74 \\uADF8\\uACF3\\uC774 \\uB2E4\\uC74C \\uC791\\uC5C5 \\uB2E8\\uC704\\uAC00 \\uB429\\uB2C8\\uB2E4.\"), mdx(\"p\", null, \"\\uC6B0\\uB9AC \\uC608\\uC2DC\\uC5D0\\uC11C\\uB294, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"div\"), \" fiber\\uC5D0\\uC11C\\uC758 \\uC791\\uC5C5\\uC774 \\uB05D\\uB09C \\uD6C4 \\uB2E4\\uC74C \\uC791\\uC5C5 \\uB2E8\\uC704\\uB294 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"h1\"), \" fiber\\uAC00 \\uB429\\uB2C8\\uB2E4.\"), mdx(\"p\", null, mdx(\"span\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"274px\"\n    }\n  }), \"\\n      \", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"116.05839416058394%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAXCAYAAAALHW+jAAAACXBIWXMAAAsTAAALEwEAmpwYAAAEOklEQVQ4y41Vb0xbVRS/rxTarhDGNqwkICLLghp1i37wXybOBTVOY7KYmH0w+mEfTGTUmQ2XaMhm/BtjBqWv7/W10BUy6HAzjC06ZyIxQ78oAlvbe9vXvteOKcuyubISqDCu593Hq1VK9Ca/nPPOve/Xc8/5vVOE/rUUGf/DplIKSsrEbOxTVwn62zcj6gZ0A/hSVHQlZcyt2LsALwKeAWxnsXhUJxq8G9Gz21a9S6+0rSZUEsSwFjUZq5lOJ6vTqlypxTKjH7C95c/QOvo5cgBskPGD1GXaDngOrbWWctm837rvbduOnc+ze4penXB2gS/JznRY5tT95lxvTeXC8c3VuYHGmsz1jy2ryIZOhJgdHDjO+f1+uyR5K3v8fnbwx28+0q82+7qFZvdupHN7rXT+0Da6cLCZ/tn+MM2881i+bsmVJoQGB5iVToc4SZI2+n2+cm+wl1X8UOAC22v5hZa+NE7LnwUbkCdqj0SvbXk/8kdDe3ShChlEhZ01Vl1NY0nhc2da3383Ml92IJJbfzCSs7x5iT7QGqbN+8L08bYwfcLIsAlQofnTcYKikSnUlyMVSip+f1qO1Z/JkA2+RczI3RPja9b+VGosL5U9gAbNT8d12Qxl8eZ4Au9Ox0nzuRtkq2s5mi/44XOTqJVQ5Lx0GznDywgy45yAQu3tBFRrfiyJ18xAHAia+G63SfM9Hg+LvfddAjmnKPOBFMgSxJ5M4CeB0KYFZRxmm72jI5woilbAesHnZeXg3XwZ7/HcYfwAz/OokLwww/uUBC7XfBK9yGKCKHBw0C4IghWszTgLfimg0iDx+SSUUuOsufkGg/MqoJFdmYRZLaTzX5lEr7jJ7XZbhGM9VpZRl8sgLQOwBII3ptBEKsreCeaAUI1HNMKXAXVsGMQwF6BX0P9ZntHhvD8yc3EluwSxAtkLALv2PD6td3l4Ft9DVNKsxvHWk7dwQx9VSt7SSAShHGpX4RGFKu3cl3OkDiu4BTT86NmbeIs2BExAVg9gsvjpd70Op25hR1Ql9/6myHcOLcQc/dcnWXeFXh8HhGZBElkZBufJpqiKH1Jk0nQ6g2uLzsKvc0o+tmv3K/mvBbIyA5nVeB6mtPi4KvyWT357htlj349w/p4eu1cUNwi9ftuKTMzQjGqw7EdcRz5BoUUZhVXMqTJBJ+aKaNgj6HLgBY8mmwpNOgBz4RnQYiUviCzWLYlo7CpBv17GSFoqQigGe/Rp0x/gQMhVrs4ui9cv6fOw8wu213f4ACd0d63Tr30z/y40srgcApmp1eO9qQW9BjVr//kat2eRokfA5384/9/aCq3U4SjF9rEZvGMyjZ/un8f1WqwjmS1pi1CHM7JcC2jSYp/SqO3CVfzUxGXc4l3CjqKE9Kj+vwJyqIVh4eigmEnmQyWjTRcOpotpf+S23n0aRlNpXBVTcM0bcO4vAutehStvaIYAAAAASUVORK5CYII=')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  })), \"\\n  \", mdx(\"img\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"Fiber Tree 3\",\n    \"title\": \"Fiber Tree 3\",\n    \"src\": \"/static/c8bdcc17706e9ab06233c980ed9cf007/d3fa7/fiber3.png\",\n    \"srcSet\": [\"/static/c8bdcc17706e9ab06233c980ed9cf007/d3fa7/fiber3.png 274w\"],\n    \"sizes\": \"(max-width: 274px) 100vw, 274px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\"\n  })), \"\\n    \")), mdx(\"p\", null, \"\\uB9CC\\uC57D fiber\\uC5D0 \\uC790\\uC2DD\\uC774 \\uC5C6\\uB2E4\\uBA74 \\uD615\\uC81C\\uC790\\uB9E4\\uAC00 \\uB2E4\\uC74C \\uC791\\uC5C5\\uC758 \\uB300\\uC0C1\\uC774 \\uB429\\uB2C8\\uB2E4.\"), mdx(\"p\", null, \"\\uAC00\\uB839, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"p\"), \" fiber\\uB294 \\uC790\\uC2DD\\uC774 \\uC5C6\\uC73C\\uBBC0\\uB85C \\uC774\\uB97C \\uB05D\\uB9C8\\uCE58\\uACE0 \\uB098\\uBA74 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"a\"), \" fiber\\uB85C \\uC62E\\uACA8\\uAC00\\uAC8C \\uB429\\uB2C8\\uB2E4.\"), mdx(\"p\", null, mdx(\"span\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"274px\"\n    }\n  }), \"\\n      \", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"116.05839416058394%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAXCAYAAAALHW+jAAAACXBIWXMAAAsTAAALEwEAmpwYAAAERUlEQVQ4y41VbUxbVRg+t3y0tSCwgV0jiMiyTBd1i3/8ysS5oMaPmCwa4y/9sR/GAPVrbA7Ej0TN4o8N6O39aEvXkUGHmxkM3fyIM7K5PyIw2ntuv+5tYYpRqS3FtoA9nntu21Up0ZM8ed/7nnOfe877Pu+5APxrSAH4DxsOSyAUEEtz86ivBFz3SwGyYPRj0GWg6AgFIJW1t2A8hfEIxm4S8wsq0fCtAI3vWvcuutaxnlAKijmrlUM+03wkVBeRA1VKLHbxfTKXOQJuQB8DI4Ye7/gu1KfZjfEY2GispRN5v639Vf2evY+Tc7KcShhP0SWJhR7tsvxaaXrAVJU6ubUuPdRsiv3+oXYd2cgpN7HDQycpu91u4HmuymG3k4WXz3+gHi3+ohYl9m9Gy/t1KHloF0odaEErnfeg2Ov35fMWyhbBPTxELD/qpnie32y32So41wDJ+CHnBJlr/QGVPT2JKh7F1hmYqn9P+HVbtzfa1CmkakCOqLCyudFgai4pfD4WUecPepPlb3rT1Qe8ae3Ls+jONg9qafeg+zs86IHcDrdjVCr+vF8EgncGnEiLlVLYvyMS8DWei4mbbKuQkFumJjfM/ZnwpbxUXsBoUvyIX5XNSAJu9QfhvohfbLmwKO7sywj5hL97YRq0iQiYZ/8CZk8G4J1RZoxC7e3FqFN8XwhuuAN2yKWh+y0axbdarSTW9VUQmGcQ8TEpJguKhlAQPogJ9UowAD1kcuDiGMWyrA6jmrFxJB20hS6nrdabch+gaRoUkhfu8A4pCCsUXxSukhjDMhReaGAYRoetPrcW+2WYtIrOkthsPAjLflLcfIGx8zxGMzmy6CG54L/8VMNybK3FYtEyxx06JdbLOtRqDwyW9/MDZNeuxWkwFRbIO640JpT9XoXwGYwGchn4IOVE18D/GcfHubw/tnA1u7ugqMNkT2AYlOfJebXKZ+PwNlEWW2Q/3Hl6CTa50WzJK1dWqTeElS0dnszNZgERVXySgA1Qgq1Yw/eO/wG3KZeABpM1YhBZfP+zmoczS9AoyOLtP0mBLSMpv/GzpQlSXTCKND1iTGf2omrSon/CWkGGd0sBcftoDNYXvQs/T0v52JP7ns13C4oe1qN4e3XuuQuh4tdVYS+f/uKcmp9vxii7w2HgWHaT/QRPqrz6W7cuE+3asRJ9p5x8YLETOJMR4JEhJQdEcGq5iIatjCoHmrEqsqlUpGOhraWFazBpI4b6kVg3+G7BB36cg4BfK0LIulRp8INOCgu5pu9Yr5az8+TY8fm31aMvv6VBscOks55LXT82LmRxOThjM+tiyYO9xF759kg+Nhft/29tubN5OIqg4dIC3DMdgQ8PJmEjacevz2poWuke+kaGY2qV2EdI1E/8Ah+amoOt3Bo0FiVER9X/CpZDPb4sjD1IIJJxXT5P+hb3MMXYefV2QT4wE4E1PgmaXkJQ8zd9/2Dz+S+7QQAAAABJRU5ErkJggg==')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  })), \"\\n  \", mdx(\"img\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"Fiber Tree 4\",\n    \"title\": \"Fiber Tree 4\",\n    \"src\": \"/static/19c304dcb3824b14722691ded539ecdb/d3fa7/fiber4.png\",\n    \"srcSet\": [\"/static/19c304dcb3824b14722691ded539ecdb/d3fa7/fiber4.png 274w\"],\n    \"sizes\": \"(max-width: 274px) 100vw, 274px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\"\n  })), \"\\n    \")), mdx(\"p\", null, \"\\uB9CC\\uC57D \\uC5B4\\uB5A4 fiber\\uAC00 \\uC790\\uC2DD\\uB3C4, \\uD615\\uC81C\\uC790\\uB9E4\\uB3C4 \\uC5C6\\uB2E4\\uBA74 \\uBD80\\uBAA8\\uC758 \\uD615\\uC81C\\uC790\\uB9E4 fiber\\uB85C \\uC774\\uB3D9\\uD569\\uB2C8\\uB2E4. \\uC608\\uB97C \\uB4E4\\uBA74 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"a\"), \"\\uC640 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"h2\"), \"\\uCC98\\uB7FC\\uC694.\"), mdx(\"p\", null, \"\\uB610\\uD55C \\uB9CC\\uC57D \\uBD80\\uBAA8\\uC5D0\\uAC8C \\uD615\\uC81C\\uC790\\uB9E4\\uAC00 \\uC5C6\\uB2E4\\uBA74, \\uD615\\uC81C\\uC790\\uB9E4\\uAC00 \\uC788\\uB294 \\uC870\\uC0C1\\uC744 \\uCC3E\\uAC70\\uB098 \\uB8E8\\uD2B8\\uC5D0 \\uB3C4\\uCC29\\uD560 \\uB54C\\uAE4C\\uC9C0 \\uACC4\\uC18D \\uAC70\\uC2AC\\uB7EC \\uC62C\\uB77C\\uAC11\\uB2C8\\uB2E4. \\uB9CC\\uC57D \\uB8E8\\uD2B8\\uC5D0 \\uB3C4\\uB2EC\\uD588\\uB2E4\\uBA74 \\uC774\\uB294 \\uB80C\\uB354\\uB9C1 \\uC791\\uC5C5 \\uC218\\uD589\\uC774 \\uBAA8\\uB450 \\uB05D\\uB0AC\\uC74C\\uC744 \\uC758\\uBBF8\\uD569\\uB2C8\\uB2E4.\")), mdx(\"p\", null, \"\\uC774\\uC81C \\uC774\\uB97C \\uCF54\\uB4DC\\uC5D0 \\uCC44\\uC6CC\\uBD05\\uC2DC\\uB2E4.\"), mdx(CodeWave, {\n    mdxType: \"CodeWave\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./11.jsx 25:45\",\n    \"file\": \"./11.jsx\",\n    \"25:45\": true\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children: children.map(child =>\\n        typeof child === \\\"object\\\"\\n          ? child\\n          : createTextElement(child)\\n      ),\\n    },\\n  }\\n}\\n\\nfunction createTextElement(text) {\\n  return {\\n    type: \\\"TEXT_ELEMENT\\\",\\n    props: {\\n      nodeValue: text,\\n      children: [],\\n    },\\n  }\\n}\\n\\nfunction render(element, container) {\\n  const dom =\\n    element.type == \\\"TEXT_ELEMENT\\\"\\n      ? document.createTextNode(\\\"\\\")\\n      : document.createElement(element.type)\\n\\n  const isProperty = key => key !== \\\"children\\\"\\n  Object.keys(element.props)\\n    .filter(isProperty)\\n    .forEach(name => {\\n      dom[name] = element.props[name]\\n    })\\n\\n  element.props.children.forEach(child =>\\n    render(child, dom)\\n  )\\n\\n  container.appendChild(dom)\\n}\\n\\nlet nextUnitOfWork = null\\n\\nfunction workLoop(deadline) {\\n  let shouldYield = false\\n  while (nextUnitOfWork && !shouldYield) {\\n    nextUnitOfWork = performUnitOfWork(\\n      nextUnitOfWork\\n    )\\n    shouldYield = deadline.timeRemaining() < 1\\n  }\\n  requestIdleCallback(workLoop)\\n}\\n\\nrequestIdleCallback(workLoop)\\n\\nfunction performUnitOfWork(nextUnitOfWork) {\\n  // TODO\\n}\\n\\nconst Didact = {\\n  createElement,\\n  render,\\n}\\n\\n/** @jsx Didact.createElement */\\nconst element = (\\n  <div id=\\\"foo\\\">\\n    <a>bar</a>\\n    <b />\\n  </div>\\n)\\nconst container = document.getElementById(\\\"root\\\")\\nDidact.render(element, container)\\n\")), mdx(\"p\", null, \"\\uBA3C\\uC800, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"render\"), \" \\uD568\\uC218\\uC5D0\\uC11C \\uC774 \\uCF54\\uB4DC\\uB97C \\uC81C\\uAC70\\uD569\\uB2C8\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./12.jsx 25,39,41:45\",\n    \"file\": \"./12.jsx\",\n    \"25,39,41:45\": true\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children: children.map(child =>\\n        typeof child === \\\"object\\\"\\n          ? child\\n          : createTextElement(child)\\n      ),\\n    },\\n  }\\n}\\n\\nfunction createTextElement(text) {\\n  return {\\n    type: \\\"TEXT_ELEMENT\\\",\\n    props: {\\n      nodeValue: text,\\n      children: [],\\n    },\\n  }\\n}\\n\\nfunction createDom(fiber) {\\n  const dom =\\n    fiber.type == \\\"TEXT_ELEMENT\\\"\\n      ? document.createTextNode(\\\"\\\")\\n      : document.createElement(fiber.type)\\n\\n  const isProperty = key => key !== \\\"children\\\"\\n  Object.keys(fiber.props)\\n    .filter(isProperty)\\n    .forEach(name => {\\n      dom[name] = fiber.props[name]\\n    })\\n\\n  return dom\\n}\\n\\nfunction render(element, container) {\\n  // TODO set next unit of work\\n}\\n\\nlet nextUnitOfWork = null\\n\\nfunction workLoop(deadline) {\\n  let shouldYield = false\\n  while (nextUnitOfWork && !shouldYield) {\\n    nextUnitOfWork = performUnitOfWork(\\n      nextUnitOfWork\\n    )\\n    shouldYield = deadline.timeRemaining() < 1\\n  }\\n  requestIdleCallback(workLoop)\\n}\\n\\nrequestIdleCallback(workLoop)\\n\\nfunction performUnitOfWork(fiber) {\\n  // TODO add dom node\\n  // TODO create new fibers\\n  // TODO return next unit of work\\n}\\n\\nconst Didact = {\\n  createElement,\\n  render,\\n}\\n\\n/** @jsx Didact.createElement */\\nconst element = (\\n  <div id=\\\"foo\\\">\\n    <a>bar</a>\\n    <b />\\n  </div>\\n)\\nconst container = document.getElementById(\\\"root\\\")\\nDidact.render(element, container)\\n\")), mdx(\"p\", null, \"\\uC790\\uCCB4 \\uD568\\uC218 \\uB0B4\\uBD80\\uC5D0\\uC11C DOM \\uB178\\uB4DC\\uB97C \\uC0DD\\uC131\\uD558\\uB294 \\uBD80\\uBD84\\uC740 \\uADF8\\uB300\\uB85C \\uC720\\uC9C0\\uD560 \\uAC83\\uC785\\uB2C8\\uB2E4. \\uC774\\uB294 \\uB098\\uC911\\uC5D0 \\uC0AC\\uC6A9\\uD569\\uB2C8\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./13.jsx 41:50\",\n    \"file\": \"./13.jsx\",\n    \"41:50\": true\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children: children.map(child =>\\n        typeof child === \\\"object\\\"\\n          ? child\\n          : createTextElement(child)\\n      ),\\n    },\\n  }\\n}\\n\\nfunction createTextElement(text) {\\n  return {\\n    type: \\\"TEXT_ELEMENT\\\",\\n    props: {\\n      nodeValue: text,\\n      children: [],\\n    },\\n  }\\n}\\n\\nfunction createDom(fiber) {\\n  const dom =\\n    fiber.type == \\\"TEXT_ELEMENT\\\"\\n      ? document.createTextNode(\\\"\\\")\\n      : document.createElement(fiber.type)\\n\\n  const isProperty = key => key !== \\\"children\\\"\\n  Object.keys(fiber.props)\\n    .filter(isProperty)\\n    .forEach(name => {\\n      dom[name] = fiber.props[name]\\n    })\\n\\n  return dom\\n}\\n\\nfunction render(element, container) {\\n  nextUnitOfWork = {\\n    dom: container,\\n    props: {\\n      children: [element],\\n    },\\n  }\\n}\\n\\nlet nextUnitOfWork = null\\n\\nfunction workLoop(deadline) {\\n  let shouldYield = false\\n  while (nextUnitOfWork && !shouldYield) {\\n    nextUnitOfWork = performUnitOfWork(\\n      nextUnitOfWork\\n    )\\n    shouldYield = deadline.timeRemaining() < 1\\n  }\\n  requestIdleCallback(workLoop)\\n}\\n\\nrequestIdleCallback(workLoop)\\n\\nfunction performUnitOfWork(fiber) {\\n  // TODO add dom node\\n  // TODO create new fibers\\n  // TODO return next unit of work\\n}\\n\\nconst Didact = {\\n  createElement,\\n  render,\\n}\\n\\n/** @jsx Didact.createElement */\\nconst element = (\\n  <div id=\\\"foo\\\">\\n    <a>bar</a>\\n    <b />\\n  </div>\\n)\\nconst container = document.getElementById(\\\"root\\\")\\nDidact.render(element, container)\\n\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"render\"), \" \\uD568\\uC218\\uC5D0\\uC11C fiber \\uD2B8\\uB9AC\\uC758 \\uB8E8\\uD2B8\\uC5D0 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"nextUnitOfWork\"), \" \\uD568\\uC218\\uB97C \\uC124\\uC815\\uD569\\uB2C8\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./13.jsx 52,55:57,61,65:69\",\n    \"file\": \"./13.jsx\",\n    \"52,55:57,61,65:69\": true\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children: children.map(child =>\\n        typeof child === \\\"object\\\"\\n          ? child\\n          : createTextElement(child)\\n      ),\\n    },\\n  }\\n}\\n\\nfunction createTextElement(text) {\\n  return {\\n    type: \\\"TEXT_ELEMENT\\\",\\n    props: {\\n      nodeValue: text,\\n      children: [],\\n    },\\n  }\\n}\\n\\nfunction createDom(fiber) {\\n  const dom =\\n    fiber.type == \\\"TEXT_ELEMENT\\\"\\n      ? document.createTextNode(\\\"\\\")\\n      : document.createElement(fiber.type)\\n\\n  const isProperty = key => key !== \\\"children\\\"\\n  Object.keys(fiber.props)\\n    .filter(isProperty)\\n    .forEach(name => {\\n      dom[name] = fiber.props[name]\\n    })\\n\\n  return dom\\n}\\n\\nfunction render(element, container) {\\n  nextUnitOfWork = {\\n    dom: container,\\n    props: {\\n      children: [element],\\n    },\\n  }\\n}\\n\\nlet nextUnitOfWork = null\\n\\nfunction workLoop(deadline) {\\n  let shouldYield = false\\n  while (nextUnitOfWork && !shouldYield) {\\n    nextUnitOfWork = performUnitOfWork(\\n      nextUnitOfWork\\n    )\\n    shouldYield = deadline.timeRemaining() < 1\\n  }\\n  requestIdleCallback(workLoop)\\n}\\n\\nrequestIdleCallback(workLoop)\\n\\nfunction performUnitOfWork(fiber) {\\n  // TODO add dom node\\n  // TODO create new fibers\\n  // TODO return next unit of work\\n}\\n\\nconst Didact = {\\n  createElement,\\n  render,\\n}\\n\\n/** @jsx Didact.createElement */\\nconst element = (\\n  <div id=\\\"foo\\\">\\n    <a>bar</a>\\n    <b />\\n  </div>\\n)\\nconst container = document.getElementById(\\\"root\\\")\\nDidact.render(element, container)\\n\")), mdx(\"p\", null, \"\\uADF8 \\uB2E4\\uC74C, \\uC900\\uBE44\\uB97C \\uB9C8\\uCE5C \\uBE0C\\uB77C\\uC6B0\\uC800\\uAC00 \\uC6B0\\uB9AC\\uAC00 \\uB9CC\\uB4E0 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"workLoop\"), \"\\uB97C \\uD638\\uCD9C\\uD558\\uBA74, \\uB8E8\\uD2B8\\uC5D0\\uC11C\\uBD80\\uD130 \\uC791\\uC5C5\\uC744 \\uC2DC\\uC791\\uD569\\uB2C8\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./14.jsx\",\n    \"file\": \"./14.jsx\"\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children: children.map(child =>\\n        typeof child === \\\"object\\\"\\n          ? child\\n          : createTextElement(child)\\n      ),\\n    },\\n  }\\n}\\n\\nfunction createTextElement(text) {\\n  return {\\n    type: \\\"TEXT_ELEMENT\\\",\\n    props: {\\n      nodeValue: text,\\n      children: [],\\n    },\\n  }\\n}\\n\\nfunction createDom(fiber) {\\n  const dom =\\n    fiber.type == \\\"TEXT_ELEMENT\\\"\\n      ? document.createTextNode(\\\"\\\")\\n      : document.createElement(fiber.type)\\n\\n  const isProperty = key => key !== \\\"children\\\"\\n  Object.keys(fiber.props)\\n    .filter(isProperty)\\n    .forEach(name => {\\n      dom[name] = fiber.props[name]\\n    })\\n\\n  return dom\\n}\\n\\nfunction render(element, container) {\\n  nextUnitOfWork = {\\n    dom: container,\\n    props: {\\n      children: [element],\\n    },\\n  }\\n}\\n\\nlet nextUnitOfWork = null\\n\\nfunction workLoop(deadline) {\\n  let shouldYield = false\\n  while (nextUnitOfWork && !shouldYield) {\\n    nextUnitOfWork = performUnitOfWork(\\n      nextUnitOfWork\\n    )\\n    shouldYield = deadline.timeRemaining() < 1\\n  }\\n  requestIdleCallback(workLoop)\\n}\\n\\nrequestIdleCallback(workLoop)\\n\\nfunction performUnitOfWork(fiber) {\\n  if (!fiber.dom) {\\n    fiber.dom = createDom(fiber)\\n  }\\n\\n  if (fiber.parent) {\\n    fiber.parent.dom.appendChild(fiber.dom)\\n  }\\n\\n  // TODO create new fibers\\n  // TODO return next unit of work\\n}\\n\\nconst Didact = {\\n  createElement,\\n  render,\\n}\\n\\n/** @jsx Didact.createElement */\\nconst element = (\\n  <div id=\\\"foo\\\">\\n    <a>bar</a>\\n    <b />\\n  </div>\\n)\\nconst container = document.getElementById(\\\"root\\\")\\nDidact.render(element, container)\\n\")), mdx(\"p\", null, \"\\uBA3C\\uC800 \\uC0C8\\uB85C\\uC6B4 \\uB178\\uB4DC\\uB97C \\uC0DD\\uC131\\uD558\\uACE0 DOM\\uC5D0 \\uC774\\uB97C \\uCD94\\uAC00\\uD569\\uB2C8\\uB2E4.\"), mdx(\"p\", null, \"\\uACC4\\uC18D\\uD574\\uC11C \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fiber.dom\"), \" \\uC18D\\uC131 \\uB0B4\\uBD80\\uC758 DOM \\uB178\\uB4DC\\uB97C \\uCD94\\uC801\\uD569\\uB2C8\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./15.jsx\",\n    \"file\": \"./15.jsx\"\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children: children.map(child =>\\n        typeof child === \\\"object\\\"\\n          ? child\\n          : createTextElement(child)\\n      ),\\n    },\\n  }\\n}\\n\\nfunction createTextElement(text) {\\n  return {\\n    type: \\\"TEXT_ELEMENT\\\",\\n    props: {\\n      nodeValue: text,\\n      children: [],\\n    },\\n  }\\n}\\n\\nfunction createDom(fiber) {\\n  const dom =\\n    fiber.type == \\\"TEXT_ELEMENT\\\"\\n      ? document.createTextNode(\\\"\\\")\\n      : document.createElement(fiber.type)\\n\\n  const isProperty = key => key !== \\\"children\\\"\\n  Object.keys(fiber.props)\\n    .filter(isProperty)\\n    .forEach(name => {\\n      dom[name] = fiber.props[name]\\n    })\\n\\n  return dom\\n}\\n\\nfunction render(element, container) {\\n  nextUnitOfWork = {\\n    dom: container,\\n    props: {\\n      children: [element],\\n    },\\n  }\\n}\\n\\nlet nextUnitOfWork = null\\n\\nfunction workLoop(deadline) {\\n  let shouldYield = false\\n  while (nextUnitOfWork && !shouldYield) {\\n    nextUnitOfWork = performUnitOfWork(\\n      nextUnitOfWork\\n    )\\n    shouldYield = deadline.timeRemaining() < 1\\n  }\\n  requestIdleCallback(workLoop)\\n}\\n\\nrequestIdleCallback(workLoop)\\n\\nfunction performUnitOfWork(fiber) {\\n  if (!fiber.dom) {\\n    fiber.dom = createDom(fiber)\\n  }\\n\\n  if (fiber.parent) {\\n    fiber.parent.dom.appendChild(fiber.dom)\\n  }\\n\\n  const elements = fiber.props.children\\n  let index = 0\\n  let prevSibling = null\\n\\n  while (index < elements.length) {\\n    const element = elements[index]\\n\\n    const newFiber = {\\n      type: element.type,\\n      props: element.props,\\n      parent: fiber,\\n      dom: null,\\n    }\\n  }\\n\\n  // TODO return next unit of work\\n}\\n\\nconst Didact = {\\n  createElement,\\n  render,\\n}\\n\\n/** @jsx Didact.createElement */\\nconst element = (\\n  <div id=\\\"foo\\\">\\n    <a>bar</a>\\n    <b />\\n  </div>\\n)\\nconst container = document.getElementById(\\\"root\\\")\\nDidact.render(element, container)\\n\")), mdx(\"p\", null, \"\\uAC01\\uAC01\\uC758 \\uC790\\uC2DD\\uB4E4\\uB9C8\\uB2E4 \\uC0C8\\uB85C\\uC6B4 fiber\\uB97C \\uC0DD\\uC131\\uD569\\uB2C8\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./16.jsx\",\n    \"file\": \"./16.jsx\"\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children: children.map(child =>\\n        typeof child === \\\"object\\\"\\n          ? child\\n          : createTextElement(child)\\n      ),\\n    },\\n  }\\n}\\n\\nfunction createTextElement(text) {\\n  return {\\n    type: \\\"TEXT_ELEMENT\\\",\\n    props: {\\n      nodeValue: text,\\n      children: [],\\n    },\\n  }\\n}\\n\\nfunction createDom(fiber) {\\n  const dom =\\n    fiber.type == \\\"TEXT_ELEMENT\\\"\\n      ? document.createTextNode(\\\"\\\")\\n      : document.createElement(fiber.type)\\n\\n  const isProperty = key => key !== \\\"children\\\"\\n  Object.keys(fiber.props)\\n    .filter(isProperty)\\n    .forEach(name => {\\n      dom[name] = fiber.props[name]\\n    })\\n\\n  return dom\\n}\\n\\nfunction render(element, container) {\\n  nextUnitOfWork = {\\n    dom: container,\\n    props: {\\n      children: [element],\\n    },\\n  }\\n}\\n\\nlet nextUnitOfWork = null\\n\\nfunction workLoop(deadline) {\\n  let shouldYield = false\\n  while (nextUnitOfWork && !shouldYield) {\\n    nextUnitOfWork = performUnitOfWork(\\n      nextUnitOfWork\\n    )\\n    shouldYield = deadline.timeRemaining() < 1\\n  }\\n  requestIdleCallback(workLoop)\\n}\\n\\nrequestIdleCallback(workLoop)\\n\\nfunction performUnitOfWork(fiber) {\\n  if (!fiber.dom) {\\n    fiber.dom = createDom(fiber)\\n  }\\n\\n  if (fiber.parent) {\\n    fiber.parent.dom.appendChild(fiber.dom)\\n  }\\n\\n  const elements = fiber.props.children\\n  let index = 0\\n  let prevSibling = null\\n\\n  while (index < elements.length) {\\n    const element = elements[index]\\n\\n    const newFiber = {\\n      type: element.type,\\n      props: element.props,\\n      parent: fiber,\\n      dom: null,\\n    }\\n\\n    if (index === 0) {\\n      fiber.child = newFiber\\n    } else {\\n      prevSibling.sibling = newFiber\\n    }\\n\\n    prevSibling = newFiber\\n    index++\\n  }\\n\\n  // TODO return next unit of work\\n}\\n\\nconst Didact = {\\n  createElement,\\n  render,\\n}\\n\\n/** @jsx Didact.createElement */\\nconst element = (\\n  <div id=\\\"foo\\\">\\n    <a>bar</a>\\n    <b />\\n  </div>\\n)\\nconst container = document.getElementById(\\\"root\\\")\\nDidact.render(element, container)\\n\")), mdx(\"p\", null, \"\\uADF8\\uB9AC\\uACE0 \\uC774\\uB4E4\\uC744 \\uCCAB \\uBC88\\uC9F8 \\uC790\\uC2DD\\uC778\\uC9C0 \\uC544\\uB2CC\\uC9C0\\uC5D0 \\uB530\\uB77C \\uC790\\uC2DD \\uD639\\uC740 \\uD615\\uC81C\\uC790\\uB9E4\\uB85C\\uC11C fiber \\uD2B8\\uB9AC\\uC5D0 \\uCD94\\uAC00\\uD569\\uB2C8\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./17.jsx\",\n    \"file\": \"./17.jsx\"\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children: children.map(child =>\\n        typeof child === \\\"object\\\"\\n          ? child\\n          : createTextElement(child)\\n      ),\\n    },\\n  }\\n}\\n\\nfunction createTextElement(text) {\\n  return {\\n    type: \\\"TEXT_ELEMENT\\\",\\n    props: {\\n      nodeValue: text,\\n      children: [],\\n    },\\n  }\\n}\\n\\nfunction createDom(fiber) {\\n  const dom =\\n    fiber.type == \\\"TEXT_ELEMENT\\\"\\n      ? document.createTextNode(\\\"\\\")\\n      : document.createElement(fiber.type)\\n\\n  const isProperty = key => key !== \\\"children\\\"\\n  Object.keys(fiber.props)\\n    .filter(isProperty)\\n    .forEach(name => {\\n      dom[name] = fiber.props[name]\\n    })\\n\\n  return dom\\n}\\n\\nfunction render(element, container) {\\n  nextUnitOfWork = {\\n    dom: container,\\n    props: {\\n      children: [element],\\n    },\\n  }\\n}\\n\\nlet nextUnitOfWork = null\\n\\nfunction workLoop(deadline) {\\n  let shouldYield = false\\n  while (nextUnitOfWork && !shouldYield) {\\n    nextUnitOfWork = performUnitOfWork(\\n      nextUnitOfWork\\n    )\\n    shouldYield = deadline.timeRemaining() < 1\\n  }\\n  requestIdleCallback(workLoop)\\n}\\n\\nrequestIdleCallback(workLoop)\\n\\nfunction performUnitOfWork(fiber) {\\n  if (!fiber.dom) {\\n    fiber.dom = createDom(fiber)\\n  }\\n\\n  if (fiber.parent) {\\n    fiber.parent.dom.appendChild(fiber.dom)\\n  }\\n\\n  const elements = fiber.props.children\\n  let index = 0\\n  let prevSibling = null\\n\\n  while (index < elements.length) {\\n    const element = elements[index]\\n\\n    const newFiber = {\\n      type: element.type,\\n      props: element.props,\\n      parent: fiber,\\n      dom: null,\\n    }\\n\\n    if (index === 0) {\\n      fiber.child = newFiber\\n    } else {\\n      prevSibling.sibling = newFiber\\n    }\\n\\n    prevSibling = newFiber\\n    index++\\n  }\\n\\n  if (fiber.child) {\\n    return fiber.child\\n  }\\n  let nextFiber = fiber\\n  while (nextFiber) {\\n    if (nextFiber.sibling) {\\n      return nextFiber.sibling\\n    }\\n    nextFiber = nextFiber.parent\\n  }\\n}\\n\\nconst Didact = {\\n  createElement,\\n  render,\\n}\\n\\n/** @jsx Didact.createElement */\\nconst element = (\\n  <div id=\\\"foo\\\">\\n    <a>bar</a>\\n    <b />\\n  </div>\\n)\\nconst container = document.getElementById(\\\"root\\\")\\nDidact.render(element, container)\\n\")), mdx(\"p\", null, \"\\uB9C8\\uC9C0\\uB9C9\\uC73C\\uB85C \\uB2E4\\uC74C \\uC791\\uC5C5\\uC740 \\uD0D0\\uC0C9\\uC785\\uB2C8\\uB2E4.\\n\\uD0D0\\uC0C9\\uC740 \\uBA3C\\uC800 \\uC790\\uC2DD, \\uD615\\uC81C\\uC790\\uB9E4, \\uBD80\\uBAA8\\uC758 \\uD615\\uC81C\\uC790\\uB9E4 \\uC21C\\uC11C\\uB85C \\uC9C4\\uD589\\uB429\\uB2C8\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./17.jsx 65:108\",\n    \"file\": \"./17.jsx\",\n    \"65:108\": true\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children: children.map(child =>\\n        typeof child === \\\"object\\\"\\n          ? child\\n          : createTextElement(child)\\n      ),\\n    },\\n  }\\n}\\n\\nfunction createTextElement(text) {\\n  return {\\n    type: \\\"TEXT_ELEMENT\\\",\\n    props: {\\n      nodeValue: text,\\n      children: [],\\n    },\\n  }\\n}\\n\\nfunction createDom(fiber) {\\n  const dom =\\n    fiber.type == \\\"TEXT_ELEMENT\\\"\\n      ? document.createTextNode(\\\"\\\")\\n      : document.createElement(fiber.type)\\n\\n  const isProperty = key => key !== \\\"children\\\"\\n  Object.keys(fiber.props)\\n    .filter(isProperty)\\n    .forEach(name => {\\n      dom[name] = fiber.props[name]\\n    })\\n\\n  return dom\\n}\\n\\nfunction render(element, container) {\\n  nextUnitOfWork = {\\n    dom: container,\\n    props: {\\n      children: [element],\\n    },\\n  }\\n}\\n\\nlet nextUnitOfWork = null\\n\\nfunction workLoop(deadline) {\\n  let shouldYield = false\\n  while (nextUnitOfWork && !shouldYield) {\\n    nextUnitOfWork = performUnitOfWork(\\n      nextUnitOfWork\\n    )\\n    shouldYield = deadline.timeRemaining() < 1\\n  }\\n  requestIdleCallback(workLoop)\\n}\\n\\nrequestIdleCallback(workLoop)\\n\\nfunction performUnitOfWork(fiber) {\\n  if (!fiber.dom) {\\n    fiber.dom = createDom(fiber)\\n  }\\n\\n  if (fiber.parent) {\\n    fiber.parent.dom.appendChild(fiber.dom)\\n  }\\n\\n  const elements = fiber.props.children\\n  let index = 0\\n  let prevSibling = null\\n\\n  while (index < elements.length) {\\n    const element = elements[index]\\n\\n    const newFiber = {\\n      type: element.type,\\n      props: element.props,\\n      parent: fiber,\\n      dom: null,\\n    }\\n\\n    if (index === 0) {\\n      fiber.child = newFiber\\n    } else {\\n      prevSibling.sibling = newFiber\\n    }\\n\\n    prevSibling = newFiber\\n    index++\\n  }\\n\\n  if (fiber.child) {\\n    return fiber.child\\n  }\\n  let nextFiber = fiber\\n  while (nextFiber) {\\n    if (nextFiber.sibling) {\\n      return nextFiber.sibling\\n    }\\n    nextFiber = nextFiber.parent\\n  }\\n}\\n\\nconst Didact = {\\n  createElement,\\n  render,\\n}\\n\\n/** @jsx Didact.createElement */\\nconst element = (\\n  <div id=\\\"foo\\\">\\n    <a>bar</a>\\n    <b />\\n  </div>\\n)\\nconst container = document.getElementById(\\\"root\\\")\\nDidact.render(element, container)\\n\")), mdx(\"p\", null, \"\\uC774\\uC81C \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"performUnitOfWork\"), \" \\uC791\\uC5C5\\uC774 \\uB05D\\uB0AC\\uC2B5\\uB2C8\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./17.jsx 65,70:72\",\n    \"file\": \"./17.jsx\",\n    \"65,70:72\": true\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children: children.map(child =>\\n        typeof child === \\\"object\\\"\\n          ? child\\n          : createTextElement(child)\\n      ),\\n    },\\n  }\\n}\\n\\nfunction createTextElement(text) {\\n  return {\\n    type: \\\"TEXT_ELEMENT\\\",\\n    props: {\\n      nodeValue: text,\\n      children: [],\\n    },\\n  }\\n}\\n\\nfunction createDom(fiber) {\\n  const dom =\\n    fiber.type == \\\"TEXT_ELEMENT\\\"\\n      ? document.createTextNode(\\\"\\\")\\n      : document.createElement(fiber.type)\\n\\n  const isProperty = key => key !== \\\"children\\\"\\n  Object.keys(fiber.props)\\n    .filter(isProperty)\\n    .forEach(name => {\\n      dom[name] = fiber.props[name]\\n    })\\n\\n  return dom\\n}\\n\\nfunction render(element, container) {\\n  nextUnitOfWork = {\\n    dom: container,\\n    props: {\\n      children: [element],\\n    },\\n  }\\n}\\n\\nlet nextUnitOfWork = null\\n\\nfunction workLoop(deadline) {\\n  let shouldYield = false\\n  while (nextUnitOfWork && !shouldYield) {\\n    nextUnitOfWork = performUnitOfWork(\\n      nextUnitOfWork\\n    )\\n    shouldYield = deadline.timeRemaining() < 1\\n  }\\n  requestIdleCallback(workLoop)\\n}\\n\\nrequestIdleCallback(workLoop)\\n\\nfunction performUnitOfWork(fiber) {\\n  if (!fiber.dom) {\\n    fiber.dom = createDom(fiber)\\n  }\\n\\n  if (fiber.parent) {\\n    fiber.parent.dom.appendChild(fiber.dom)\\n  }\\n\\n  const elements = fiber.props.children\\n  let index = 0\\n  let prevSibling = null\\n\\n  while (index < elements.length) {\\n    const element = elements[index]\\n\\n    const newFiber = {\\n      type: element.type,\\n      props: element.props,\\n      parent: fiber,\\n      dom: null,\\n    }\\n\\n    if (index === 0) {\\n      fiber.child = newFiber\\n    } else {\\n      prevSibling.sibling = newFiber\\n    }\\n\\n    prevSibling = newFiber\\n    index++\\n  }\\n\\n  if (fiber.child) {\\n    return fiber.child\\n  }\\n  let nextFiber = fiber\\n  while (nextFiber) {\\n    if (nextFiber.sibling) {\\n      return nextFiber.sibling\\n    }\\n    nextFiber = nextFiber.parent\\n  }\\n}\\n\\nconst Didact = {\\n  createElement,\\n  render,\\n}\\n\\n/** @jsx Didact.createElement */\\nconst element = (\\n  <div id=\\\"foo\\\">\\n    <a>bar</a>\\n    <b />\\n  </div>\\n)\\nconst container = document.getElementById(\\\"root\\\")\\nDidact.render(element, container)\\n\")), mdx(\"h2\", {\n    \"id\": \"step-v-렌더와-커밋-단계-render-and-commit-phases\"\n  }, \"Step V: \\uB80C\\uB354\\uC640 \\uCEE4\\uBC0B \\uB2E8\\uACC4 (Render and Commit Phases)\"), mdx(\"p\", null, \"\\uC544\\uC9C1 \\uBB38\\uC81C \\uD558\\uB098\\uAC00 \\uB354 \\uB0A8\\uC544\\uC788\\uC2B5\\uB2C8\\uB2E4.\"), mdx(\"p\", null, \"\\uC5D8\\uB9AC\\uBA3C\\uD2B8\\uC5D0\\uC11C \\uC791\\uC5C5\\uC744 \\uC218\\uD589\\uD560 \\uB54C \\uB9C8\\uB2E4 \\uAC01\\uAC01\\uC758 DOM\\uC5D0 \\uC0C8\\uB85C\\uC6B4 \\uB178\\uB4DC\\uB97C \\uCD94\\uAC00\\uD558\\uACE0 \\uC788\\uC2B5\\uB2C8\\uB2E4.\\n\\uADF8\\uB9AC\\uACE0 \\uBE0C\\uB77C\\uC6B0\\uC800\\uAC00 \\uB80C\\uB354\\uB9C1\\uC774 \\uC9C4\\uD589\\uB418\\uACE0 \\uC788\\uB294 \\uC911\\uAC04\\uC5D0 \\uB09C\\uC785\\uD560 \\uC218 \\uC788\\uB2E4\\uB294 \\uAC83\\uC744 \\uAE30\\uC5B5\\uD574\\uC57C \\uD569\\uB2C8\\uB2E4.\\n\\uC774 \\uACBD\\uC6B0 \\uC720\\uC800\\uB294 \\uBBF8\\uC644\\uC131\\uB41C UI\\uB97C \\uBCF4\\uAC8C \\uB429\\uB2C8\\uB2E4. \\uBB3C\\uB860 \\uC774\\uB807\\uAC8C \\uB418\\uC9C0 \\uC54A\\uB3C4\\uB85D \\uD574\\uC57C \\uD569\\uB2C8\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./18.jsx 65,72[1]\",\n    \"file\": \"./18.jsx\",\n    \"65,72[1]\": true\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children: children.map(child =>\\n        typeof child === \\\"object\\\"\\n          ? child\\n          : createTextElement(child)\\n      ),\\n    },\\n  }\\n}\\n\\nfunction createTextElement(text) {\\n  return {\\n    type: \\\"TEXT_ELEMENT\\\",\\n    props: {\\n      nodeValue: text,\\n      children: [],\\n    },\\n  }\\n}\\n\\nfunction createDom(fiber) {\\n  const dom =\\n    fiber.type == \\\"TEXT_ELEMENT\\\"\\n      ? document.createTextNode(\\\"\\\")\\n      : document.createElement(fiber.type)\\n\\n  const isProperty = key => key !== \\\"children\\\"\\n  Object.keys(fiber.props)\\n    .filter(isProperty)\\n    .forEach(name => {\\n      dom[name] = fiber.props[name]\\n    })\\n\\n  return dom\\n}\\n\\nfunction render(element, container) {\\n  nextUnitOfWork = {\\n    dom: container,\\n    props: {\\n      children: [element],\\n    },\\n  }\\n}\\n\\nlet nextUnitOfWork = null\\n\\nfunction workLoop(deadline) {\\n  let shouldYield = false\\n  while (nextUnitOfWork && !shouldYield) {\\n    nextUnitOfWork = performUnitOfWork(\\n      nextUnitOfWork\\n    )\\n    shouldYield = deadline.timeRemaining() < 1\\n  }\\n  requestIdleCallback(workLoop)\\n}\\n\\nrequestIdleCallback(workLoop)\\n\\nfunction performUnitOfWork(fiber) {\\n  if (!fiber.dom) {\\n    fiber.dom = createDom(fiber)\\n  }\\n\\n  const elements = fiber.props.children\\n  let index = 0\\n  let prevSibling = null\\n\\n  while (index < elements.length) {\\n    const element = elements[index]\\n\\n    const newFiber = {\\n      type: element.type,\\n      props: element.props,\\n      parent: fiber,\\n      dom: null,\\n    }\\n\\n    if (index === 0) {\\n      fiber.child = newFiber\\n    } else {\\n      prevSibling.sibling = newFiber\\n    }\\n\\n    prevSibling = newFiber\\n    index++\\n  }\\n\\n  if (fiber.child) {\\n    return fiber.child\\n  }\\n  let nextFiber = fiber\\n  while (nextFiber) {\\n    if (nextFiber.sibling) {\\n      return nextFiber.sibling\\n    }\\n    nextFiber = nextFiber.parent\\n  }\\n}\\n\\nconst Didact = {\\n  createElement,\\n  render,\\n}\\n\\n/** @jsx Didact.createElement */\\nconst element = (\\n  <div id=\\\"foo\\\">\\n    <a>bar</a>\\n    <b />\\n  </div>\\n)\\nconst container = document.getElementById(\\\"root\\\")\\nDidact.render(element, container)\\n\")), mdx(\"p\", null, \"\\uC774\\uB97C \\uC704\\uD574 \\uC5EC\\uAE30\\uC11C DOM\\uC744 \\uBCC0\\uD615\\uC2DC\\uD0A4\\uB294 \\uBD80\\uBD84\\uC744 \\uC81C\\uAC70\\uD569\\uB2C8\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./18.1.jsx\",\n    \"file\": \"./18.1.jsx\"\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children: children.map(child =>\\n        typeof child === \\\"object\\\"\\n          ? child\\n          : createTextElement(child)\\n      ),\\n    },\\n  }\\n}\\n\\nfunction createTextElement(text) {\\n  return {\\n    type: \\\"TEXT_ELEMENT\\\",\\n    props: {\\n      nodeValue: text,\\n      children: [],\\n    },\\n  }\\n}\\n\\nfunction createDom(fiber) {\\n  const dom =\\n    fiber.type == \\\"TEXT_ELEMENT\\\"\\n      ? document.createTextNode(\\\"\\\")\\n      : document.createElement(fiber.type)\\n\\n  const isProperty = key => key !== \\\"children\\\"\\n  Object.keys(fiber.props)\\n    .filter(isProperty)\\n    .forEach(name => {\\n      dom[name] = fiber.props[name]\\n    })\\n\\n  return dom\\n}\\n\\nfunction render(element, container) {\\n  wipRoot = {\\n    dom: container,\\n    props: {\\n      children: [element],\\n    },\\n  }\\n  nextUnitOfWork = wipRoot\\n}\\n\\nlet nextUnitOfWork = null\\nlet wipRoot = null\\n\\nfunction workLoop(deadline) {\\n  let shouldYield = false\\n  while (nextUnitOfWork && !shouldYield) {\\n    nextUnitOfWork = performUnitOfWork(\\n      nextUnitOfWork\\n    )\\n    shouldYield = deadline.timeRemaining() < 1\\n  }\\n  requestIdleCallback(workLoop)\\n}\\n\\nrequestIdleCallback(workLoop)\\n\\nfunction performUnitOfWork(fiber) {\\n  if (!fiber.dom) {\\n    fiber.dom = createDom(fiber)\\n  }\\n\\n  const elements = fiber.props.children\\n  let index = 0\\n  let prevSibling = null\\n\\n  while (index < elements.length) {\\n    const element = elements[index]\\n\\n    const newFiber = {\\n      type: element.type,\\n      props: element.props,\\n      parent: fiber,\\n      dom: null,\\n    }\\n\\n    if (index === 0) {\\n      fiber.child = newFiber\\n    } else {\\n      prevSibling.sibling = newFiber\\n    }\\n\\n    prevSibling = newFiber\\n    index++\\n  }\\n\\n  if (fiber.child) {\\n    return fiber.child\\n  }\\n  let nextFiber = fiber\\n  while (nextFiber) {\\n    if (nextFiber.sibling) {\\n      return nextFiber.sibling\\n    }\\n    nextFiber = nextFiber.parent\\n  }\\n}\\n\\nconst Didact = {\\n  createElement,\\n  render,\\n}\\n\\n/** @jsx Didact.createElement */\\nconst element = (\\n  <div id=\\\"foo\\\">\\n    <a>bar</a>\\n    <b />\\n  </div>\\n)\\nconst container = document.getElementById(\\\"root\\\")\\nDidact.render(element, container)\\n\")), mdx(\"p\", null, \"\\uADF8 \\uB300\\uC2E0, fiber \\uD2B8\\uB9AC\\uC758 \\uB8E8\\uD2B8\\uB97C \\uCD94\\uC801\\uD560 \\uAC83\\uC785\\uB2C8\\uB2E4. \\uC774\\uB97C \\uC791\\uC5C5 \\uC911\\uC778(work in progress) \\uB8E8\\uD2B8\\uB77C\\uB294 \\uB73B\\uC73C\\uB85C \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"wipRoot\"), \"\\uB77C\\uACE0 \\uD558\\uACA0\\uC2B5\\uB2C8\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./19.jsx 41:43,58,67:69,72\",\n    \"file\": \"./19.jsx\",\n    \"41:43,58,67:69,72\": true\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children: children.map(child =>\\n        typeof child === \\\"object\\\"\\n          ? child\\n          : createTextElement(child)\\n      ),\\n    },\\n  }\\n}\\n\\nfunction createTextElement(text) {\\n  return {\\n    type: \\\"TEXT_ELEMENT\\\",\\n    props: {\\n      nodeValue: text,\\n      children: [],\\n    },\\n  }\\n}\\n\\nfunction createDom(fiber) {\\n  const dom =\\n    fiber.type == \\\"TEXT_ELEMENT\\\"\\n      ? document.createTextNode(\\\"\\\")\\n      : document.createElement(fiber.type)\\n\\n  const isProperty = key => key !== \\\"children\\\"\\n  Object.keys(fiber.props)\\n    .filter(isProperty)\\n    .forEach(name => {\\n      dom[name] = fiber.props[name]\\n    })\\n\\n  return dom\\n}\\n\\nfunction commitRoot() {\\n  // TODO add nodes to dom\\n}\\n\\nfunction render(element, container) {\\n  wipRoot = {\\n    dom: container,\\n    props: {\\n      children: [element],\\n    },\\n  }\\n  nextUnitOfWork = wipRoot\\n}\\n\\nlet nextUnitOfWork = null\\nlet wipRoot = null\\n\\nfunction workLoop(deadline) {\\n  let shouldYield = false\\n  while (nextUnitOfWork && !shouldYield) {\\n    nextUnitOfWork = performUnitOfWork(\\n      nextUnitOfWork\\n    )\\n    shouldYield = deadline.timeRemaining() < 1\\n  }\\n\\n  if (!nextUnitOfWork && wipRoot) {\\n    commitRoot()\\n  }\\n\\n  requestIdleCallback(workLoop)\\n}\\n\\nrequestIdleCallback(workLoop)\\n\\nfunction performUnitOfWork(fiber) {\\n  if (!fiber.dom) {\\n    fiber.dom = createDom(fiber)\\n  }\\n\\n  const elements = fiber.props.children\\n  let index = 0\\n  let prevSibling = null\\n\\n  while (index < elements.length) {\\n    const element = elements[index]\\n\\n    const newFiber = {\\n      type: element.type,\\n      props: element.props,\\n      parent: fiber,\\n      dom: null,\\n    }\\n\\n    if (index === 0) {\\n      fiber.child = newFiber\\n    } else {\\n      prevSibling.sibling = newFiber\\n    }\\n\\n    prevSibling = newFiber\\n    index++\\n  }\\n\\n  if (fiber.child) {\\n    return fiber.child\\n  }\\n  let nextFiber = fiber\\n  while (nextFiber) {\\n    if (nextFiber.sibling) {\\n      return nextFiber.sibling\\n    }\\n    nextFiber = nextFiber.parent\\n  }\\n}\\n\\nconst Didact = {\\n  createElement,\\n  render,\\n}\\n\\n/** @jsx Didact.createElement */\\nconst element = (\\n  <div id=\\\"foo\\\">\\n    <a>bar</a>\\n    <b />\\n  </div>\\n)\\nconst container = document.getElementById(\\\"root\\\")\\nDidact.render(element, container)\\n\")), mdx(\"p\", null, \"\\uC77C\\uB2E8 \\uBAA8\\uB4E0 \\uC791\\uC5C5\\uC774 \\uB05D\\uB098\\uACE0 \\uB098\\uBA74 (\\uB354 \\uC774\\uC0C1 \\uB2E4\\uC74C \\uC791\\uC5C5\\uC774 \\uC5C6\\uB294 \\uACBD\\uC6B0), \\uC804\\uCCB4 fiber \\uD2B8\\uB9AC\\uB97C DOM\\uC5D0 \\uCEE4\\uBC0B\\uD569\\uB2C8\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./20.jsx 41:54\",\n    \"file\": \"./20.jsx\",\n    \"41:54\": true\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children: children.map(child =>\\n        typeof child === \\\"object\\\"\\n          ? child\\n          : createTextElement(child)\\n      ),\\n    },\\n  }\\n}\\n\\nfunction createTextElement(text) {\\n  return {\\n    type: \\\"TEXT_ELEMENT\\\",\\n    props: {\\n      nodeValue: text,\\n      children: [],\\n    },\\n  }\\n}\\n\\nfunction createDom(fiber) {\\n  const dom =\\n    fiber.type == \\\"TEXT_ELEMENT\\\"\\n      ? document.createTextNode(\\\"\\\")\\n      : document.createElement(fiber.type)\\n\\n  const isProperty = key => key !== \\\"children\\\"\\n  Object.keys(fiber.props)\\n    .filter(isProperty)\\n    .forEach(name => {\\n      dom[name] = fiber.props[name]\\n    })\\n\\n  return dom\\n}\\n\\nfunction commitRoot() {\\n  commitWork(wipRoot.child)\\n  wipRoot = null\\n}\\n\\nfunction commitWork(fiber) {\\n  if (!fiber) {\\n    return\\n  }\\n  const domParent = fiber.parent.dom\\n  domParent.appendChild(fiber.dom)\\n  commitWork(fiber.child)\\n  commitWork(fiber.sibling)\\n}\\n\\nfunction render(element, container) {\\n  wipRoot = {\\n    dom: container,\\n    props: {\\n      children: [element],\\n    },\\n  }\\n  nextUnitOfWork = wipRoot\\n}\\n\\nlet nextUnitOfWork = null\\nlet wipRoot = null\\n\\nfunction workLoop(deadline) {\\n  let shouldYield = false\\n  while (nextUnitOfWork && !shouldYield) {\\n    nextUnitOfWork = performUnitOfWork(\\n      nextUnitOfWork\\n    )\\n    shouldYield = deadline.timeRemaining() < 1\\n  }\\n\\n  if (!nextUnitOfWork && wipRoot) {\\n    commitRoot()\\n  }\\n\\n  requestIdleCallback(workLoop)\\n}\\n\\nrequestIdleCallback(workLoop)\\n\\nfunction performUnitOfWork(fiber) {\\n  if (!fiber.dom) {\\n    fiber.dom = createDom(fiber)\\n  }\\n\\n  const elements = fiber.props.children\\n  let index = 0\\n  let prevSibling = null\\n\\n  while (index < elements.length) {\\n    const element = elements[index]\\n\\n    const newFiber = {\\n      type: element.type,\\n      props: element.props,\\n      parent: fiber,\\n      dom: null,\\n    }\\n\\n    if (index === 0) {\\n      fiber.child = newFiber\\n    } else {\\n      prevSibling.sibling = newFiber\\n    }\\n\\n    prevSibling = newFiber\\n    index++\\n  }\\n\\n  if (fiber.child) {\\n    return fiber.child\\n  }\\n  let nextFiber = fiber\\n  while (nextFiber) {\\n    if (nextFiber.sibling) {\\n      return nextFiber.sibling\\n    }\\n    nextFiber = nextFiber.parent\\n  }\\n}\\n\\nconst Didact = {\\n  createElement,\\n  render,\\n}\\n\\n/** @jsx Didact.createElement */\\nconst element = (\\n  <div id=\\\"foo\\\">\\n    <a>bar</a>\\n    <b />\\n  </div>\\n)\\nconst container = document.getElementById(\\\"root\\\")\\nDidact.render(element, container)\\n\")), mdx(\"p\", null, \"\\uC774 \\uACFC\\uC815\\uC740 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"commitRoot\"), \" \\uD568\\uC218\\uC5D0\\uC11C \\uC774\\uB8E8\\uC5B4\\uC9D1\\uB2C8\\uB2E4. \\uC5EC\\uAE30\\uC11C \\uBAA8\\uB4E0 \\uB178\\uB4DC\\uB97C \\uC7AC\\uADC0\\uC801\\uC73C\\uB85C DOM\\uC5D0 \\uCD94\\uAC00\\uD569\\uB2C8\\uB2E4.\"), mdx(\"h2\", {\n    \"id\": \"step-vi-재조정reconciliation\"\n  }, \"Step VI: \\uC7AC\\uC870\\uC815(Reconciliation)\"), mdx(\"p\", null, \"\\uC774\\uC81C\\uAE4C\\uC9C0 \\uC6B0\\uB9AC\\uB294 DOM\\uC5D0 \\uC694\\uC18C\\uB4E4\\uC744 \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"\\uB123\\uB294\"), \" \\uC791\\uC5C5\\uC744 \\uD588\\uC2B5\\uB2C8\\uB2E4. \\uADF8\\uB7FC \\uB178\\uB4DC\\uB97C \\uAC31\\uC2E0\\uACFC \\uC0AD\\uC81C\\uD558\\uB294 \\uAC83\\uC740 \\uC5B4\\uB5BB\\uAC8C \\uB41C \\uAC78\\uAE4C\\uC694?\"), mdx(\"p\", null, \"\\uB2E4\\uC74C\\uC5D0 \\uD560 \\uAC83\\uC774 \\uBC14\\uB85C \\uADF8 \\uBD80\\uBD84\\uC785\\uB2C8\\uB2E4. \\uC6B0\\uB9AC\\uAC00 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"render\"), \" \\uD568\\uC218\\uB85C \\uC5BB\\uC740 \\uC5D8\\uB9AC\\uBA3C\\uD2B8\\uB4E4\\uC744 \\uB9C8\\uC9C0\\uB9C9\\uC73C\\uB85C \\uCEE4\\uBC0B\\uD55C fiber \\uD2B8\\uB9AC\\uC640 \\uBE44\\uAD50\\uD574\\uC57C \\uD569\\uB2C8\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./21.jsx 41,43,45,57,58,63,64,66,69\",\n    \"file\": \"./21.jsx\",\n    \"41,43,45,57,58,63,64,66,69\": true\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children: children.map(child =>\\n        typeof child === \\\"object\\\"\\n          ? child\\n          : createTextElement(child)\\n      ),\\n    },\\n  }\\n}\\n\\nfunction createTextElement(text) {\\n  return {\\n    type: \\\"TEXT_ELEMENT\\\",\\n    props: {\\n      nodeValue: text,\\n      children: [],\\n    },\\n  }\\n}\\n\\nfunction createDom(fiber) {\\n  const dom =\\n    fiber.type == \\\"TEXT_ELEMENT\\\"\\n      ? document.createTextNode(\\\"\\\")\\n      : document.createElement(fiber.type)\\n\\n  const isProperty = key => key !== \\\"children\\\"\\n  Object.keys(fiber.props)\\n    .filter(isProperty)\\n    .forEach(name => {\\n      dom[name] = fiber.props[name]\\n    })\\n\\n  return dom\\n}\\n\\nfunction commitRoot() {\\n  commitWork(wipRoot.child)\\n  currentRoot = wipRoot\\n  wipRoot = null\\n}\\n\\nfunction commitWork(fiber) {\\n  if (!fiber) {\\n    return\\n  }\\n  const domParent = fiber.parent.dom\\n  domParent.appendChild(fiber.dom)\\n  commitWork(fiber.child)\\n  commitWork(fiber.sibling)\\n}\\n\\nfunction render(element, container) {\\n  wipRoot = {\\n    dom: container,\\n    props: {\\n      children: [element],\\n    },\\n    alternate: currentRoot,\\n  }\\n  nextUnitOfWork = wipRoot\\n}\\n\\nlet nextUnitOfWork = null\\nlet currentRoot = null\\nlet wipRoot = null\\n\\nfunction workLoop(deadline) {\\n  let shouldYield = false\\n  while (nextUnitOfWork && !shouldYield) {\\n    nextUnitOfWork = performUnitOfWork(\\n      nextUnitOfWork\\n    )\\n    shouldYield = deadline.timeRemaining() < 1\\n  }\\n\\n  if (!nextUnitOfWork && wipRoot) {\\n    commitRoot()\\n  }\\n\\n  requestIdleCallback(workLoop)\\n}\\n\\nrequestIdleCallback(workLoop)\\n\\nfunction performUnitOfWork(fiber) {\\n  if (!fiber.dom) {\\n    fiber.dom = createDom(fiber)\\n  }\\n\\n  const elements = fiber.props.children\\n  let index = 0\\n  let prevSibling = null\\n\\n  while (index < elements.length) {\\n    const element = elements[index]\\n\\n    const newFiber = {\\n      type: element.type,\\n      props: element.props,\\n      parent: fiber,\\n      dom: null,\\n    }\\n\\n    if (index === 0) {\\n      fiber.child = newFiber\\n    } else {\\n      prevSibling.sibling = newFiber\\n    }\\n\\n    prevSibling = newFiber\\n    index++\\n  }\\n\\n  if (fiber.child) {\\n    return fiber.child\\n  }\\n  let nextFiber = fiber\\n  while (nextFiber) {\\n    if (nextFiber.sibling) {\\n      return nextFiber.sibling\\n    }\\n    nextFiber = nextFiber.parent\\n  }\\n}\\n\\nconst Didact = {\\n  createElement,\\n  render,\\n}\\n\\n/** @jsx Didact.createElement */\\nconst element = (\\n  <div id=\\\"foo\\\">\\n    <a>bar</a>\\n    <b />\\n  </div>\\n)\\nconst container = document.getElementById(\\\"root\\\")\\nDidact.render(element, container)\\n\")), mdx(\"p\", null, \"\\uB530\\uB77C\\uC11C \\uCEE4\\uBC0B\\uC774 \\uB05D\\uB09C \\uB2E4\\uC74C\\uC5D0\\uB294 \\u201C\\uB9C8\\uC9C0\\uB9C9\\uC73C\\uB85C DOM\\uC5D0 \\uCEE4\\uBC0B\\uB41C fiber \\uD2B8\\uB9AC\\u201D\\uB97C \\uC800\\uC7A5\\uD560 \\uD544\\uC694\\uAC00 \\uC788\\uC2B5\\uB2C8\\uB2E4. \\uC774\\uB97C \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"currentRoot\"), \"\\uB77C\\uACE0 \\uD569\\uC2DC\\uB2E4.\"), mdx(\"p\", null, \"\\uB610\\uD55C \\uBAA8\\uB4E0 fiber\\uC5D0 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"alternate\"), \"\\uB77C\\uB294 \\uC18D\\uC131\\uC744 \\uCD94\\uAC00\\uD574\\uC57C \\uD569\\uB2C8\\uB2E4. \\uC774 \\uC18D\\uC131\\uC740 \\uC774\\uC804\\uC758 \\uCEE4\\uBC0B \\uB2E8\\uACC4\\uC5D0\\uC11C DOM\\uC5D0 \\uCD94\\uAC00\\uD588\\uB358 \\uC624\\uB798\\uB41C fiber\\uC5D0 \\uB300\\uD55C \\uB9C1\\uD06C\\uC785\\uB2C8\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./21.jsx 90:129\",\n    \"file\": \"./21.jsx\",\n    \"90:129\": true\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children: children.map(child =>\\n        typeof child === \\\"object\\\"\\n          ? child\\n          : createTextElement(child)\\n      ),\\n    },\\n  }\\n}\\n\\nfunction createTextElement(text) {\\n  return {\\n    type: \\\"TEXT_ELEMENT\\\",\\n    props: {\\n      nodeValue: text,\\n      children: [],\\n    },\\n  }\\n}\\n\\nfunction createDom(fiber) {\\n  const dom =\\n    fiber.type == \\\"TEXT_ELEMENT\\\"\\n      ? document.createTextNode(\\\"\\\")\\n      : document.createElement(fiber.type)\\n\\n  const isProperty = key => key !== \\\"children\\\"\\n  Object.keys(fiber.props)\\n    .filter(isProperty)\\n    .forEach(name => {\\n      dom[name] = fiber.props[name]\\n    })\\n\\n  return dom\\n}\\n\\nfunction commitRoot() {\\n  commitWork(wipRoot.child)\\n  currentRoot = wipRoot\\n  wipRoot = null\\n}\\n\\nfunction commitWork(fiber) {\\n  if (!fiber) {\\n    return\\n  }\\n  const domParent = fiber.parent.dom\\n  domParent.appendChild(fiber.dom)\\n  commitWork(fiber.child)\\n  commitWork(fiber.sibling)\\n}\\n\\nfunction render(element, container) {\\n  wipRoot = {\\n    dom: container,\\n    props: {\\n      children: [element],\\n    },\\n    alternate: currentRoot,\\n  }\\n  nextUnitOfWork = wipRoot\\n}\\n\\nlet nextUnitOfWork = null\\nlet currentRoot = null\\nlet wipRoot = null\\n\\nfunction workLoop(deadline) {\\n  let shouldYield = false\\n  while (nextUnitOfWork && !shouldYield) {\\n    nextUnitOfWork = performUnitOfWork(\\n      nextUnitOfWork\\n    )\\n    shouldYield = deadline.timeRemaining() < 1\\n  }\\n\\n  if (!nextUnitOfWork && wipRoot) {\\n    commitRoot()\\n  }\\n\\n  requestIdleCallback(workLoop)\\n}\\n\\nrequestIdleCallback(workLoop)\\n\\nfunction performUnitOfWork(fiber) {\\n  if (!fiber.dom) {\\n    fiber.dom = createDom(fiber)\\n  }\\n\\n  const elements = fiber.props.children\\n  let index = 0\\n  let prevSibling = null\\n\\n  while (index < elements.length) {\\n    const element = elements[index]\\n\\n    const newFiber = {\\n      type: element.type,\\n      props: element.props,\\n      parent: fiber,\\n      dom: null,\\n    }\\n\\n    if (index === 0) {\\n      fiber.child = newFiber\\n    } else {\\n      prevSibling.sibling = newFiber\\n    }\\n\\n    prevSibling = newFiber\\n    index++\\n  }\\n\\n  if (fiber.child) {\\n    return fiber.child\\n  }\\n  let nextFiber = fiber\\n  while (nextFiber) {\\n    if (nextFiber.sibling) {\\n      return nextFiber.sibling\\n    }\\n    nextFiber = nextFiber.parent\\n  }\\n}\\n\\nconst Didact = {\\n  createElement,\\n  render,\\n}\\n\\n/** @jsx Didact.createElement */\\nconst element = (\\n  <div id=\\\"foo\\\">\\n    <a>bar</a>\\n    <b />\\n  </div>\\n)\\nconst container = document.getElementById(\\\"root\\\")\\nDidact.render(element, container)\\n\")), mdx(\"p\", null, \"\\uC774\\uC81C \\uC0C8\\uB85C\\uC6B4 fiber\\uB97C \\uC0DD\\uC131\\uD558\\uB294 \\uCF54\\uB4DC\\uB97C \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"performUnitOfWork\"), \"\\uC5D0\\uC11C \\uCD94\\uCD9C\\uD574\\uC11C,\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./22.jsx 90,95,96,108,110,114[1]\",\n    \"file\": \"./22.jsx\",\n    \"90,95,96,108,110,114[1]\": true\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children: children.map(child =>\\n        typeof child === \\\"object\\\"\\n          ? child\\n          : createTextElement(child)\\n      ),\\n    },\\n  }\\n}\\n\\nfunction createTextElement(text) {\\n  return {\\n    type: \\\"TEXT_ELEMENT\\\",\\n    props: {\\n      nodeValue: text,\\n      children: [],\\n    },\\n  }\\n}\\n\\nfunction createDom(fiber) {\\n  const dom =\\n    fiber.type == \\\"TEXT_ELEMENT\\\"\\n      ? document.createTextNode(\\\"\\\")\\n      : document.createElement(fiber.type)\\n\\n  const isProperty = key => key !== \\\"children\\\"\\n  Object.keys(fiber.props)\\n    .filter(isProperty)\\n    .forEach(name => {\\n      dom[name] = fiber.props[name]\\n    })\\n\\n  return dom\\n}\\n\\nfunction commitRoot() {\\n  commitWork(wipRoot.child)\\n  currentRoot = wipRoot\\n  wipRoot = null\\n}\\n\\nfunction commitWork(fiber) {\\n  if (!fiber) {\\n    return\\n  }\\n  const domParent = fiber.parent.dom\\n  domParent.appendChild(fiber.dom)\\n  commitWork(fiber.child)\\n  commitWork(fiber.sibling)\\n}\\n\\nfunction render(element, container) {\\n  wipRoot = {\\n    dom: container,\\n    props: {\\n      children: [element],\\n    },\\n    alternate: currentRoot,\\n  }\\n  nextUnitOfWork = wipRoot\\n}\\n\\nlet nextUnitOfWork = null\\nlet currentRoot = null\\nlet wipRoot = null\\n\\nfunction workLoop(deadline) {\\n  let shouldYield = false\\n  while (nextUnitOfWork && !shouldYield) {\\n    nextUnitOfWork = performUnitOfWork(\\n      nextUnitOfWork\\n    )\\n    shouldYield = deadline.timeRemaining() < 1\\n  }\\n\\n  if (!nextUnitOfWork && wipRoot) {\\n    commitRoot()\\n  }\\n\\n  requestIdleCallback(workLoop)\\n}\\n\\nrequestIdleCallback(workLoop)\\n\\nfunction performUnitOfWork(fiber) {\\n  if (!fiber.dom) {\\n    fiber.dom = createDom(fiber)\\n  }\\n\\n  const elements = fiber.props.children\\n  reconcileChildren(fiber, elements)\\n\\n  if (fiber.child) {\\n    return fiber.child\\n  }\\n  let nextFiber = fiber\\n  while (nextFiber) {\\n    if (nextFiber.sibling) {\\n      return nextFiber.sibling\\n    }\\n    nextFiber = nextFiber.parent\\n  }\\n}\\n\\nfunction reconcileChildren(wipFiber, elements) {\\n  let index = 0\\n  let prevSibling = null\\n\\n  while (index < elements.length) {\\n    const element = elements[index]\\n\\n    const newFiber = {\\n      type: element.type,\\n      props: element.props,\\n      parent: wipFiber,\\n      dom: null,\\n    }\\n\\n    if (index === 0) {\\n      wipFiber.child = newFiber\\n    } else {\\n      prevSibling.sibling = newFiber\\n    }\\n\\n    prevSibling = newFiber\\n    index++\\n  }\\n}\\n\\nconst Didact = {\\n  createElement,\\n  render,\\n}\\n\\n/** @jsx Didact.createElement */\\nconst element = (\\n  <div id=\\\"foo\\\">\\n    <a>bar</a>\\n    <b />\\n  </div>\\n)\\nconst container = document.getElementById(\\\"root\\\")\\nDidact.render(element, container)\\n\")), mdx(\"p\", null, \"\\uC0C8\\uB85C \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reconcileChildren\"), \" \\uD568\\uC218\\uB97C \\uB9CC\\uB4ED\\uB2C8\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./22.jsx 110,133\",\n    \"file\": \"./22.jsx\",\n    \"110,133\": true\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children: children.map(child =>\\n        typeof child === \\\"object\\\"\\n          ? child\\n          : createTextElement(child)\\n      ),\\n    },\\n  }\\n}\\n\\nfunction createTextElement(text) {\\n  return {\\n    type: \\\"TEXT_ELEMENT\\\",\\n    props: {\\n      nodeValue: text,\\n      children: [],\\n    },\\n  }\\n}\\n\\nfunction createDom(fiber) {\\n  const dom =\\n    fiber.type == \\\"TEXT_ELEMENT\\\"\\n      ? document.createTextNode(\\\"\\\")\\n      : document.createElement(fiber.type)\\n\\n  const isProperty = key => key !== \\\"children\\\"\\n  Object.keys(fiber.props)\\n    .filter(isProperty)\\n    .forEach(name => {\\n      dom[name] = fiber.props[name]\\n    })\\n\\n  return dom\\n}\\n\\nfunction commitRoot() {\\n  commitWork(wipRoot.child)\\n  currentRoot = wipRoot\\n  wipRoot = null\\n}\\n\\nfunction commitWork(fiber) {\\n  if (!fiber) {\\n    return\\n  }\\n  const domParent = fiber.parent.dom\\n  domParent.appendChild(fiber.dom)\\n  commitWork(fiber.child)\\n  commitWork(fiber.sibling)\\n}\\n\\nfunction render(element, container) {\\n  wipRoot = {\\n    dom: container,\\n    props: {\\n      children: [element],\\n    },\\n    alternate: currentRoot,\\n  }\\n  nextUnitOfWork = wipRoot\\n}\\n\\nlet nextUnitOfWork = null\\nlet currentRoot = null\\nlet wipRoot = null\\n\\nfunction workLoop(deadline) {\\n  let shouldYield = false\\n  while (nextUnitOfWork && !shouldYield) {\\n    nextUnitOfWork = performUnitOfWork(\\n      nextUnitOfWork\\n    )\\n    shouldYield = deadline.timeRemaining() < 1\\n  }\\n\\n  if (!nextUnitOfWork && wipRoot) {\\n    commitRoot()\\n  }\\n\\n  requestIdleCallback(workLoop)\\n}\\n\\nrequestIdleCallback(workLoop)\\n\\nfunction performUnitOfWork(fiber) {\\n  if (!fiber.dom) {\\n    fiber.dom = createDom(fiber)\\n  }\\n\\n  const elements = fiber.props.children\\n  reconcileChildren(fiber, elements)\\n\\n  if (fiber.child) {\\n    return fiber.child\\n  }\\n  let nextFiber = fiber\\n  while (nextFiber) {\\n    if (nextFiber.sibling) {\\n      return nextFiber.sibling\\n    }\\n    nextFiber = nextFiber.parent\\n  }\\n}\\n\\nfunction reconcileChildren(wipFiber, elements) {\\n  let index = 0\\n  let prevSibling = null\\n\\n  while (index < elements.length) {\\n    const element = elements[index]\\n\\n    const newFiber = {\\n      type: element.type,\\n      props: element.props,\\n      parent: wipFiber,\\n      dom: null,\\n    }\\n\\n    if (index === 0) {\\n      wipFiber.child = newFiber\\n    } else {\\n      prevSibling.sibling = newFiber\\n    }\\n\\n    prevSibling = newFiber\\n    index++\\n  }\\n}\\n\\nconst Didact = {\\n  createElement,\\n  render,\\n}\\n\\n/** @jsx Didact.createElement */\\nconst element = (\\n  <div id=\\\"foo\\\">\\n    <a>bar</a>\\n    <b />\\n  </div>\\n)\\nconst container = document.getElementById(\\\"root\\\")\\nDidact.render(element, container)\\n\")), mdx(\"p\", null, \"\\uC774\\uC81C \\uC774\\uACF3\\uC5D0\\uC11C \\uC624\\uB798\\uB41C fiber\\uB97C \\uC0C8\\uB85C\\uC6B4 \\uC5D8\\uB9AC\\uBA3C\\uD2B8\\uB85C \\uC7AC\\uC870\\uC815(reconcile) \\uD560 \\uAC83\\uC785\\uB2C8\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./23.jsx 110:113,116:120,123\",\n    \"file\": \"./23.jsx\",\n    \"110:113,116:120,123\": true\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children: children.map(child =>\\n        typeof child === \\\"object\\\"\\n          ? child\\n          : createTextElement(child)\\n      ),\\n    },\\n  }\\n}\\n\\nfunction createTextElement(text) {\\n  return {\\n    type: \\\"TEXT_ELEMENT\\\",\\n    props: {\\n      nodeValue: text,\\n      children: [],\\n    },\\n  }\\n}\\n\\nfunction createDom(fiber) {\\n  const dom =\\n    fiber.type == \\\"TEXT_ELEMENT\\\"\\n      ? document.createTextNode(\\\"\\\")\\n      : document.createElement(fiber.type)\\n\\n  const isProperty = key => key !== \\\"children\\\"\\n  Object.keys(fiber.props)\\n    .filter(isProperty)\\n    .forEach(name => {\\n      dom[name] = fiber.props[name]\\n    })\\n\\n  return dom\\n}\\n\\nfunction commitRoot() {\\n  commitWork(wipRoot.child)\\n  currentRoot = wipRoot\\n  wipRoot = null\\n}\\n\\nfunction commitWork(fiber) {\\n  if (!fiber) {\\n    return\\n  }\\n  const domParent = fiber.parent.dom\\n  domParent.appendChild(fiber.dom)\\n  commitWork(fiber.child)\\n  commitWork(fiber.sibling)\\n}\\n\\nfunction render(element, container) {\\n  wipRoot = {\\n    dom: container,\\n    props: {\\n      children: [element],\\n    },\\n    alternate: currentRoot,\\n  }\\n  nextUnitOfWork = wipRoot\\n}\\n\\nlet nextUnitOfWork = null\\nlet currentRoot = null\\nlet wipRoot = null\\n\\nfunction workLoop(deadline) {\\n  let shouldYield = false\\n  while (nextUnitOfWork && !shouldYield) {\\n    nextUnitOfWork = performUnitOfWork(\\n      nextUnitOfWork\\n    )\\n    shouldYield = deadline.timeRemaining() < 1\\n  }\\n\\n  if (!nextUnitOfWork && wipRoot) {\\n    commitRoot()\\n  }\\n\\n  requestIdleCallback(workLoop)\\n}\\n\\nrequestIdleCallback(workLoop)\\n\\nfunction performUnitOfWork(fiber) {\\n  if (!fiber.dom) {\\n    fiber.dom = createDom(fiber)\\n  }\\n\\n  const elements = fiber.props.children\\n  reconcileChildren(fiber, elements)\\n\\n  if (fiber.child) {\\n    return fiber.child\\n  }\\n  let nextFiber = fiber\\n  while (nextFiber) {\\n    if (nextFiber.sibling) {\\n      return nextFiber.sibling\\n    }\\n    nextFiber = nextFiber.parent\\n  }\\n}\\n\\nfunction reconcileChildren(wipFiber, elements) {\\n  let index = 0\\n  let oldFiber =\\n    wipFiber.alternate && wipFiber.alternate.child\\n  let prevSibling = null\\n\\n  while (\\n    index < elements.length ||\\n    oldFiber != null\\n  ) {\\n    const element = elements[index]\\n    let newFiber = null\\n\\n    // TODO compare oldFiber to element\\n\\n    if (oldFiber) {\\n      oldFiber = oldFiber.sibling\\n    }\\n\\n    if (index === 0) {\\n      wipFiber.child = newFiber\\n    } else if (element) {\\n      prevSibling.sibling = newFiber\\n    }\\n\\n    prevSibling = newFiber\\n    index++\\n  }\\n}\\n\\nconst Didact = {\\n  createElement,\\n  render,\\n}\\n\\n/** @jsx Didact.createElement */\\nconst element = (\\n  <div id=\\\"foo\\\">\\n    <a>bar</a>\\n    <b />\\n  </div>\\n)\\nconst container = document.getElementById(\\\"root\\\")\\nDidact.render(element, container)\\n\")), mdx(\"p\", null, \"\\uC624\\uB798\\uB41C fiber(\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"wipFiber.alternate\"), \")\\uC758 \\uC790\\uC2DD\\uB4E4(\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"children\"), \")\\uACFC \\uC7AC\\uC870\\uC815\\uD558\\uAE30\\uB97C \\uC6D0\\uD558\\uB294 \\uC5D8\\uB9AC\\uBA3C\\uD2B8\\uC758 \\uBC30\\uC5F4\\uC744 \\uB3D9\\uC2DC\\uC5D0 \\uC21C\\uD68C\\uD569\\uB2C8\\uB2E4.\"), mdx(\"p\", null, \"\\uB9CC\\uC57D \\uBC30\\uC5F4\\uACFC \\uB9C1\\uD06C\\uB4DC \\uB9AC\\uC2A4\\uD2B8\\uB97C \\uB3D9\\uC2DC\\uC5D0 \\uBC18\\uBCF5\\uD558\\uB294 \\uB370 \\uD544\\uC694\\uD55C \\uC774 \\uBAA8\\uB4E0 \\uBCF4\\uC77C\\uB7EC\\uD50C\\uB808\\uC774\\uD2B8\\uB97C \\uC2E0\\uACBD\\uC4F0\\uC9C0 \\uC54A\\uB294\\uB2E4\\uBA74, while\\uBB38 \\uC548\\uC5D0\\uB294 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"oldFiber\"), \"\\uC640 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"element\"), \"\\uB77C\\uB294 \\uAC00\\uC7A5 \\uC911\\uC694\\uD55C \\uBD80\\uBD84\\uB9CC \\uB0A8\\uC2B5\\uB2C8\\uB2E4. \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"element\"), \"\\uB294 \\uC6B0\\uB9AC\\uAC00 DOM \\uC548\\uC5D0 \\uB80C\\uB354\\uB9C1\\uD558\\uACE0 \\uC2F6\\uC740 \\uAC83\\uC774\\uBA70, \", mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"oldFiber\"), \"\\uB294 \\uAC00\\uC7A5 \\uB9C8\\uC9C0\\uB9C9\\uC73C\\uB85C \\uB80C\\uB354\\uB9C1 \\uD588\\uB358 \\uAC83\\uC785\\uB2C8\\uB2E4.\")), mdx(\"p\", null, \"\\uC774\\uB97C DOM\\uC5D0 \\uC801\\uC6A9\\uD558\\uAE30 \\uC704\\uD574\\uC11C\\uB294 \\uB458 \\uC0AC\\uC774\\uC5D0 \\uC5B4\\uB5A4 \\uCC28\\uC774\\uAC00 \\uC0DD\\uACBC\\uB294\\uC9C0 \\uBE44\\uAD50\\uD574\\uC57C \\uD569\\uB2C8\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./24.jsx\",\n    \"file\": \"./24.jsx\"\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children: children.map(child =>\\n        typeof child === \\\"object\\\"\\n          ? child\\n          : createTextElement(child)\\n      ),\\n    },\\n  }\\n}\\n\\nfunction createTextElement(text) {\\n  return {\\n    type: \\\"TEXT_ELEMENT\\\",\\n    props: {\\n      nodeValue: text,\\n      children: [],\\n    },\\n  }\\n}\\n\\nfunction createDom(fiber) {\\n  const dom =\\n    fiber.type == \\\"TEXT_ELEMENT\\\"\\n      ? document.createTextNode(\\\"\\\")\\n      : document.createElement(fiber.type)\\n\\n  const isProperty = key => key !== \\\"children\\\"\\n  Object.keys(fiber.props)\\n    .filter(isProperty)\\n    .forEach(name => {\\n      dom[name] = fiber.props[name]\\n    })\\n\\n  return dom\\n}\\n\\nfunction commitRoot() {\\n  commitWork(wipRoot.child)\\n  currentRoot = wipRoot\\n  wipRoot = null\\n}\\n\\nfunction commitWork(fiber) {\\n  if (!fiber) {\\n    return\\n  }\\n  const domParent = fiber.parent.dom\\n  domParent.appendChild(fiber.dom)\\n  commitWork(fiber.child)\\n  commitWork(fiber.sibling)\\n}\\n\\nfunction render(element, container) {\\n  wipRoot = {\\n    dom: container,\\n    props: {\\n      children: [element],\\n    },\\n    alternate: currentRoot,\\n  }\\n  nextUnitOfWork = wipRoot\\n}\\n\\nlet nextUnitOfWork = null\\nlet currentRoot = null\\nlet wipRoot = null\\n\\nfunction workLoop(deadline) {\\n  let shouldYield = false\\n  while (nextUnitOfWork && !shouldYield) {\\n    nextUnitOfWork = performUnitOfWork(\\n      nextUnitOfWork\\n    )\\n    shouldYield = deadline.timeRemaining() < 1\\n  }\\n\\n  if (!nextUnitOfWork && wipRoot) {\\n    commitRoot()\\n  }\\n\\n  requestIdleCallback(workLoop)\\n}\\n\\nrequestIdleCallback(workLoop)\\n\\nfunction performUnitOfWork(fiber) {\\n  if (!fiber.dom) {\\n    fiber.dom = createDom(fiber)\\n  }\\n\\n  const elements = fiber.props.children\\n  reconcileChildren(fiber, elements)\\n\\n  if (fiber.child) {\\n    return fiber.child\\n  }\\n  let nextFiber = fiber\\n  while (nextFiber) {\\n    if (nextFiber.sibling) {\\n      return nextFiber.sibling\\n    }\\n    nextFiber = nextFiber.parent\\n  }\\n}\\n\\nfunction reconcileChildren(wipFiber, elements) {\\n  let index = 0\\n  let oldFiber =\\n    wipFiber.alternate && wipFiber.alternate.child\\n  let prevSibling = null\\n\\n  while (\\n    index < elements.length ||\\n    oldFiber != null\\n  ) {\\n    const element = elements[index]\\n    let newFiber = null\\n\\n    const sameType =\\n      oldFiber &&\\n      element &&\\n      element.type == oldFiber.type\\n\\n    if (sameType) {\\n      // TODO update the node\\n    }\\n    if (element && !sameType) {\\n      // TODO add this node\\n    }\\n    if (oldFiber && !sameType) {\\n      // TODO delete the oldFiber's node\\n    }\\n\\n    if (oldFiber) {\\n      oldFiber = oldFiber.sibling\\n    }\\n\\n    if (index === 0) {\\n      wipFiber.child = newFiber\\n    } else if (element) {\\n      prevSibling.sibling = newFiber\\n    }\\n\\n    prevSibling = newFiber\\n    index++\\n  }\\n}\\n\\nconst Didact = {\\n  createElement,\\n  render,\\n}\\n\\n/** @jsx Didact.createElement */\\nconst element = (\\n  <div id=\\\"foo\\\">\\n    <a>bar</a>\\n    <b />\\n  </div>\\n)\\nconst container = document.getElementById(\\\"root\\\")\\nDidact.render(element, container)\\n\")), mdx(\"p\", null, \"\\uC774\\uB7EC\\uD55C \\uBE44\\uAD50\\uB97C \\uC704\\uD574\\uC11C \\uD0C0\\uC785\\uC744 \\uC0AC\\uC6A9\\uD569\\uB2C8\\uB2E4.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"\\uB9CC\\uC57D \\uC624\\uB798\\uB41C fiber\\uC640 \\uC0C8\\uB85C\\uC6B4 \\uC5D8\\uB9AC\\uBA3C\\uD2B8\\uAC00 \\uAC19\\uC740 \\uD0C0\\uC785\\uC774\\uB77C\\uBA74, DOM \\uB178\\uB4DC\\uB97C \\uC720\\uC9C0\\uD558\\uACE0 \\uC0C8\\uB85C\\uC6B4 props\\uB9CC \\uC5C5\\uB370\\uC774\\uD2B8 \\uD569\\uB2C8\\uB2E4.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"\\uB9CC\\uC57D \\uC11C\\uB85C \\uD0C0\\uC785\\uC774 \\uB2E4\\uB974\\uACE0 \\uC0C8\\uB85C\\uC6B4 \\uC5D8\\uB9AC\\uBA3C\\uD2B8\\uAC00 \\uC874\\uC7AC\\uD55C\\uB2E4\\uBA74, \\uC774\\uB294 \\uC0C8\\uB85C\\uC6B4 DOM \\uB178\\uB4DC \\uC0DD\\uC131\\uC774 \\uD544\\uC694\\uD558\\uB2E4\\uB294 \\uB73B\\uC785\\uB2C8\\uB2E4.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"\\uADF8\\uB9AC\\uACE0 \\uB9CC\\uC57D \\uD0C0\\uC785\\uC774 \\uB2E4\\uB974\\uACE0 \\uC624\\uB798\\uB41C fiber\\uAC00 \\uC874\\uC7AC\\uD55C\\uB2E4\\uBA74, \\uC624\\uB798\\uB41C \\uB178\\uB4DC\\uB97C \\uC81C\\uAC70\\uD574\\uC57C \\uD569\\uB2C8\\uB2E4.\"))), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Here React also uses keys, that makes a better reconciliation. For example, it detects when \", mdx(\"inlineCode\", {\n    parentName: \"em\"\n  }, \"children\"), \" change places in the element array.\")), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"\\uC5EC\\uAE30\\uC11C \\uB9AC\\uC561\\uD2B8\\uB294 \\uB354 \\uB098\\uC740 \\uC7AC\\uC870\\uC815\\uC744 \\uD558\\uAE30 \\uC704\\uD574 \\uD0A4(key)\\uB4E4\\uC744 \\uC0AC\\uC6A9\\uD569\\uB2C8\\uB2E4. \\uC608\\uB97C \\uB4E4\\uBA74, \\uD0A4\\uB97C \\uC0AC\\uC6A9\\uD558\\uC5EC \\uC5D8\\uB9AC\\uBA3C\\uD2B8 \\uBC30\\uC5F4\\uC758 \\uC790\\uC2DD\\uC774 \\uBCC0\\uD558\\uB294 \\uC9C0\\uC810\\uC744 \\uAC10\\uC9C0\\uD569\\uB2C8\\uB2E4..\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./25.jsx 123:137\",\n    \"file\": \"./25.jsx\",\n    \"123:137\": true\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children: children.map(child =>\\n        typeof child === \\\"object\\\"\\n          ? child\\n          : createTextElement(child)\\n      ),\\n    },\\n  }\\n}\\n\\nfunction createTextElement(text) {\\n  return {\\n    type: \\\"TEXT_ELEMENT\\\",\\n    props: {\\n      nodeValue: text,\\n      children: [],\\n    },\\n  }\\n}\\n\\nfunction createDom(fiber) {\\n  const dom =\\n    fiber.type == \\\"TEXT_ELEMENT\\\"\\n      ? document.createTextNode(\\\"\\\")\\n      : document.createElement(fiber.type)\\n\\n  const isProperty = key => key !== \\\"children\\\"\\n  Object.keys(fiber.props)\\n    .filter(isProperty)\\n    .forEach(name => {\\n      dom[name] = fiber.props[name]\\n    })\\n\\n  return dom\\n}\\n\\nfunction commitRoot() {\\n  commitWork(wipRoot.child)\\n  currentRoot = wipRoot\\n  wipRoot = null\\n}\\n\\nfunction commitWork(fiber) {\\n  if (!fiber) {\\n    return\\n  }\\n  const domParent = fiber.parent.dom\\n  domParent.appendChild(fiber.dom)\\n  commitWork(fiber.child)\\n  commitWork(fiber.sibling)\\n}\\n\\nfunction render(element, container) {\\n  wipRoot = {\\n    dom: container,\\n    props: {\\n      children: [element],\\n    },\\n    alternate: currentRoot,\\n  }\\n  nextUnitOfWork = wipRoot\\n}\\n\\nlet nextUnitOfWork = null\\nlet currentRoot = null\\nlet wipRoot = null\\n\\nfunction workLoop(deadline) {\\n  let shouldYield = false\\n  while (nextUnitOfWork && !shouldYield) {\\n    nextUnitOfWork = performUnitOfWork(\\n      nextUnitOfWork\\n    )\\n    shouldYield = deadline.timeRemaining() < 1\\n  }\\n\\n  if (!nextUnitOfWork && wipRoot) {\\n    commitRoot()\\n  }\\n\\n  requestIdleCallback(workLoop)\\n}\\n\\nrequestIdleCallback(workLoop)\\n\\nfunction performUnitOfWork(fiber) {\\n  if (!fiber.dom) {\\n    fiber.dom = createDom(fiber)\\n  }\\n\\n  const elements = fiber.props.children\\n  reconcileChildren(fiber, elements)\\n\\n  if (fiber.child) {\\n    return fiber.child\\n  }\\n  let nextFiber = fiber\\n  while (nextFiber) {\\n    if (nextFiber.sibling) {\\n      return nextFiber.sibling\\n    }\\n    nextFiber = nextFiber.parent\\n  }\\n}\\n\\nfunction reconcileChildren(wipFiber, elements) {\\n  let index = 0\\n  let oldFiber =\\n    wipFiber.alternate && wipFiber.alternate.child\\n  let prevSibling = null\\n\\n  while (\\n    index < elements.length ||\\n    oldFiber != null\\n  ) {\\n    const element = elements[index]\\n    let newFiber = null\\n\\n    const sameType =\\n      oldFiber &&\\n      element &&\\n      element.type == oldFiber.type\\n\\n    if (sameType) {\\n      newFiber = {\\n        type: oldFiber.type,\\n        props: element.props,\\n        dom: oldFiber.dom,\\n        parent: wipFiber,\\n        alternate: oldFiber,\\n        effectTag: \\\"UPDATE\\\",\\n      }\\n    }\\n    if (element && !sameType) {\\n      // TODO add this node\\n    }\\n    if (oldFiber && !sameType) {\\n      // TODO delete the oldFiber's node\\n    }\\n\\n    if (oldFiber) {\\n      oldFiber = oldFiber.sibling\\n    }\\n\\n    if (index === 0) {\\n      wipFiber.child = newFiber\\n    } else if (element) {\\n      prevSibling.sibling = newFiber\\n    }\\n\\n    prevSibling = newFiber\\n    index++\\n  }\\n}\\n\\nconst Didact = {\\n  createElement,\\n  render,\\n}\\n\\n/** @jsx Didact.createElement */\\nconst element = (\\n  <div id=\\\"foo\\\">\\n    <a>bar</a>\\n    <b />\\n  </div>\\n)\\nconst container = document.getElementById(\\\"root\\\")\\nDidact.render(element, container)\\n\")), mdx(\"p\", null, \"\\uC624\\uB798\\uB41C fiber\\uC640 \\uC5D8\\uB9AC\\uBA3C\\uD2B8\\uAC00 \\uAC19\\uC740 \\uD0C0\\uC785\\uC744 \\uAC00\\uC9C8 \\uB54C, \\uC624\\uB798\\uB41C fiber\\uC640 \\uC5D8\\uB9AC\\uBA3C\\uD2B8\\uC758 props\\uC5D0\\uC11C \\uC0C8\\uB85C\\uC6B4 fiber\\uB97C \\uC0DD\\uC131\\uD558\\uACE0 DOM \\uB178\\uB4DC\\uB97C \\uC720\\uC9C0\\uD569\\uB2C8\\uB2E4.\"), mdx(\"p\", null, \"\\uB610\\uD55C fiber\\uC5D0 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"effectTag\"), \" \\uB77C\\uB294 \\uC0C8\\uB85C\\uC6B4 \\uC18D\\uC131\\uC744 \\uCD94\\uAC00\\uD569\\uB2C8\\uB2E4. \\uC774 \\uC18D\\uC131\\uC740 \\uB098\\uC911\\uC5D0 \\uCEE4\\uBC0B \\uB2E8\\uACC4\\uC5D0\\uC11C \\uC0AC\\uC6A9\\uD558\\uAC8C \\uB429\\uB2C8\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./26.jsx 138:147\",\n    \"file\": \"./26.jsx\",\n    \"138:147\": true\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children: children.map(child =>\\n        typeof child === \\\"object\\\"\\n          ? child\\n          : createTextElement(child)\\n      ),\\n    },\\n  }\\n}\\n\\nfunction createTextElement(text) {\\n  return {\\n    type: \\\"TEXT_ELEMENT\\\",\\n    props: {\\n      nodeValue: text,\\n      children: [],\\n    },\\n  }\\n}\\n\\nfunction createDom(fiber) {\\n  const dom =\\n    fiber.type == \\\"TEXT_ELEMENT\\\"\\n      ? document.createTextNode(\\\"\\\")\\n      : document.createElement(fiber.type)\\n\\n  const isProperty = key => key !== \\\"children\\\"\\n  Object.keys(fiber.props)\\n    .filter(isProperty)\\n    .forEach(name => {\\n      dom[name] = fiber.props[name]\\n    })\\n\\n  return dom\\n}\\n\\nfunction commitRoot() {\\n  commitWork(wipRoot.child)\\n  currentRoot = wipRoot\\n  wipRoot = null\\n}\\n\\nfunction commitWork(fiber) {\\n  if (!fiber) {\\n    return\\n  }\\n  const domParent = fiber.parent.dom\\n  domParent.appendChild(fiber.dom)\\n  commitWork(fiber.child)\\n  commitWork(fiber.sibling)\\n}\\n\\nfunction render(element, container) {\\n  wipRoot = {\\n    dom: container,\\n    props: {\\n      children: [element],\\n    },\\n    alternate: currentRoot,\\n  }\\n  nextUnitOfWork = wipRoot\\n}\\n\\nlet nextUnitOfWork = null\\nlet currentRoot = null\\nlet wipRoot = null\\n\\nfunction workLoop(deadline) {\\n  let shouldYield = false\\n  while (nextUnitOfWork && !shouldYield) {\\n    nextUnitOfWork = performUnitOfWork(\\n      nextUnitOfWork\\n    )\\n    shouldYield = deadline.timeRemaining() < 1\\n  }\\n\\n  if (!nextUnitOfWork && wipRoot) {\\n    commitRoot()\\n  }\\n\\n  requestIdleCallback(workLoop)\\n}\\n\\nrequestIdleCallback(workLoop)\\n\\nfunction performUnitOfWork(fiber) {\\n  if (!fiber.dom) {\\n    fiber.dom = createDom(fiber)\\n  }\\n\\n  const elements = fiber.props.children\\n  reconcileChildren(fiber, elements)\\n\\n  if (fiber.child) {\\n    return fiber.child\\n  }\\n  let nextFiber = fiber\\n  while (nextFiber) {\\n    if (nextFiber.sibling) {\\n      return nextFiber.sibling\\n    }\\n    nextFiber = nextFiber.parent\\n  }\\n}\\n\\nfunction reconcileChildren(wipFiber, elements) {\\n  let index = 0\\n  let oldFiber =\\n    wipFiber.alternate && wipFiber.alternate.child\\n  let prevSibling = null\\n\\n  while (\\n    index < elements.length ||\\n    oldFiber != null\\n  ) {\\n    const element = elements[index]\\n    let newFiber = null\\n\\n    const sameType =\\n      oldFiber &&\\n      element &&\\n      element.type == oldFiber.type\\n\\n    if (sameType) {\\n      newFiber = {\\n        type: oldFiber.type,\\n        props: element.props,\\n        dom: oldFiber.dom,\\n        parent: wipFiber,\\n        alternate: oldFiber,\\n        effectTag: \\\"UPDATE\\\",\\n      }\\n    }\\n    if (element && !sameType) {\\n      newFiber = {\\n        type: element.type,\\n        props: element.props,\\n        dom: null,\\n        parent: wipFiber,\\n        alternate: null,\\n        effectTag: \\\"PLACEMENT\\\",\\n      }\\n    }\\n    if (oldFiber && !sameType) {\\n      // TODO delete the oldFiber's node\\n    }\\n\\n    if (oldFiber) {\\n      oldFiber = oldFiber.sibling\\n    }\\n\\n    if (index === 0) {\\n      wipFiber.child = newFiber\\n    } else if (element) {\\n      prevSibling.sibling = newFiber\\n    }\\n\\n    prevSibling = newFiber\\n    index++\\n  }\\n}\\n\\nconst Didact = {\\n  createElement,\\n  render,\\n}\\n\\n/** @jsx Didact.createElement */\\nconst element = (\\n  <div id=\\\"foo\\\">\\n    <a>bar</a>\\n    <b />\\n  </div>\\n)\\nconst container = document.getElementById(\\\"root\\\")\\nDidact.render(element, container)\\n\")), mdx(\"p\", null, \"\\uADF8\\uB9AC\\uACE0 \\uC0C8\\uB85C\\uC6B4 DOM \\uB178\\uB4DC\\uAC00 \\uD544\\uC694\\uD55C \\uACBD\\uC6B0, \\uC0C8\\uB85C\\uC6B4 fiber\\uC5D0 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"PLACEMENT\"), \"\\uB77C\\uB294 effect tag\\uB97C \\uBD99\\uC785\\uB2C8\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./27.jsx 148:151\",\n    \"file\": \"./27.jsx\",\n    \"148:151\": true\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children: children.map(child =>\\n        typeof child === \\\"object\\\"\\n          ? child\\n          : createTextElement(child)\\n      ),\\n    },\\n  }\\n}\\n\\nfunction createTextElement(text) {\\n  return {\\n    type: \\\"TEXT_ELEMENT\\\",\\n    props: {\\n      nodeValue: text,\\n      children: [],\\n    },\\n  }\\n}\\n\\nfunction createDom(fiber) {\\n  const dom =\\n    fiber.type == \\\"TEXT_ELEMENT\\\"\\n      ? document.createTextNode(\\\"\\\")\\n      : document.createElement(fiber.type)\\n\\n  const isProperty = key => key !== \\\"children\\\"\\n  Object.keys(fiber.props)\\n    .filter(isProperty)\\n    .forEach(name => {\\n      dom[name] = fiber.props[name]\\n    })\\n\\n  return dom\\n}\\n\\nfunction commitRoot() {\\n  commitWork(wipRoot.child)\\n  currentRoot = wipRoot\\n  wipRoot = null\\n}\\n\\nfunction commitWork(fiber) {\\n  if (!fiber) {\\n    return\\n  }\\n  const domParent = fiber.parent.dom\\n  domParent.appendChild(fiber.dom)\\n  commitWork(fiber.child)\\n  commitWork(fiber.sibling)\\n}\\n\\nfunction render(element, container) {\\n  wipRoot = {\\n    dom: container,\\n    props: {\\n      children: [element],\\n    },\\n    alternate: currentRoot,\\n  }\\n  nextUnitOfWork = wipRoot\\n}\\n\\nlet nextUnitOfWork = null\\nlet currentRoot = null\\nlet wipRoot = null\\n\\nfunction workLoop(deadline) {\\n  let shouldYield = false\\n  while (nextUnitOfWork && !shouldYield) {\\n    nextUnitOfWork = performUnitOfWork(\\n      nextUnitOfWork\\n    )\\n    shouldYield = deadline.timeRemaining() < 1\\n  }\\n\\n  if (!nextUnitOfWork && wipRoot) {\\n    commitRoot()\\n  }\\n\\n  requestIdleCallback(workLoop)\\n}\\n\\nrequestIdleCallback(workLoop)\\n\\nfunction performUnitOfWork(fiber) {\\n  if (!fiber.dom) {\\n    fiber.dom = createDom(fiber)\\n  }\\n\\n  const elements = fiber.props.children\\n  reconcileChildren(fiber, elements)\\n\\n  if (fiber.child) {\\n    return fiber.child\\n  }\\n  let nextFiber = fiber\\n  while (nextFiber) {\\n    if (nextFiber.sibling) {\\n      return nextFiber.sibling\\n    }\\n    nextFiber = nextFiber.parent\\n  }\\n}\\n\\nfunction reconcileChildren(wipFiber, elements) {\\n  let index = 0\\n  let oldFiber =\\n    wipFiber.alternate && wipFiber.alternate.child\\n  let prevSibling = null\\n\\n  while (\\n    index < elements.length ||\\n    oldFiber != null\\n  ) {\\n    const element = elements[index]\\n    let newFiber = null\\n\\n    const sameType =\\n      oldFiber &&\\n      element &&\\n      element.type == oldFiber.type\\n\\n    if (sameType) {\\n      newFiber = {\\n        type: oldFiber.type,\\n        props: element.props,\\n        dom: oldFiber.dom,\\n        parent: wipFiber,\\n        alternate: oldFiber,\\n        effectTag: \\\"UPDATE\\\",\\n      }\\n    }\\n    if (element && !sameType) {\\n      newFiber = {\\n        type: element.type,\\n        props: element.props,\\n        dom: null,\\n        parent: wipFiber,\\n        alternate: null,\\n        effectTag: \\\"PLACEMENT\\\",\\n      }\\n    }\\n    if (oldFiber && !sameType) {\\n      oldFiber.effectTag = \\\"DELETION\\\"\\n      deletions.push(oldFiber)\\n    }\\n\\n    if (oldFiber) {\\n      oldFiber = oldFiber.sibling\\n    }\\n\\n    if (index === 0) {\\n      wipFiber.child = newFiber\\n    } else if (element) {\\n      prevSibling.sibling = newFiber\\n    }\\n\\n    prevSibling = newFiber\\n    index++\\n  }\\n}\\n\\nconst Didact = {\\n  createElement,\\n  render,\\n}\\n\\n/** @jsx Didact.createElement */\\nconst element = (\\n  <div id=\\\"foo\\\">\\n    <a>bar</a>\\n    <b />\\n  </div>\\n)\\nconst container = document.getElementById(\\\"root\\\")\\nDidact.render(element, container)\\n\")), mdx(\"p\", null, \"\\uB178\\uB4DC\\uB97C \\uC0AD\\uC81C\\uD574\\uC57C \\uD558\\uB294 \\uACBD\\uC6B0\\uC5D0\\uB294 \\uC0C8\\uB85C\\uC6B4 fiber\\uAC00 \\uD544\\uC694\\uD558\\uC9C0 \\uC54A\\uC73C\\uBA70, \\uC624\\uB798\\uB41C fiber\\uC5D0 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DELETION\"), \" \\uD0DC\\uADF8\\uB97C \\uCD94\\uAC00\\uD569\\uB2C8\\uB2E4.\"), mdx(\"p\", null, \"\\uD558\\uC9C0\\uB9CC fiber \\uD2B8\\uB9AC\\uB97C DOM\\uC5D0 \\uCEE4\\uBC0B\\uD560 \\uB54C, \\uC791\\uC5C5 \\uC911\\uC778 \\uB8E8\\uD2B8(work in progress root)\\uC5D0\\uB294 \\uC624\\uB798\\uB41C fiber\\uAC00 \\uC5C6\\uC2B5\\uB2C8\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./28.jsx 57,65,67,72\",\n    \"file\": \"./28.jsx\",\n    \"57,65,67,72\": true\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children: children.map(child =>\\n        typeof child === \\\"object\\\"\\n          ? child\\n          : createTextElement(child)\\n      ),\\n    },\\n  }\\n}\\n\\nfunction createTextElement(text) {\\n  return {\\n    type: \\\"TEXT_ELEMENT\\\",\\n    props: {\\n      nodeValue: text,\\n      children: [],\\n    },\\n  }\\n}\\n\\nfunction createDom(fiber) {\\n  const dom =\\n    fiber.type == \\\"TEXT_ELEMENT\\\"\\n      ? document.createTextNode(\\\"\\\")\\n      : document.createElement(fiber.type)\\n\\n  const isProperty = key => key !== \\\"children\\\"\\n  Object.keys(fiber.props)\\n    .filter(isProperty)\\n    .forEach(name => {\\n      dom[name] = fiber.props[name]\\n    })\\n\\n  return dom\\n}\\n\\nfunction commitRoot() {\\n  commitWork(wipRoot.child)\\n  currentRoot = wipRoot\\n  wipRoot = null\\n}\\n\\nfunction commitWork(fiber) {\\n  if (!fiber) {\\n    return\\n  }\\n  const domParent = fiber.parent.dom\\n  domParent.appendChild(fiber.dom)\\n  commitWork(fiber.child)\\n  commitWork(fiber.sibling)\\n}\\n\\nfunction render(element, container) {\\n  wipRoot = {\\n    dom: container,\\n    props: {\\n      children: [element],\\n    },\\n    alternate: currentRoot,\\n  }\\n  deletions = []\\n  nextUnitOfWork = wipRoot\\n}\\n\\nlet nextUnitOfWork = null\\nlet currentRoot = null\\nlet wipRoot = null\\nlet deletions = null\\n\\nfunction workLoop(deadline) {\\n  let shouldYield = false\\n  while (nextUnitOfWork && !shouldYield) {\\n    nextUnitOfWork = performUnitOfWork(\\n      nextUnitOfWork\\n    )\\n    shouldYield = deadline.timeRemaining() < 1\\n  }\\n\\n  if (!nextUnitOfWork && wipRoot) {\\n    commitRoot()\\n  }\\n\\n  requestIdleCallback(workLoop)\\n}\\n\\nrequestIdleCallback(workLoop)\\n\\nfunction performUnitOfWork(fiber) {\\n  if (!fiber.dom) {\\n    fiber.dom = createDom(fiber)\\n  }\\n\\n  const elements = fiber.props.children\\n  reconcileChildren(fiber, elements)\\n\\n  if (fiber.child) {\\n    return fiber.child\\n  }\\n  let nextFiber = fiber\\n  while (nextFiber) {\\n    if (nextFiber.sibling) {\\n      return nextFiber.sibling\\n    }\\n    nextFiber = nextFiber.parent\\n  }\\n}\\n\\nfunction reconcileChildren(wipFiber, elements) {\\n  let index = 0\\n  let oldFiber =\\n    wipFiber.alternate && wipFiber.alternate.child\\n  let prevSibling = null\\n\\n  while (\\n    index < elements.length ||\\n    oldFiber != null\\n  ) {\\n    const element = elements[index]\\n    let newFiber = null\\n\\n    const sameType =\\n      oldFiber &&\\n      element &&\\n      element.type == oldFiber.type\\n\\n    if (sameType) {\\n      newFiber = {\\n        type: oldFiber.type,\\n        props: element.props,\\n        dom: oldFiber.dom,\\n        parent: wipFiber,\\n        alternate: oldFiber,\\n        effectTag: \\\"UPDATE\\\",\\n      }\\n    }\\n    if (element && !sameType) {\\n      newFiber = {\\n        type: element.type,\\n        props: element.props,\\n        dom: null,\\n        parent: wipFiber,\\n        alternate: null,\\n        effectTag: \\\"PLACEMENT\\\",\\n      }\\n    }\\n    if (oldFiber && !sameType) {\\n      oldFiber.effectTag = \\\"DELETION\\\"\\n      deletions.push(oldFiber)\\n    }\\n\\n    if (oldFiber) {\\n      oldFiber = oldFiber.sibling\\n    }\\n\\n    if (index === 0) {\\n      wipFiber.child = newFiber\\n    } else if (element) {\\n      prevSibling.sibling = newFiber\\n    }\\n\\n    prevSibling = newFiber\\n    index++\\n  }\\n}\\n\\nconst Didact = {\\n  createElement,\\n  render,\\n}\\n\\n/** @jsx Didact.createElement */\\nconst element = (\\n  <div id=\\\"foo\\\">\\n    <a>bar</a>\\n    <b />\\n  </div>\\n)\\nconst container = document.getElementById(\\\"root\\\")\\nDidact.render(element, container)\\n\")), mdx(\"p\", null, \"\\uB530\\uB77C\\uC11C \\uC81C\\uAC70\\uD558\\uACE0 \\uC2F6\\uC740 \\uB178\\uB4DC\\uB97C \\uCD94\\uC801\\uD558\\uAE30 \\uC704\\uD55C \\uBC30\\uC5F4(deletions)\\uC774 \\uD544\\uC694\\uD569\\uB2C8\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./29.jsx 41,42,46\",\n    \"file\": \"./29.jsx\",\n    \"41,42,46\": true\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children: children.map(child =>\\n        typeof child === \\\"object\\\"\\n          ? child\\n          : createTextElement(child)\\n      ),\\n    },\\n  }\\n}\\n\\nfunction createTextElement(text) {\\n  return {\\n    type: \\\"TEXT_ELEMENT\\\",\\n    props: {\\n      nodeValue: text,\\n      children: [],\\n    },\\n  }\\n}\\n\\nfunction createDom(fiber) {\\n  const dom =\\n    fiber.type == \\\"TEXT_ELEMENT\\\"\\n      ? document.createTextNode(\\\"\\\")\\n      : document.createElement(fiber.type)\\n\\n  const isProperty = key => key !== \\\"children\\\"\\n  Object.keys(fiber.props)\\n    .filter(isProperty)\\n    .forEach(name => {\\n      dom[name] = fiber.props[name]\\n    })\\n\\n  return dom\\n}\\n\\nfunction commitRoot() {\\n  deletions.forEach(commitWork)\\n  commitWork(wipRoot.child)\\n  currentRoot = wipRoot\\n  wipRoot = null\\n}\\n\\nfunction commitWork(fiber) {\\n  if (!fiber) {\\n    return\\n  }\\n  const domParent = fiber.parent.dom\\n  domParent.appendChild(fiber.dom)\\n  commitWork(fiber.child)\\n  commitWork(fiber.sibling)\\n}\\n\\nfunction render(element, container) {\\n  wipRoot = {\\n    dom: container,\\n    props: {\\n      children: [element],\\n    },\\n    alternate: currentRoot,\\n  }\\n  deletions = []\\n  nextUnitOfWork = wipRoot\\n}\\n\\nlet nextUnitOfWork = null\\nlet currentRoot = null\\nlet wipRoot = null\\nlet deletions = null\\n\\nfunction workLoop(deadline) {\\n  let shouldYield = false\\n  while (nextUnitOfWork && !shouldYield) {\\n    nextUnitOfWork = performUnitOfWork(\\n      nextUnitOfWork\\n    )\\n    shouldYield = deadline.timeRemaining() < 1\\n  }\\n\\n  if (!nextUnitOfWork && wipRoot) {\\n    commitRoot()\\n  }\\n\\n  requestIdleCallback(workLoop)\\n}\\n\\nrequestIdleCallback(workLoop)\\n\\nfunction performUnitOfWork(fiber) {\\n  if (!fiber.dom) {\\n    fiber.dom = createDom(fiber)\\n  }\\n\\n  const elements = fiber.props.children\\n  reconcileChildren(fiber, elements)\\n\\n  if (fiber.child) {\\n    return fiber.child\\n  }\\n  let nextFiber = fiber\\n  while (nextFiber) {\\n    if (nextFiber.sibling) {\\n      return nextFiber.sibling\\n    }\\n    nextFiber = nextFiber.parent\\n  }\\n}\\n\\nfunction reconcileChildren(wipFiber, elements) {\\n  let index = 0\\n  let oldFiber =\\n    wipFiber.alternate && wipFiber.alternate.child\\n  let prevSibling = null\\n\\n  while (\\n    index < elements.length ||\\n    oldFiber != null\\n  ) {\\n    const element = elements[index]\\n    let newFiber = null\\n\\n    const sameType =\\n      oldFiber &&\\n      element &&\\n      element.type == oldFiber.type\\n\\n    if (sameType) {\\n      newFiber = {\\n        type: oldFiber.type,\\n        props: element.props,\\n        dom: oldFiber.dom,\\n        parent: wipFiber,\\n        alternate: oldFiber,\\n        effectTag: \\\"UPDATE\\\",\\n      }\\n    }\\n    if (element && !sameType) {\\n      newFiber = {\\n        type: element.type,\\n        props: element.props,\\n        dom: null,\\n        parent: wipFiber,\\n        alternate: null,\\n        effectTag: \\\"PLACEMENT\\\",\\n      }\\n    }\\n    if (oldFiber && !sameType) {\\n      oldFiber.effectTag = \\\"DELETION\\\"\\n      deletions.push(oldFiber)\\n    }\\n\\n    if (oldFiber) {\\n      oldFiber = oldFiber.sibling\\n    }\\n\\n    if (index === 0) {\\n      wipFiber.child = newFiber\\n    } else if (element) {\\n      prevSibling.sibling = newFiber\\n    }\\n\\n    prevSibling = newFiber\\n    index++\\n  }\\n}\\n\\nconst Didact = {\\n  createElement,\\n  render,\\n}\\n\\n/** @jsx Didact.createElement */\\nconst element = (\\n  <div id=\\\"foo\\\">\\n    <a>bar</a>\\n    <b />\\n  </div>\\n)\\nconst container = document.getElementById(\\\"root\\\")\\nDidact.render(element, container)\\n\")), mdx(\"p\", null, \"\\uADF8\\uB7EC\\uBA74 DOM\\uC5D0 \\uBCC0\\uACBD\\uC0AC\\uD56D\\uC744 \\uCEE4\\uBC0B\\uD560 \\uB54C \\uC774 \\uBC30\\uC5F4\\uC5D0 \\uC788\\uB294 fiber\\uB97C \\uC0AC\\uC6A9\\uD560 \\uC218 \\uC788\\uC2B5\\uB2C8\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./29.jsx 48:56\",\n    \"file\": \"./29.jsx\",\n    \"48:56\": true\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children: children.map(child =>\\n        typeof child === \\\"object\\\"\\n          ? child\\n          : createTextElement(child)\\n      ),\\n    },\\n  }\\n}\\n\\nfunction createTextElement(text) {\\n  return {\\n    type: \\\"TEXT_ELEMENT\\\",\\n    props: {\\n      nodeValue: text,\\n      children: [],\\n    },\\n  }\\n}\\n\\nfunction createDom(fiber) {\\n  const dom =\\n    fiber.type == \\\"TEXT_ELEMENT\\\"\\n      ? document.createTextNode(\\\"\\\")\\n      : document.createElement(fiber.type)\\n\\n  const isProperty = key => key !== \\\"children\\\"\\n  Object.keys(fiber.props)\\n    .filter(isProperty)\\n    .forEach(name => {\\n      dom[name] = fiber.props[name]\\n    })\\n\\n  return dom\\n}\\n\\nfunction commitRoot() {\\n  deletions.forEach(commitWork)\\n  commitWork(wipRoot.child)\\n  currentRoot = wipRoot\\n  wipRoot = null\\n}\\n\\nfunction commitWork(fiber) {\\n  if (!fiber) {\\n    return\\n  }\\n  const domParent = fiber.parent.dom\\n  domParent.appendChild(fiber.dom)\\n  commitWork(fiber.child)\\n  commitWork(fiber.sibling)\\n}\\n\\nfunction render(element, container) {\\n  wipRoot = {\\n    dom: container,\\n    props: {\\n      children: [element],\\n    },\\n    alternate: currentRoot,\\n  }\\n  deletions = []\\n  nextUnitOfWork = wipRoot\\n}\\n\\nlet nextUnitOfWork = null\\nlet currentRoot = null\\nlet wipRoot = null\\nlet deletions = null\\n\\nfunction workLoop(deadline) {\\n  let shouldYield = false\\n  while (nextUnitOfWork && !shouldYield) {\\n    nextUnitOfWork = performUnitOfWork(\\n      nextUnitOfWork\\n    )\\n    shouldYield = deadline.timeRemaining() < 1\\n  }\\n\\n  if (!nextUnitOfWork && wipRoot) {\\n    commitRoot()\\n  }\\n\\n  requestIdleCallback(workLoop)\\n}\\n\\nrequestIdleCallback(workLoop)\\n\\nfunction performUnitOfWork(fiber) {\\n  if (!fiber.dom) {\\n    fiber.dom = createDom(fiber)\\n  }\\n\\n  const elements = fiber.props.children\\n  reconcileChildren(fiber, elements)\\n\\n  if (fiber.child) {\\n    return fiber.child\\n  }\\n  let nextFiber = fiber\\n  while (nextFiber) {\\n    if (nextFiber.sibling) {\\n      return nextFiber.sibling\\n    }\\n    nextFiber = nextFiber.parent\\n  }\\n}\\n\\nfunction reconcileChildren(wipFiber, elements) {\\n  let index = 0\\n  let oldFiber =\\n    wipFiber.alternate && wipFiber.alternate.child\\n  let prevSibling = null\\n\\n  while (\\n    index < elements.length ||\\n    oldFiber != null\\n  ) {\\n    const element = elements[index]\\n    let newFiber = null\\n\\n    const sameType =\\n      oldFiber &&\\n      element &&\\n      element.type == oldFiber.type\\n\\n    if (sameType) {\\n      newFiber = {\\n        type: oldFiber.type,\\n        props: element.props,\\n        dom: oldFiber.dom,\\n        parent: wipFiber,\\n        alternate: oldFiber,\\n        effectTag: \\\"UPDATE\\\",\\n      }\\n    }\\n    if (element && !sameType) {\\n      newFiber = {\\n        type: element.type,\\n        props: element.props,\\n        dom: null,\\n        parent: wipFiber,\\n        alternate: null,\\n        effectTag: \\\"PLACEMENT\\\",\\n      }\\n    }\\n    if (oldFiber && !sameType) {\\n      oldFiber.effectTag = \\\"DELETION\\\"\\n      deletions.push(oldFiber)\\n    }\\n\\n    if (oldFiber) {\\n      oldFiber = oldFiber.sibling\\n    }\\n\\n    if (index === 0) {\\n      wipFiber.child = newFiber\\n    } else if (element) {\\n      prevSibling.sibling = newFiber\\n    }\\n\\n    prevSibling = newFiber\\n    index++\\n  }\\n}\\n\\nconst Didact = {\\n  createElement,\\n  render,\\n}\\n\\n/** @jsx Didact.createElement */\\nconst element = (\\n  <div id=\\\"foo\\\">\\n    <a>bar</a>\\n    <b />\\n  </div>\\n)\\nconst container = document.getElementById(\\\"root\\\")\\nDidact.render(element, container)\\n\")), mdx(\"p\", null, \"\\uC774\\uC81C \\uC0C8\\uB85C\\uC6B4 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"effectTags\"), \"\\uB97C \\uCC98\\uB9AC\\uD558\\uAE30 \\uC704\\uD574 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"commitWork\"), \" \\uD568\\uC218\\uB97C \\uBCC0\\uACBD\\uD574 \\uBCF4\\uACA0\\uC2B5\\uB2C8\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./30.jsx\",\n    \"file\": \"./30.jsx\"\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children: children.map(child =>\\n        typeof child === \\\"object\\\"\\n          ? child\\n          : createTextElement(child)\\n      ),\\n    },\\n  }\\n}\\n\\nfunction createTextElement(text) {\\n  return {\\n    type: \\\"TEXT_ELEMENT\\\",\\n    props: {\\n      nodeValue: text,\\n      children: [],\\n    },\\n  }\\n}\\n\\nfunction createDom(fiber) {\\n  const dom =\\n    fiber.type == \\\"TEXT_ELEMENT\\\"\\n      ? document.createTextNode(\\\"\\\")\\n      : document.createElement(fiber.type)\\n\\n  const isProperty = key => key !== \\\"children\\\"\\n  Object.keys(fiber.props)\\n    .filter(isProperty)\\n    .forEach(name => {\\n      dom[name] = fiber.props[name]\\n    })\\n\\n  return dom\\n}\\n\\nfunction commitRoot() {\\n  deletions.forEach(commitWork)\\n  commitWork(wipRoot.child)\\n  currentRoot = wipRoot\\n  wipRoot = null\\n}\\n\\nfunction commitWork(fiber) {\\n  if (!fiber) {\\n    return\\n  }\\n  const domParent = fiber.parent.dom\\n  if (\\n    fiber.effectTag === \\\"PLACEMENT\\\" &&\\n    fiber.dom != null\\n  ) {\\n    domParent.appendChild(fiber.dom)\\n  }\\n\\n  commitWork(fiber.child)\\n  commitWork(fiber.sibling)\\n}\\n\\nfunction render(element, container) {\\n  wipRoot = {\\n    dom: container,\\n    props: {\\n      children: [element],\\n    },\\n    alternate: currentRoot,\\n  }\\n  deletions = []\\n  nextUnitOfWork = wipRoot\\n}\\n\\nlet nextUnitOfWork = null\\nlet currentRoot = null\\nlet wipRoot = null\\nlet deletions = null\\n\\nfunction workLoop(deadline) {\\n  let shouldYield = false\\n  while (nextUnitOfWork && !shouldYield) {\\n    nextUnitOfWork = performUnitOfWork(\\n      nextUnitOfWork\\n    )\\n    shouldYield = deadline.timeRemaining() < 1\\n  }\\n\\n  if (!nextUnitOfWork && wipRoot) {\\n    commitRoot()\\n  }\\n\\n  requestIdleCallback(workLoop)\\n}\\n\\nrequestIdleCallback(workLoop)\\n\\nfunction performUnitOfWork(fiber) {\\n  if (!fiber.dom) {\\n    fiber.dom = createDom(fiber)\\n  }\\n\\n  const elements = fiber.props.children\\n  reconcileChildren(fiber, elements)\\n\\n  if (fiber.child) {\\n    return fiber.child\\n  }\\n  let nextFiber = fiber\\n  while (nextFiber) {\\n    if (nextFiber.sibling) {\\n      return nextFiber.sibling\\n    }\\n    nextFiber = nextFiber.parent\\n  }\\n}\\n\\nfunction reconcileChildren(wipFiber, elements) {\\n  let index = 0\\n  let oldFiber =\\n    wipFiber.alternate && wipFiber.alternate.child\\n  let prevSibling = null\\n\\n  while (\\n    index < elements.length ||\\n    oldFiber != null\\n  ) {\\n    const element = elements[index]\\n    let newFiber = null\\n\\n    const sameType =\\n      oldFiber &&\\n      element &&\\n      element.type == oldFiber.type\\n\\n    if (sameType) {\\n      newFiber = {\\n        type: oldFiber.type,\\n        props: element.props,\\n        dom: oldFiber.dom,\\n        parent: wipFiber,\\n        alternate: oldFiber,\\n        effectTag: \\\"UPDATE\\\",\\n      }\\n    }\\n    if (element && !sameType) {\\n      newFiber = {\\n        type: element.type,\\n        props: element.props,\\n        dom: null,\\n        parent: wipFiber,\\n        alternate: null,\\n        effectTag: \\\"PLACEMENT\\\",\\n      }\\n    }\\n    if (oldFiber && !sameType) {\\n      oldFiber.effectTag = \\\"DELETION\\\"\\n      deletions.push(oldFiber)\\n    }\\n\\n    if (oldFiber) {\\n      oldFiber = oldFiber.sibling\\n    }\\n\\n    if (index === 0) {\\n      wipFiber.child = newFiber\\n    } else if (element) {\\n      prevSibling.sibling = newFiber\\n    }\\n\\n    prevSibling = newFiber\\n    index++\\n  }\\n}\\n\\nconst Didact = {\\n  createElement,\\n  render,\\n}\\n\\n/** @jsx Didact.createElement */\\nconst element = (\\n  <div id=\\\"foo\\\">\\n    <a>bar</a>\\n    <b />\\n  </div>\\n)\\nconst container = document.getElementById(\\\"root\\\")\\nDidact.render(element, container)\\n\")), mdx(\"p\", null, \"\\uB9CC\\uC57D fiber\\uAC00 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"PLACEMENT\"), \" \\uD0DC\\uADF8\\uB97C \\uAC00\\uC9C4\\uB2E4\\uBA74 \\uC774\\uC804\\uC5D0 \\uD588\\uB358 \\uAC83\\uACFC \\uB3D9\\uC77C\\uD558\\uAC8C \\uBD80\\uBAA8 fiber \\uB178\\uB4DC\\uC5D0 \\uC790\\uC2DD DOM \\uB178\\uB4DC\\uB97C \\uCD94\\uAC00\\uD569\\uB2C8\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./31.jsx\",\n    \"file\": \"./31.jsx\"\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children: children.map(child =>\\n        typeof child === \\\"object\\\"\\n          ? child\\n          : createTextElement(child)\\n      ),\\n    },\\n  }\\n}\\n\\nfunction createTextElement(text) {\\n  return {\\n    type: \\\"TEXT_ELEMENT\\\",\\n    props: {\\n      nodeValue: text,\\n      children: [],\\n    },\\n  }\\n}\\n\\nfunction createDom(fiber) {\\n  const dom =\\n    fiber.type == \\\"TEXT_ELEMENT\\\"\\n      ? document.createTextNode(\\\"\\\")\\n      : document.createElement(fiber.type)\\n\\n  const isProperty = key => key !== \\\"children\\\"\\n  Object.keys(fiber.props)\\n    .filter(isProperty)\\n    .forEach(name => {\\n      dom[name] = fiber.props[name]\\n    })\\n\\n  return dom\\n}\\n\\nfunction commitRoot() {\\n  deletions.forEach(commitWork)\\n  commitWork(wipRoot.child)\\n  currentRoot = wipRoot\\n  wipRoot = null\\n}\\n\\nfunction commitWork(fiber) {\\n  if (!fiber) {\\n    return\\n  }\\n  const domParent = fiber.parent.dom\\n  if (\\n    fiber.effectTag === \\\"PLACEMENT\\\" &&\\n    fiber.dom != null\\n  ) {\\n    domParent.appendChild(fiber.dom)\\n  } else if (fiber.effectTag === \\\"DELETION\\\") {\\n    domParent.removeChild(fiber.dom)\\n  }\\n\\n  commitWork(fiber.child)\\n  commitWork(fiber.sibling)\\n}\\n\\nfunction render(element, container) {\\n  wipRoot = {\\n    dom: container,\\n    props: {\\n      children: [element],\\n    },\\n    alternate: currentRoot,\\n  }\\n  deletions = []\\n  nextUnitOfWork = wipRoot\\n}\\n\\nlet nextUnitOfWork = null\\nlet currentRoot = null\\nlet wipRoot = null\\nlet deletions = null\\n\\nfunction workLoop(deadline) {\\n  let shouldYield = false\\n  while (nextUnitOfWork && !shouldYield) {\\n    nextUnitOfWork = performUnitOfWork(\\n      nextUnitOfWork\\n    )\\n    shouldYield = deadline.timeRemaining() < 1\\n  }\\n\\n  if (!nextUnitOfWork && wipRoot) {\\n    commitRoot()\\n  }\\n\\n  requestIdleCallback(workLoop)\\n}\\n\\nrequestIdleCallback(workLoop)\\n\\nfunction performUnitOfWork(fiber) {\\n  if (!fiber.dom) {\\n    fiber.dom = createDom(fiber)\\n  }\\n\\n  const elements = fiber.props.children\\n  reconcileChildren(fiber, elements)\\n\\n  if (fiber.child) {\\n    return fiber.child\\n  }\\n  let nextFiber = fiber\\n  while (nextFiber) {\\n    if (nextFiber.sibling) {\\n      return nextFiber.sibling\\n    }\\n    nextFiber = nextFiber.parent\\n  }\\n}\\n\\nfunction reconcileChildren(wipFiber, elements) {\\n  let index = 0\\n  let oldFiber =\\n    wipFiber.alternate && wipFiber.alternate.child\\n  let prevSibling = null\\n\\n  while (\\n    index < elements.length ||\\n    oldFiber != null\\n  ) {\\n    const element = elements[index]\\n    let newFiber = null\\n\\n    const sameType =\\n      oldFiber &&\\n      element &&\\n      element.type == oldFiber.type\\n\\n    if (sameType) {\\n      newFiber = {\\n        type: oldFiber.type,\\n        props: element.props,\\n        dom: oldFiber.dom,\\n        parent: wipFiber,\\n        alternate: oldFiber,\\n        effectTag: \\\"UPDATE\\\",\\n      }\\n    }\\n    if (element && !sameType) {\\n      newFiber = {\\n        type: element.type,\\n        props: element.props,\\n        dom: null,\\n        parent: wipFiber,\\n        alternate: null,\\n        effectTag: \\\"PLACEMENT\\\",\\n      }\\n    }\\n    if (oldFiber && !sameType) {\\n      oldFiber.effectTag = \\\"DELETION\\\"\\n      deletions.push(oldFiber)\\n    }\\n\\n    if (oldFiber) {\\n      oldFiber = oldFiber.sibling\\n    }\\n\\n    if (index === 0) {\\n      wipFiber.child = newFiber\\n    } else if (element) {\\n      prevSibling.sibling = newFiber\\n    }\\n\\n    prevSibling = newFiber\\n    index++\\n  }\\n}\\n\\nconst Didact = {\\n  createElement,\\n  render,\\n}\\n\\n/** @jsx Didact.createElement */\\nconst element = (\\n  <div id=\\\"foo\\\">\\n    <a>bar</a>\\n    <b />\\n  </div>\\n)\\nconst container = document.getElementById(\\\"root\\\")\\nDidact.render(element, container)\\n\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DELETION\"), \" \\uD0DC\\uADF8\\uB294 \\uBC18\\uB300\\uB85C \\uC790\\uC2DD\\uC744 \\uBD80\\uBAA8 DOM\\uC5D0\\uC11C \\uC81C\\uAC70\\uD569\\uB2C8\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./32.jsx\",\n    \"file\": \"./32.jsx\"\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children: children.map(child =>\\n        typeof child === \\\"object\\\"\\n          ? child\\n          : createTextElement(child)\\n      ),\\n    },\\n  }\\n}\\n\\nfunction createTextElement(text) {\\n  return {\\n    type: \\\"TEXT_ELEMENT\\\",\\n    props: {\\n      nodeValue: text,\\n      children: [],\\n    },\\n  }\\n}\\n\\nfunction createDom(fiber) {\\n  const dom =\\n    fiber.type == \\\"TEXT_ELEMENT\\\"\\n      ? document.createTextNode(\\\"\\\")\\n      : document.createElement(fiber.type)\\n\\n  const isProperty = key => key !== \\\"children\\\"\\n  Object.keys(fiber.props)\\n    .filter(isProperty)\\n    .forEach(name => {\\n      dom[name] = fiber.props[name]\\n    })\\n\\n  return dom\\n}\\n\\nfunction commitRoot() {\\n  deletions.forEach(commitWork)\\n  commitWork(wipRoot.child)\\n  currentRoot = wipRoot\\n  wipRoot = null\\n}\\n\\nfunction commitWork(fiber) {\\n  if (!fiber) {\\n    return\\n  }\\n  const domParent = fiber.parent.dom\\n  if (\\n    fiber.effectTag === \\\"PLACEMENT\\\" &&\\n    fiber.dom != null\\n  ) {\\n    domParent.appendChild(fiber.dom)\\n  } else if (\\n    fiber.effectTag === \\\"UPDATE\\\" &&\\n    fiber.dom != null\\n  ) {\\n    updateDom(\\n      fiber.dom,\\n      fiber.alternate.props,\\n      fiber.props\\n    )\\n  } else if (fiber.effectTag === \\\"DELETION\\\") {\\n    domParent.removeChild(fiber.dom)\\n  }\\n\\n  commitWork(fiber.child)\\n  commitWork(fiber.sibling)\\n}\\n\\nfunction render(element, container) {\\n  wipRoot = {\\n    dom: container,\\n    props: {\\n      children: [element],\\n    },\\n    alternate: currentRoot,\\n  }\\n  deletions = []\\n  nextUnitOfWork = wipRoot\\n}\\n\\nlet nextUnitOfWork = null\\nlet currentRoot = null\\nlet wipRoot = null\\nlet deletions = null\\n\\nfunction workLoop(deadline) {\\n  let shouldYield = false\\n  while (nextUnitOfWork && !shouldYield) {\\n    nextUnitOfWork = performUnitOfWork(\\n      nextUnitOfWork\\n    )\\n    shouldYield = deadline.timeRemaining() < 1\\n  }\\n\\n  if (!nextUnitOfWork && wipRoot) {\\n    commitRoot()\\n  }\\n\\n  requestIdleCallback(workLoop)\\n}\\n\\nrequestIdleCallback(workLoop)\\n\\nfunction performUnitOfWork(fiber) {\\n  if (!fiber.dom) {\\n    fiber.dom = createDom(fiber)\\n  }\\n\\n  const elements = fiber.props.children\\n  reconcileChildren(fiber, elements)\\n\\n  if (fiber.child) {\\n    return fiber.child\\n  }\\n  let nextFiber = fiber\\n  while (nextFiber) {\\n    if (nextFiber.sibling) {\\n      return nextFiber.sibling\\n    }\\n    nextFiber = nextFiber.parent\\n  }\\n}\\n\\nfunction reconcileChildren(wipFiber, elements) {\\n  let index = 0\\n  let oldFiber =\\n    wipFiber.alternate && wipFiber.alternate.child\\n  let prevSibling = null\\n\\n  while (\\n    index < elements.length ||\\n    oldFiber != null\\n  ) {\\n    const element = elements[index]\\n    let newFiber = null\\n\\n    const sameType =\\n      oldFiber &&\\n      element &&\\n      element.type == oldFiber.type\\n\\n    if (sameType) {\\n      newFiber = {\\n        type: oldFiber.type,\\n        props: element.props,\\n        dom: oldFiber.dom,\\n        parent: wipFiber,\\n        alternate: oldFiber,\\n        effectTag: \\\"UPDATE\\\",\\n      }\\n    }\\n    if (element && !sameType) {\\n      newFiber = {\\n        type: element.type,\\n        props: element.props,\\n        dom: null,\\n        parent: wipFiber,\\n        alternate: null,\\n        effectTag: \\\"PLACEMENT\\\",\\n      }\\n    }\\n    if (oldFiber && !sameType) {\\n      oldFiber.effectTag = \\\"DELETION\\\"\\n      deletions.push(oldFiber)\\n    }\\n\\n    if (oldFiber) {\\n      oldFiber = oldFiber.sibling\\n    }\\n\\n    if (index === 0) {\\n      wipFiber.child = newFiber\\n    } else if (element) {\\n      prevSibling.sibling = newFiber\\n    }\\n\\n    prevSibling = newFiber\\n    index++\\n  }\\n}\\n\\nconst Didact = {\\n  createElement,\\n  render,\\n}\\n\\n/** @jsx Didact.createElement */\\nconst element = (\\n  <div id=\\\"foo\\\">\\n    <a>bar</a>\\n    <b />\\n  </div>\\n)\\nconst container = document.getElementById(\\\"root\\\")\\nDidact.render(element, container)\\n\")), mdx(\"p\", null, \"\\uAC31\\uC2E0(\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UPDATE\"), \")\\uC758 \\uACBD\\uC6B0, \\uC774\\uBBF8 \\uC874\\uC7AC\\uD558\\uB294 DOM \\uB178\\uB4DC\\uB97C \\uBCC0\\uACBD\\uB41C props\\uB97C \\uC774\\uC6A9\\uD558\\uC5EC \\uAC31\\uC2E0\\uD569\\uB2C8\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./33.jsx\",\n    \"file\": \"./33.jsx\"\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children: children.map(child =>\\n        typeof child === \\\"object\\\"\\n          ? child\\n          : createTextElement(child)\\n      ),\\n    },\\n  }\\n}\\n\\nfunction createTextElement(text) {\\n  return {\\n    type: \\\"TEXT_ELEMENT\\\",\\n    props: {\\n      nodeValue: text,\\n      children: [],\\n    },\\n  }\\n}\\n\\nfunction createDom(fiber) {\\n  const dom =\\n    fiber.type == \\\"TEXT_ELEMENT\\\"\\n      ? document.createTextNode(\\\"\\\")\\n      : document.createElement(fiber.type)\\n\\n  const isProperty = key => key !== \\\"children\\\"\\n  Object.keys(fiber.props)\\n    .filter(isProperty)\\n    .forEach(name => {\\n      dom[name] = fiber.props[name]\\n    })\\n\\n  return dom\\n}\\n\\nfunction updateDom(dom, prevProps, nextProps) {\\n  // TODO\\n}\\n\\nfunction commitRoot() {\\n  deletions.forEach(commitWork)\\n  commitWork(wipRoot.child)\\n  currentRoot = wipRoot\\n  wipRoot = null\\n}\\n\\nfunction commitWork(fiber) {\\n  if (!fiber) {\\n    return\\n  }\\n  const domParent = fiber.parent.dom\\n  if (\\n    fiber.effectTag === \\\"PLACEMENT\\\" &&\\n    fiber.dom != null\\n  ) {\\n    domParent.appendChild(fiber.dom)\\n  } else if (\\n    fiber.effectTag === \\\"UPDATE\\\" &&\\n    fiber.dom != null\\n  ) {\\n    updateDom(\\n      fiber.dom,\\n      fiber.alternate.props,\\n      fiber.props\\n    )\\n  } else if (fiber.effectTag === \\\"DELETION\\\") {\\n    domParent.removeChild(fiber.dom)\\n  }\\n\\n  commitWork(fiber.child)\\n  commitWork(fiber.sibling)\\n}\\n\\nfunction render(element, container) {\\n  wipRoot = {\\n    dom: container,\\n    props: {\\n      children: [element],\\n    },\\n    alternate: currentRoot,\\n  }\\n  deletions = []\\n  nextUnitOfWork = wipRoot\\n}\\n\\nlet nextUnitOfWork = null\\nlet currentRoot = null\\nlet wipRoot = null\\nlet deletions = null\\n\\nfunction workLoop(deadline) {\\n  let shouldYield = false\\n  while (nextUnitOfWork && !shouldYield) {\\n    nextUnitOfWork = performUnitOfWork(\\n      nextUnitOfWork\\n    )\\n    shouldYield = deadline.timeRemaining() < 1\\n  }\\n\\n  if (!nextUnitOfWork && wipRoot) {\\n    commitRoot()\\n  }\\n\\n  requestIdleCallback(workLoop)\\n}\\n\\nrequestIdleCallback(workLoop)\\n\\nfunction performUnitOfWork(fiber) {\\n  if (!fiber.dom) {\\n    fiber.dom = createDom(fiber)\\n  }\\n\\n  const elements = fiber.props.children\\n  reconcileChildren(fiber, elements)\\n\\n  if (fiber.child) {\\n    return fiber.child\\n  }\\n  let nextFiber = fiber\\n  while (nextFiber) {\\n    if (nextFiber.sibling) {\\n      return nextFiber.sibling\\n    }\\n    nextFiber = nextFiber.parent\\n  }\\n}\\n\\nfunction reconcileChildren(wipFiber, elements) {\\n  let index = 0\\n  let oldFiber =\\n    wipFiber.alternate && wipFiber.alternate.child\\n  let prevSibling = null\\n\\n  while (\\n    index < elements.length ||\\n    oldFiber != null\\n  ) {\\n    const element = elements[index]\\n    let newFiber = null\\n\\n    const sameType =\\n      oldFiber &&\\n      element &&\\n      element.type == oldFiber.type\\n\\n    if (sameType) {\\n      newFiber = {\\n        type: oldFiber.type,\\n        props: element.props,\\n        dom: oldFiber.dom,\\n        parent: wipFiber,\\n        alternate: oldFiber,\\n        effectTag: \\\"UPDATE\\\",\\n      }\\n    }\\n    if (element && !sameType) {\\n      newFiber = {\\n        type: element.type,\\n        props: element.props,\\n        dom: null,\\n        parent: wipFiber,\\n        alternate: null,\\n        effectTag: \\\"PLACEMENT\\\",\\n      }\\n    }\\n    if (oldFiber && !sameType) {\\n      oldFiber.effectTag = \\\"DELETION\\\"\\n      deletions.push(oldFiber)\\n    }\\n\\n    if (oldFiber) {\\n      oldFiber = oldFiber.sibling\\n    }\\n\\n    if (index === 0) {\\n      wipFiber.child = newFiber\\n    } else if (element) {\\n      prevSibling.sibling = newFiber\\n    }\\n\\n    prevSibling = newFiber\\n    index++\\n  }\\n}\\n\\nconst Didact = {\\n  createElement,\\n  render,\\n}\\n\\n/** @jsx Didact.createElement */\\nconst element = (\\n  <div id=\\\"foo\\\">\\n    <a>bar</a>\\n    <b />\\n  </div>\\n)\\nconst container = document.getElementById(\\\"root\\\")\\nDidact.render(element, container)\\n\")), mdx(\"p\", null, \"\\uC774 \\uC791\\uC5C5\\uC740 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"updateDom\"), \" \\uC774\\uB77C\\uB294 \\uD568\\uC218\\uC5D0\\uC11C \\uC218\\uD589\\uD560 \\uAC83\\uC785\\uB2C8\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./34.jsx 36:56\",\n    \"file\": \"./34.jsx\",\n    \"36:56\": true\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children: children.map(child =>\\n        typeof child === \\\"object\\\"\\n          ? child\\n          : createTextElement(child)\\n      ),\\n    },\\n  }\\n}\\n\\nfunction createTextElement(text) {\\n  return {\\n    type: \\\"TEXT_ELEMENT\\\",\\n    props: {\\n      nodeValue: text,\\n      children: [],\\n    },\\n  }\\n}\\n\\nfunction createDom(fiber) {\\n  const dom =\\n    fiber.type == \\\"TEXT_ELEMENT\\\"\\n      ? document.createTextNode(\\\"\\\")\\n      : document.createElement(fiber.type)\\n\\n  updateDom(dom, {}, fiber.props)\\n\\n  return dom\\n}\\n\\nconst isProperty = key => key !== \\\"children\\\"\\nconst isNew = (prev, next) => key =>\\n  prev[key] !== next[key]\\nconst isGone = (prev, next) => key => !(key in next)\\nfunction updateDom(dom, prevProps, nextProps) {\\n  // Remove old properties\\n  Object.keys(prevProps)\\n    .filter(isProperty)\\n    .filter(isGone(prevProps, nextProps))\\n    .forEach(name => {\\n      dom[name] = \\\"\\\"\\n    })\\n\\n  // Set new or changed properties\\n  Object.keys(nextProps)\\n    .filter(isProperty)\\n    .filter(isNew(prevProps, nextProps))\\n    .forEach(name => {\\n      dom[name] = nextProps[name]\\n    })\\n}\\n\\nfunction commitRoot() {\\n  deletions.forEach(commitWork)\\n  commitWork(wipRoot.child)\\n  currentRoot = wipRoot\\n  wipRoot = null\\n}\\n\\nfunction commitWork(fiber) {\\n  if (!fiber) {\\n    return\\n  }\\n\\n  const domParent = fiber.parent.dom\\n  if (\\n    fiber.effectTag === \\\"PLACEMENT\\\" &&\\n    fiber.dom != null\\n  ) {\\n    domParent.appendChild(fiber.dom)\\n  } else if (\\n    fiber.effectTag === \\\"UPDATE\\\" &&\\n    fiber.dom != null\\n  ) {\\n    updateDom(\\n      fiber.dom,\\n      fiber.alternate.props,\\n      fiber.props\\n    )\\n  } else if (fiber.effectTag === \\\"DELETION\\\") {\\n    domParent.removeChild(fiber.dom)\\n  }\\n\\n  commitWork(fiber.child)\\n  commitWork(fiber.sibling)\\n}\\n\\nfunction render(element, container) {\\n  wipRoot = {\\n    dom: container,\\n    props: {\\n      children: [element],\\n    },\\n    alternate: currentRoot,\\n  }\\n  deletions = []\\n  nextUnitOfWork = wipRoot\\n}\\n\\nlet nextUnitOfWork = null\\nlet currentRoot = null\\nlet wipRoot = null\\nlet deletions = null\\n\\nfunction workLoop(deadline) {\\n  let shouldYield = false\\n  while (nextUnitOfWork && !shouldYield) {\\n    nextUnitOfWork = performUnitOfWork(\\n      nextUnitOfWork\\n    )\\n    shouldYield = deadline.timeRemaining() < 1\\n  }\\n\\n  if (!nextUnitOfWork && wipRoot) {\\n    commitRoot()\\n  }\\n\\n  requestIdleCallback(workLoop)\\n}\\n\\nrequestIdleCallback(workLoop)\\n\\nfunction performUnitOfWork(fiber) {\\n  if (!fiber.dom) {\\n    fiber.dom = createDom(fiber)\\n  }\\n\\n  const elements = fiber.props.children\\n  reconcileChildren(fiber, elements)\\n\\n  if (fiber.child) {\\n    return fiber.child\\n  }\\n  let nextFiber = fiber\\n  while (nextFiber) {\\n    if (nextFiber.sibling) {\\n      return nextFiber.sibling\\n    }\\n    nextFiber = nextFiber.parent\\n  }\\n}\\n\\nfunction reconcileChildren(wipFiber, elements) {\\n  let index = 0\\n  let oldFiber =\\n    wipFiber.alternate && wipFiber.alternate.child\\n  let prevSibling = null\\n\\n  while (\\n    index < elements.length ||\\n    oldFiber != null\\n  ) {\\n    const element = elements[index]\\n    let newFiber = null\\n\\n    const sameType =\\n      oldFiber &&\\n      element &&\\n      element.type == oldFiber.type\\n\\n    if (sameType) {\\n      newFiber = {\\n        type: oldFiber.type,\\n        props: element.props,\\n        dom: oldFiber.dom,\\n        parent: wipFiber,\\n        alternate: oldFiber,\\n        effectTag: \\\"UPDATE\\\",\\n      }\\n    }\\n    if (element && !sameType) {\\n      newFiber = {\\n        type: element.type,\\n        props: element.props,\\n        dom: null,\\n        parent: wipFiber,\\n        alternate: null,\\n        effectTag: \\\"PLACEMENT\\\",\\n      }\\n    }\\n    if (oldFiber && !sameType) {\\n      oldFiber.effectTag = \\\"DELETION\\\"\\n      deletions.push(oldFiber)\\n    }\\n\\n    if (oldFiber) {\\n      oldFiber = oldFiber.sibling\\n    }\\n\\n    if (index === 0) {\\n      wipFiber.child = newFiber\\n    } else if (element) {\\n      prevSibling.sibling = newFiber\\n    }\\n\\n    prevSibling = newFiber\\n    index++\\n  }\\n}\\n\\nconst Didact = {\\n  createElement,\\n  render,\\n}\\n\\n/** @jsx Didact.createElement */\\nconst element = (\\n  <div id=\\\"foo\\\">\\n    <a>bar</a>\\n    <b />\\n  </div>\\n)\\nconst container = document.getElementById(\\\"root\\\")\\nDidact.render(element, container)\\n\")), mdx(\"p\", null, \"\\uC624\\uB798\\uB41C fiber\\uC758 props\\uB4E4\\uC744 \\uC0C8\\uB85C\\uC6B4 fiber\\uC758 props\\uC640 \\uBE44\\uAD50\\uD558\\uC5EC, \\uC0AC\\uB77C\\uC9C4 props\\uB294 \\uC81C\\uAC70\\uD558\\uACE0, \\uC0C8\\uB86D\\uAC70\\uB098 \\uBCC0\\uACBD\\uB41C props\\uB97C \\uC124\\uC815\\uD569\\uB2C8\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./35.jsx\",\n    \"file\": \"./35.jsx\"\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children: children.map(child =>\\n        typeof child === \\\"object\\\"\\n          ? child\\n          : createTextElement(child)\\n      ),\\n    },\\n  }\\n}\\n\\nfunction createTextElement(text) {\\n  return {\\n    type: \\\"TEXT_ELEMENT\\\",\\n    props: {\\n      nodeValue: text,\\n      children: [],\\n    },\\n  }\\n}\\n\\nfunction createDom(fiber) {\\n  const dom =\\n    fiber.type == \\\"TEXT_ELEMENT\\\"\\n      ? document.createTextNode(\\\"\\\")\\n      : document.createElement(fiber.type)\\n\\n  updateDom(dom, {}, fiber.props)\\n\\n  return dom\\n}\\n\\nconst isEvent = key => key.startsWith(\\\"on\\\")\\nconst isProperty = key =>\\n  key !== \\\"children\\\" && !isEvent(key)\\nconst isNew = (prev, next) => key =>\\n  prev[key] !== next[key]\\nconst isGone = (prev, next) => key => !(key in next)\\nfunction updateDom(dom, prevProps, nextProps) {\\n  // Remove old properties\\n  Object.keys(prevProps)\\n    .filter(isProperty)\\n    .filter(isGone(prevProps, nextProps))\\n    .forEach(name => {\\n      dom[name] = \\\"\\\"\\n    })\\n\\n  // Set new or changed properties\\n  Object.keys(nextProps)\\n    .filter(isProperty)\\n    .filter(isNew(prevProps, nextProps))\\n    .forEach(name => {\\n      dom[name] = nextProps[name]\\n    })\\n}\\n\\nfunction commitRoot() {\\n  deletions.forEach(commitWork)\\n  commitWork(wipRoot.child)\\n  currentRoot = wipRoot\\n  wipRoot = null\\n}\\n\\nfunction commitWork(fiber) {\\n  if (!fiber) {\\n    return\\n  }\\n\\n  const domParent = fiber.parent.dom\\n  if (\\n    fiber.effectTag === \\\"PLACEMENT\\\" &&\\n    fiber.dom != null\\n  ) {\\n    domParent.appendChild(fiber.dom)\\n  } else if (\\n    fiber.effectTag === \\\"UPDATE\\\" &&\\n    fiber.dom != null\\n  ) {\\n    updateDom(\\n      fiber.dom,\\n      fiber.alternate.props,\\n      fiber.props\\n    )\\n  } else if (fiber.effectTag === \\\"DELETION\\\") {\\n    domParent.removeChild(fiber.dom)\\n  }\\n\\n  commitWork(fiber.child)\\n  commitWork(fiber.sibling)\\n}\\n\\nfunction render(element, container) {\\n  wipRoot = {\\n    dom: container,\\n    props: {\\n      children: [element],\\n    },\\n    alternate: currentRoot,\\n  }\\n  deletions = []\\n  nextUnitOfWork = wipRoot\\n}\\n\\nlet nextUnitOfWork = null\\nlet currentRoot = null\\nlet wipRoot = null\\nlet deletions = null\\n\\nfunction workLoop(deadline) {\\n  let shouldYield = false\\n  while (nextUnitOfWork && !shouldYield) {\\n    nextUnitOfWork = performUnitOfWork(\\n      nextUnitOfWork\\n    )\\n    shouldYield = deadline.timeRemaining() < 1\\n  }\\n\\n  if (!nextUnitOfWork && wipRoot) {\\n    commitRoot()\\n  }\\n\\n  requestIdleCallback(workLoop)\\n}\\n\\nrequestIdleCallback(workLoop)\\n\\nfunction performUnitOfWork(fiber) {\\n  if (!fiber.dom) {\\n    fiber.dom = createDom(fiber)\\n  }\\n\\n  const elements = fiber.props.children\\n  reconcileChildren(fiber, elements)\\n\\n  if (fiber.child) {\\n    return fiber.child\\n  }\\n  let nextFiber = fiber\\n  while (nextFiber) {\\n    if (nextFiber.sibling) {\\n      return nextFiber.sibling\\n    }\\n    nextFiber = nextFiber.parent\\n  }\\n}\\n\\nfunction reconcileChildren(wipFiber, elements) {\\n  let index = 0\\n  let oldFiber =\\n    wipFiber.alternate && wipFiber.alternate.child\\n  let prevSibling = null\\n\\n  while (\\n    index < elements.length ||\\n    oldFiber != null\\n  ) {\\n    const element = elements[index]\\n    let newFiber = null\\n\\n    const sameType =\\n      oldFiber &&\\n      element &&\\n      element.type == oldFiber.type\\n\\n    if (sameType) {\\n      newFiber = {\\n        type: oldFiber.type,\\n        props: element.props,\\n        dom: oldFiber.dom,\\n        parent: wipFiber,\\n        alternate: oldFiber,\\n        effectTag: \\\"UPDATE\\\",\\n      }\\n    }\\n    if (element && !sameType) {\\n      newFiber = {\\n        type: element.type,\\n        props: element.props,\\n        dom: null,\\n        parent: wipFiber,\\n        alternate: null,\\n        effectTag: \\\"PLACEMENT\\\",\\n      }\\n    }\\n    if (oldFiber && !sameType) {\\n      oldFiber.effectTag = \\\"DELETION\\\"\\n      deletions.push(oldFiber)\\n    }\\n\\n    if (oldFiber) {\\n      oldFiber = oldFiber.sibling\\n    }\\n\\n    if (index === 0) {\\n      wipFiber.child = newFiber\\n    } else if (element) {\\n      prevSibling.sibling = newFiber\\n    }\\n\\n    prevSibling = newFiber\\n    index++\\n  }\\n}\\n\\nconst Didact = {\\n  createElement,\\n  render,\\n}\\n\\n/** @jsx Didact.createElement */\\nconst element = (\\n  <div id=\\\"foo\\\">\\n    <a>bar</a>\\n    <b />\\n  </div>\\n)\\nconst container = document.getElementById(\\\"root\\\")\\nDidact.render(element, container)\\n\")), mdx(\"p\", null, \"\\uAC31\\uC2E0\\uC744 \\uC704\\uD574 \\uC0AC\\uC6A9\\uD558\\uB294 \\uD2B9\\uBCC4\\uD55C \\uC885\\uB958\\uC758 \\uC18D\\uC131\\uC774 \\uC788\\uB294\\uB370 \\uBC14\\uB85C \\uC774\\uBCA4\\uD2B8 \\uB9AC\\uC2A4\\uB108\\uC785\\uB2C8\\uB2E4. \\uB530\\uB77C\\uC11C \\uB9CC\\uC57D \\uC18D\\uC131\\uC758 \\uC774\\uB984\\uC774 \\u201Con\\u201D \\uC774\\uB77C\\uB294 \\uC811\\uB450\\uC0AC\\uB85C \\uC2DC\\uC791\\uD55C\\uB2E4\\uBA74 \\uC774\\uB97C \\uB2E4\\uB974\\uAC8C \\uCC98\\uB9AC\\uD574\\uC918\\uC57C \\uD569\\uB2C8\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./36.jsx\",\n    \"file\": \"./36.jsx\"\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children: children.map(child =>\\n        typeof child === \\\"object\\\"\\n          ? child\\n          : createTextElement(child)\\n      ),\\n    },\\n  }\\n}\\n\\nfunction createTextElement(text) {\\n  return {\\n    type: \\\"TEXT_ELEMENT\\\",\\n    props: {\\n      nodeValue: text,\\n      children: [],\\n    },\\n  }\\n}\\n\\nfunction createDom(fiber) {\\n  const dom =\\n    fiber.type == \\\"TEXT_ELEMENT\\\"\\n      ? document.createTextNode(\\\"\\\")\\n      : document.createElement(fiber.type)\\n\\n  updateDom(dom, {}, fiber.props)\\n\\n  return dom\\n}\\n\\nconst isEvent = key => key.startsWith(\\\"on\\\")\\nconst isProperty = key =>\\n  key !== \\\"children\\\" && !isEvent(key)\\nconst isNew = (prev, next) => key =>\\n  prev[key] !== next[key]\\nconst isGone = (prev, next) => key => !(key in next)\\nfunction updateDom(dom, prevProps, nextProps) {\\n  //Remove old or changed event listeners\\n  Object.keys(prevProps)\\n    .filter(isEvent)\\n    .filter(\\n      key =>\\n        !(key in nextProps) ||\\n        isNew(prevProps, nextProps)(key)\\n    )\\n    .forEach(name => {\\n      const eventType = name\\n        .toLowerCase()\\n        .substring(2)\\n      dom.removeEventListener(\\n        eventType,\\n        prevProps[name]\\n      )\\n    })\\n\\n  // Remove old properties\\n  Object.keys(prevProps)\\n    .filter(isProperty)\\n    .filter(isGone(prevProps, nextProps))\\n    .forEach(name => {\\n      dom[name] = \\\"\\\"\\n    })\\n\\n  // Set new or changed properties\\n  Object.keys(nextProps)\\n    .filter(isProperty)\\n    .filter(isNew(prevProps, nextProps))\\n    .forEach(name => {\\n      dom[name] = nextProps[name]\\n    })\\n}\\n\\nfunction commitRoot() {\\n  deletions.forEach(commitWork)\\n  commitWork(wipRoot.child)\\n  currentRoot = wipRoot\\n  wipRoot = null\\n}\\n\\nfunction commitWork(fiber) {\\n  if (!fiber) {\\n    return\\n  }\\n\\n  const domParent = fiber.parent.dom\\n  if (\\n    fiber.effectTag === \\\"PLACEMENT\\\" &&\\n    fiber.dom != null\\n  ) {\\n    domParent.appendChild(fiber.dom)\\n  } else if (\\n    fiber.effectTag === \\\"UPDATE\\\" &&\\n    fiber.dom != null\\n  ) {\\n    updateDom(\\n      fiber.dom,\\n      fiber.alternate.props,\\n      fiber.props\\n    )\\n  } else if (fiber.effectTag === \\\"DELETION\\\") {\\n    domParent.removeChild(fiber.dom)\\n  }\\n\\n  commitWork(fiber.child)\\n  commitWork(fiber.sibling)\\n}\\n\\nfunction render(element, container) {\\n  wipRoot = {\\n    dom: container,\\n    props: {\\n      children: [element],\\n    },\\n    alternate: currentRoot,\\n  }\\n  deletions = []\\n  nextUnitOfWork = wipRoot\\n}\\n\\nlet nextUnitOfWork = null\\nlet currentRoot = null\\nlet wipRoot = null\\nlet deletions = null\\n\\nfunction workLoop(deadline) {\\n  let shouldYield = false\\n  while (nextUnitOfWork && !shouldYield) {\\n    nextUnitOfWork = performUnitOfWork(\\n      nextUnitOfWork\\n    )\\n    shouldYield = deadline.timeRemaining() < 1\\n  }\\n\\n  if (!nextUnitOfWork && wipRoot) {\\n    commitRoot()\\n  }\\n\\n  requestIdleCallback(workLoop)\\n}\\n\\nrequestIdleCallback(workLoop)\\n\\nfunction performUnitOfWork(fiber) {\\n  if (!fiber.dom) {\\n    fiber.dom = createDom(fiber)\\n  }\\n\\n  const elements = fiber.props.children\\n  reconcileChildren(fiber, elements)\\n\\n  if (fiber.child) {\\n    return fiber.child\\n  }\\n  let nextFiber = fiber\\n  while (nextFiber) {\\n    if (nextFiber.sibling) {\\n      return nextFiber.sibling\\n    }\\n    nextFiber = nextFiber.parent\\n  }\\n}\\n\\nfunction reconcileChildren(wipFiber, elements) {\\n  let index = 0\\n  let oldFiber =\\n    wipFiber.alternate && wipFiber.alternate.child\\n  let prevSibling = null\\n\\n  while (\\n    index < elements.length ||\\n    oldFiber != null\\n  ) {\\n    const element = elements[index]\\n    let newFiber = null\\n\\n    const sameType =\\n      oldFiber &&\\n      element &&\\n      element.type == oldFiber.type\\n\\n    if (sameType) {\\n      newFiber = {\\n        type: oldFiber.type,\\n        props: element.props,\\n        dom: oldFiber.dom,\\n        parent: wipFiber,\\n        alternate: oldFiber,\\n        effectTag: \\\"UPDATE\\\",\\n      }\\n    }\\n    if (element && !sameType) {\\n      newFiber = {\\n        type: element.type,\\n        props: element.props,\\n        dom: null,\\n        parent: wipFiber,\\n        alternate: null,\\n        effectTag: \\\"PLACEMENT\\\",\\n      }\\n    }\\n    if (oldFiber && !sameType) {\\n      oldFiber.effectTag = \\\"DELETION\\\"\\n      deletions.push(oldFiber)\\n    }\\n\\n    if (oldFiber) {\\n      oldFiber = oldFiber.sibling\\n    }\\n\\n    if (index === 0) {\\n      wipFiber.child = newFiber\\n    } else if (element) {\\n      prevSibling.sibling = newFiber\\n    }\\n\\n    prevSibling = newFiber\\n    index++\\n  }\\n}\\n\\nconst Didact = {\\n  createElement,\\n  render,\\n}\\n\\n/** @jsx Didact.createElement */\\nconst element = (\\n  <div id=\\\"foo\\\">\\n    <a>bar</a>\\n    <b />\\n  </div>\\n)\\nconst container = document.getElementById(\\\"root\\\")\\nDidact.render(element, container)\\n\")), mdx(\"p\", null, \"\\uB9CC\\uC57D \\uC774\\uBCA4\\uD2B8 \\uD578\\uB4E4\\uB7EC\\uAC00 \\uBC14\\uB010\\uB2E4\\uBA74, \\uC774\\uB97C \\uB178\\uD2B8\\uC5D0\\uC11C \\uC81C\\uAC70\\uD569\\uB2C8\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./37.jsx\",\n    \"file\": \"./37.jsx\"\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children: children.map(child =>\\n        typeof child === \\\"object\\\"\\n          ? child\\n          : createTextElement(child)\\n      ),\\n    },\\n  }\\n}\\n\\nfunction createTextElement(text) {\\n  return {\\n    type: \\\"TEXT_ELEMENT\\\",\\n    props: {\\n      nodeValue: text,\\n      children: [],\\n    },\\n  }\\n}\\n\\nfunction createDom(fiber) {\\n  const dom =\\n    fiber.type == \\\"TEXT_ELEMENT\\\"\\n      ? document.createTextNode(\\\"\\\")\\n      : document.createElement(fiber.type)\\n\\n  updateDom(dom, {}, fiber.props)\\n\\n  return dom\\n}\\n\\nconst isEvent = key => key.startsWith(\\\"on\\\")\\nconst isProperty = key =>\\n  key !== \\\"children\\\" && !isEvent(key)\\nconst isNew = (prev, next) => key =>\\n  prev[key] !== next[key]\\nconst isGone = (prev, next) => key => !(key in next)\\nfunction updateDom(dom, prevProps, nextProps) {\\n  //Remove old or changed event listeners\\n  Object.keys(prevProps)\\n    .filter(isEvent)\\n    .filter(\\n      key =>\\n        !(key in nextProps) ||\\n        isNew(prevProps, nextProps)(key)\\n    )\\n    .forEach(name => {\\n      const eventType = name\\n        .toLowerCase()\\n        .substring(2)\\n      dom.removeEventListener(\\n        eventType,\\n        prevProps[name]\\n      )\\n    })\\n\\n  // Remove old properties\\n  Object.keys(prevProps)\\n    .filter(isProperty)\\n    .filter(isGone(prevProps, nextProps))\\n    .forEach(name => {\\n      dom[name] = \\\"\\\"\\n    })\\n\\n  // Set new or changed properties\\n  Object.keys(nextProps)\\n    .filter(isProperty)\\n    .filter(isNew(prevProps, nextProps))\\n    .forEach(name => {\\n      dom[name] = nextProps[name]\\n    })\\n\\n  // Add event listeners\\n  Object.keys(nextProps)\\n    .filter(isEvent)\\n    .filter(isNew(prevProps, nextProps))\\n    .forEach(name => {\\n      const eventType = name\\n        .toLowerCase()\\n        .substring(2)\\n      dom.addEventListener(\\n        eventType,\\n        nextProps[name]\\n      )\\n    })\\n}\\n\\nfunction commitRoot() {\\n  deletions.forEach(commitWork)\\n  commitWork(wipRoot.child)\\n  currentRoot = wipRoot\\n  wipRoot = null\\n}\\n\\nfunction commitWork(fiber) {\\n  if (!fiber) {\\n    return\\n  }\\n\\n  const domParent = fiber.parent.dom\\n  if (\\n    fiber.effectTag === \\\"PLACEMENT\\\" &&\\n    fiber.dom != null\\n  ) {\\n    domParent.appendChild(fiber.dom)\\n  } else if (\\n    fiber.effectTag === \\\"UPDATE\\\" &&\\n    fiber.dom != null\\n  ) {\\n    updateDom(\\n      fiber.dom,\\n      fiber.alternate.props,\\n      fiber.props\\n    )\\n  } else if (fiber.effectTag === \\\"DELETION\\\") {\\n    domParent.removeChild(fiber.dom)\\n  }\\n\\n  commitWork(fiber.child)\\n  commitWork(fiber.sibling)\\n}\\n\\nfunction render(element, container) {\\n  wipRoot = {\\n    dom: container,\\n    props: {\\n      children: [element],\\n    },\\n    alternate: currentRoot,\\n  }\\n  deletions = []\\n  nextUnitOfWork = wipRoot\\n}\\n\\nlet nextUnitOfWork = null\\nlet currentRoot = null\\nlet wipRoot = null\\nlet deletions = null\\n\\nfunction workLoop(deadline) {\\n  let shouldYield = false\\n  while (nextUnitOfWork && !shouldYield) {\\n    nextUnitOfWork = performUnitOfWork(\\n      nextUnitOfWork\\n    )\\n    shouldYield = deadline.timeRemaining() < 1\\n  }\\n\\n  if (!nextUnitOfWork && wipRoot) {\\n    commitRoot()\\n  }\\n\\n  requestIdleCallback(workLoop)\\n}\\n\\nrequestIdleCallback(workLoop)\\n\\nfunction performUnitOfWork(fiber) {\\n  if (!fiber.dom) {\\n    fiber.dom = createDom(fiber)\\n  }\\n\\n  const elements = fiber.props.children\\n  reconcileChildren(fiber, elements)\\n\\n  if (fiber.child) {\\n    return fiber.child\\n  }\\n  let nextFiber = fiber\\n  while (nextFiber) {\\n    if (nextFiber.sibling) {\\n      return nextFiber.sibling\\n    }\\n    nextFiber = nextFiber.parent\\n  }\\n}\\n\\nfunction reconcileChildren(wipFiber, elements) {\\n  let index = 0\\n  let oldFiber =\\n    wipFiber.alternate && wipFiber.alternate.child\\n  let prevSibling = null\\n\\n  while (\\n    index < elements.length ||\\n    oldFiber != null\\n  ) {\\n    const element = elements[index]\\n    let newFiber = null\\n\\n    const sameType =\\n      oldFiber &&\\n      element &&\\n      element.type == oldFiber.type\\n\\n    if (sameType) {\\n      newFiber = {\\n        type: oldFiber.type,\\n        props: element.props,\\n        dom: oldFiber.dom,\\n        parent: wipFiber,\\n        alternate: oldFiber,\\n        effectTag: \\\"UPDATE\\\",\\n      }\\n    }\\n    if (element && !sameType) {\\n      newFiber = {\\n        type: element.type,\\n        props: element.props,\\n        dom: null,\\n        parent: wipFiber,\\n        alternate: null,\\n        effectTag: \\\"PLACEMENT\\\",\\n      }\\n    }\\n    if (oldFiber && !sameType) {\\n      oldFiber.effectTag = \\\"DELETION\\\"\\n      deletions.push(oldFiber)\\n    }\\n\\n    if (oldFiber) {\\n      oldFiber = oldFiber.sibling\\n    }\\n\\n    if (index === 0) {\\n      wipFiber.child = newFiber\\n    } else if (element) {\\n      prevSibling.sibling = newFiber\\n    }\\n\\n    prevSibling = newFiber\\n    index++\\n  }\\n}\\n\\nconst Didact = {\\n  createElement,\\n  render,\\n}\\n\\n/** @jsx Didact.createElement */\\nconst element = (\\n  <div id=\\\"foo\\\">\\n    <a>bar</a>\\n    <b />\\n  </div>\\n)\\nconst container = document.getElementById(\\\"root\\\")\\nDidact.render(element, container)\\n\")), mdx(\"p\", null, \"\\uADF8 \\uB2E4\\uC74C \\uC0C8\\uB85C\\uC6B4 \\uD578\\uB4E4\\uB7EC\\uB97C \\uCD94\\uAC00\\uD569\\uB2C8\\uB2E4.\")), mdx(\"p\", null, \"\\uC7AC\\uC870\\uC815\\uC774 \\uC801\\uC6A9\\uB41C \\uBC84\\uC804\\uC758 \\uCF54\\uB4DC\\uB97C \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://codesandbox.io/s/didact-6-96533\"\n  }), \"\\uC5EC\\uAE30\"), \"\\uC5D0\\uC11C \\uD655\\uC778\\uD560 \\uC218 \\uC788\\uC2B5\\uB2C8\\uB2E4.\"), mdx(CodeWave, {\n    mdxType: \"CodeWave\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./38.jsx 245:251\",\n    \"file\": \"./38.jsx\",\n    \"245:251\": true\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children: children.map(child =>\\n        typeof child === \\\"object\\\"\\n          ? child\\n          : createTextElement(child)\\n      ),\\n    },\\n  }\\n}\\n\\nfunction createTextElement(text) {\\n  return {\\n    type: \\\"TEXT_ELEMENT\\\",\\n    props: {\\n      nodeValue: text,\\n      children: [],\\n    },\\n  }\\n}\\n\\nfunction createDom(fiber) {\\n  const dom =\\n    fiber.type == \\\"TEXT_ELEMENT\\\"\\n      ? document.createTextNode(\\\"\\\")\\n      : document.createElement(fiber.type)\\n\\n  updateDom(dom, {}, fiber.props)\\n\\n  return dom\\n}\\n\\nconst isEvent = key => key.startsWith(\\\"on\\\")\\nconst isProperty = key =>\\n  key !== \\\"children\\\" && !isEvent(key)\\nconst isNew = (prev, next) => key =>\\n  prev[key] !== next[key]\\nconst isGone = (prev, next) => key => !(key in next)\\nfunction updateDom(dom, prevProps, nextProps) {\\n  //Remove old or changed event listeners\\n  Object.keys(prevProps)\\n    .filter(isEvent)\\n    .filter(\\n      key =>\\n        !(key in nextProps) ||\\n        isNew(prevProps, nextProps)(key)\\n    )\\n    .forEach(name => {\\n      const eventType = name\\n        .toLowerCase()\\n        .substring(2)\\n      dom.removeEventListener(\\n        eventType,\\n        prevProps[name]\\n      )\\n    })\\n\\n  // Remove old properties\\n  Object.keys(prevProps)\\n    .filter(isProperty)\\n    .filter(isGone(prevProps, nextProps))\\n    .forEach(name => {\\n      dom[name] = \\\"\\\"\\n    })\\n\\n  // Set new or changed properties\\n  Object.keys(nextProps)\\n    .filter(isProperty)\\n    .filter(isNew(prevProps, nextProps))\\n    .forEach(name => {\\n      dom[name] = nextProps[name]\\n    })\\n\\n  // Add event listeners\\n  Object.keys(nextProps)\\n    .filter(isEvent)\\n    .filter(isNew(prevProps, nextProps))\\n    .forEach(name => {\\n      const eventType = name\\n        .toLowerCase()\\n        .substring(2)\\n      dom.addEventListener(\\n        eventType,\\n        nextProps[name]\\n      )\\n    })\\n}\\n\\nfunction commitRoot() {\\n  deletions.forEach(commitWork)\\n  commitWork(wipRoot.child)\\n  currentRoot = wipRoot\\n  wipRoot = null\\n}\\n\\nfunction commitWork(fiber) {\\n  if (!fiber) {\\n    return\\n  }\\n\\n  const domParent = fiber.parent.dom\\n  if (\\n    fiber.effectTag === \\\"PLACEMENT\\\" &&\\n    fiber.dom != null\\n  ) {\\n    domParent.appendChild(fiber.dom)\\n  } else if (\\n    fiber.effectTag === \\\"UPDATE\\\" &&\\n    fiber.dom != null\\n  ) {\\n    updateDom(\\n      fiber.dom,\\n      fiber.alternate.props,\\n      fiber.props\\n    )\\n  } else if (fiber.effectTag === \\\"DELETION\\\") {\\n    domParent.removeChild(fiber.dom)\\n  }\\n\\n  commitWork(fiber.child)\\n  commitWork(fiber.sibling)\\n}\\n\\nfunction render(element, container) {\\n  wipRoot = {\\n    dom: container,\\n    props: {\\n      children: [element],\\n    },\\n    alternate: currentRoot,\\n  }\\n  deletions = []\\n  nextUnitOfWork = wipRoot\\n}\\n\\nlet nextUnitOfWork = null\\nlet currentRoot = null\\nlet wipRoot = null\\nlet deletions = null\\n\\nfunction workLoop(deadline) {\\n  let shouldYield = false\\n  while (nextUnitOfWork && !shouldYield) {\\n    nextUnitOfWork = performUnitOfWork(\\n      nextUnitOfWork\\n    )\\n    shouldYield = deadline.timeRemaining() < 1\\n  }\\n\\n  if (!nextUnitOfWork && wipRoot) {\\n    commitRoot()\\n  }\\n\\n  requestIdleCallback(workLoop)\\n}\\n\\nrequestIdleCallback(workLoop)\\n\\nfunction performUnitOfWork(fiber) {\\n  if (!fiber.dom) {\\n    fiber.dom = createDom(fiber)\\n  }\\n\\n  const elements = fiber.props.children\\n  reconcileChildren(fiber, elements)\\n\\n  if (fiber.child) {\\n    return fiber.child\\n  }\\n  let nextFiber = fiber\\n  while (nextFiber) {\\n    if (nextFiber.sibling) {\\n      return nextFiber.sibling\\n    }\\n    nextFiber = nextFiber.parent\\n  }\\n}\\n\\nfunction reconcileChildren(wipFiber, elements) {\\n  let index = 0\\n  let oldFiber =\\n    wipFiber.alternate && wipFiber.alternate.child\\n  let prevSibling = null\\n\\n  while (\\n    index < elements.length ||\\n    oldFiber != null\\n  ) {\\n    const element = elements[index]\\n    let newFiber = null\\n\\n    const sameType =\\n      oldFiber &&\\n      element &&\\n      element.type == oldFiber.type\\n\\n    if (sameType) {\\n      newFiber = {\\n        type: oldFiber.type,\\n        props: element.props,\\n        dom: oldFiber.dom,\\n        parent: wipFiber,\\n        alternate: oldFiber,\\n        effectTag: \\\"UPDATE\\\",\\n      }\\n    }\\n    if (element && !sameType) {\\n      newFiber = {\\n        type: element.type,\\n        props: element.props,\\n        dom: null,\\n        parent: wipFiber,\\n        alternate: null,\\n        effectTag: \\\"PLACEMENT\\\",\\n      }\\n    }\\n    if (oldFiber && !sameType) {\\n      oldFiber.effectTag = \\\"DELETION\\\"\\n      deletions.push(oldFiber)\\n    }\\n\\n    if (oldFiber) {\\n      oldFiber = oldFiber.sibling\\n    }\\n\\n    if (index === 0) {\\n      wipFiber.child = newFiber\\n    } else if (element) {\\n      prevSibling.sibling = newFiber\\n    }\\n\\n    prevSibling = newFiber\\n    index++\\n  }\\n}\\n\\nconst Didact = {\\n  createElement,\\n  render,\\n}\\n\\n/** @jsx Didact.createElement */\\nfunction App(props) {\\n  return <h1>Hi {props.name}</h1>\\n}\\nconst element = <App name=\\\"foo\\\" />\\nconst container = document.getElementById(\\\"root\\\")\\nDidact.render(element, container)\\n\")), mdx(\"h2\", {\n    \"id\": \"step-vii-함수형-컴포넌트-function-components\"\n  }, \"Step VII: \\uD568\\uC218\\uD615 \\uCEF4\\uD3EC\\uB10C\\uD2B8 (Function Components)\"), mdx(\"p\", null, \"\\uADF8 \\uB2E4\\uC74C \\uD574\\uC57C \\uD560 \\uAC83\\uC740 \\uD568\\uC218\\uD615 \\uCEF4\\uD3EC\\uB10C\\uD2B8 \\uC9C0\\uC6D0\\uC744 \\uCD94\\uAC00\\uD558\\uB294 \\uAC83\\uC785\\uB2C8\\uB2E4.\"), mdx(\"p\", null, \"\\uBA3C\\uC800 \\uC608\\uC81C\\uB97C \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"h1\"), \" \\uC5D8\\uB9AC\\uBA3C\\uD2B8\\uB97C \\uBC18\\uD658\\uD558\\uB294 \\uAC04\\uB2E8\\uD55C \\uD568\\uC218\\uD615 \\uCEF4\\uD3EC\\uB10C\\uD2B8\\uB97C \\uC0AC\\uC6A9\\uD558\\uB294 \\uAC83\\uC73C\\uB85C \\uBC14\\uAFD4\\uBCF4\\uACA0\\uC2B5\\uB2C8\\uB2E4.\"), mdx(\"p\", null, \"\\uB9CC\\uC57D JSX\\uB97C JS\\uB85C \\uBCC0\\uD658\\uD558\\uBA74 \\uB2E4\\uC74C\\uACFC \\uAC19\\uC2B5\\uB2C8\\uB2E4.\"), mdx(\"div\", null, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"function App(props) {\\n  return Didact.createElement(\\n    \\\"h1\\\",\\n    null,\\n    \\\"Hi \\\",\\n    props.name\\n  )\\n}\\nconst element = Didact.createElement(App, {\\n  name: \\\"foo\\\",\\n})\\n\"))), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./38.jsx 162:168\",\n    \"file\": \"./38.jsx\",\n    \"162:168\": true\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children: children.map(child =>\\n        typeof child === \\\"object\\\"\\n          ? child\\n          : createTextElement(child)\\n      ),\\n    },\\n  }\\n}\\n\\nfunction createTextElement(text) {\\n  return {\\n    type: \\\"TEXT_ELEMENT\\\",\\n    props: {\\n      nodeValue: text,\\n      children: [],\\n    },\\n  }\\n}\\n\\nfunction createDom(fiber) {\\n  const dom =\\n    fiber.type == \\\"TEXT_ELEMENT\\\"\\n      ? document.createTextNode(\\\"\\\")\\n      : document.createElement(fiber.type)\\n\\n  updateDom(dom, {}, fiber.props)\\n\\n  return dom\\n}\\n\\nconst isEvent = key => key.startsWith(\\\"on\\\")\\nconst isProperty = key =>\\n  key !== \\\"children\\\" && !isEvent(key)\\nconst isNew = (prev, next) => key =>\\n  prev[key] !== next[key]\\nconst isGone = (prev, next) => key => !(key in next)\\nfunction updateDom(dom, prevProps, nextProps) {\\n  //Remove old or changed event listeners\\n  Object.keys(prevProps)\\n    .filter(isEvent)\\n    .filter(\\n      key =>\\n        !(key in nextProps) ||\\n        isNew(prevProps, nextProps)(key)\\n    )\\n    .forEach(name => {\\n      const eventType = name\\n        .toLowerCase()\\n        .substring(2)\\n      dom.removeEventListener(\\n        eventType,\\n        prevProps[name]\\n      )\\n    })\\n\\n  // Remove old properties\\n  Object.keys(prevProps)\\n    .filter(isProperty)\\n    .filter(isGone(prevProps, nextProps))\\n    .forEach(name => {\\n      dom[name] = \\\"\\\"\\n    })\\n\\n  // Set new or changed properties\\n  Object.keys(nextProps)\\n    .filter(isProperty)\\n    .filter(isNew(prevProps, nextProps))\\n    .forEach(name => {\\n      dom[name] = nextProps[name]\\n    })\\n\\n  // Add event listeners\\n  Object.keys(nextProps)\\n    .filter(isEvent)\\n    .filter(isNew(prevProps, nextProps))\\n    .forEach(name => {\\n      const eventType = name\\n        .toLowerCase()\\n        .substring(2)\\n      dom.addEventListener(\\n        eventType,\\n        nextProps[name]\\n      )\\n    })\\n}\\n\\nfunction commitRoot() {\\n  deletions.forEach(commitWork)\\n  commitWork(wipRoot.child)\\n  currentRoot = wipRoot\\n  wipRoot = null\\n}\\n\\nfunction commitWork(fiber) {\\n  if (!fiber) {\\n    return\\n  }\\n\\n  const domParent = fiber.parent.dom\\n  if (\\n    fiber.effectTag === \\\"PLACEMENT\\\" &&\\n    fiber.dom != null\\n  ) {\\n    domParent.appendChild(fiber.dom)\\n  } else if (\\n    fiber.effectTag === \\\"UPDATE\\\" &&\\n    fiber.dom != null\\n  ) {\\n    updateDom(\\n      fiber.dom,\\n      fiber.alternate.props,\\n      fiber.props\\n    )\\n  } else if (fiber.effectTag === \\\"DELETION\\\") {\\n    domParent.removeChild(fiber.dom)\\n  }\\n\\n  commitWork(fiber.child)\\n  commitWork(fiber.sibling)\\n}\\n\\nfunction render(element, container) {\\n  wipRoot = {\\n    dom: container,\\n    props: {\\n      children: [element],\\n    },\\n    alternate: currentRoot,\\n  }\\n  deletions = []\\n  nextUnitOfWork = wipRoot\\n}\\n\\nlet nextUnitOfWork = null\\nlet currentRoot = null\\nlet wipRoot = null\\nlet deletions = null\\n\\nfunction workLoop(deadline) {\\n  let shouldYield = false\\n  while (nextUnitOfWork && !shouldYield) {\\n    nextUnitOfWork = performUnitOfWork(\\n      nextUnitOfWork\\n    )\\n    shouldYield = deadline.timeRemaining() < 1\\n  }\\n\\n  if (!nextUnitOfWork && wipRoot) {\\n    commitRoot()\\n  }\\n\\n  requestIdleCallback(workLoop)\\n}\\n\\nrequestIdleCallback(workLoop)\\n\\nfunction performUnitOfWork(fiber) {\\n  if (!fiber.dom) {\\n    fiber.dom = createDom(fiber)\\n  }\\n\\n  const elements = fiber.props.children\\n  reconcileChildren(fiber, elements)\\n\\n  if (fiber.child) {\\n    return fiber.child\\n  }\\n  let nextFiber = fiber\\n  while (nextFiber) {\\n    if (nextFiber.sibling) {\\n      return nextFiber.sibling\\n    }\\n    nextFiber = nextFiber.parent\\n  }\\n}\\n\\nfunction reconcileChildren(wipFiber, elements) {\\n  let index = 0\\n  let oldFiber =\\n    wipFiber.alternate && wipFiber.alternate.child\\n  let prevSibling = null\\n\\n  while (\\n    index < elements.length ||\\n    oldFiber != null\\n  ) {\\n    const element = elements[index]\\n    let newFiber = null\\n\\n    const sameType =\\n      oldFiber &&\\n      element &&\\n      element.type == oldFiber.type\\n\\n    if (sameType) {\\n      newFiber = {\\n        type: oldFiber.type,\\n        props: element.props,\\n        dom: oldFiber.dom,\\n        parent: wipFiber,\\n        alternate: oldFiber,\\n        effectTag: \\\"UPDATE\\\",\\n      }\\n    }\\n    if (element && !sameType) {\\n      newFiber = {\\n        type: element.type,\\n        props: element.props,\\n        dom: null,\\n        parent: wipFiber,\\n        alternate: null,\\n        effectTag: \\\"PLACEMENT\\\",\\n      }\\n    }\\n    if (oldFiber && !sameType) {\\n      oldFiber.effectTag = \\\"DELETION\\\"\\n      deletions.push(oldFiber)\\n    }\\n\\n    if (oldFiber) {\\n      oldFiber = oldFiber.sibling\\n    }\\n\\n    if (index === 0) {\\n      wipFiber.child = newFiber\\n    } else if (element) {\\n      prevSibling.sibling = newFiber\\n    }\\n\\n    prevSibling = newFiber\\n    index++\\n  }\\n}\\n\\nconst Didact = {\\n  createElement,\\n  render,\\n}\\n\\n/** @jsx Didact.createElement */\\nfunction App(props) {\\n  return <h1>Hi {props.name}</h1>\\n}\\nconst element = <App name=\\\"foo\\\" />\\nconst container = document.getElementById(\\\"root\\\")\\nDidact.render(element, container)\\n\")), mdx(\"p\", null, \"\\uD568\\uC218\\uD615 \\uCEF4\\uD3EC\\uB10C\\uD2B8\\uB294 \\uB2E4\\uC74C \\uB450 \\uAC00\\uC9C0 \\uBA74\\uC5D0\\uC11C \\uCC28\\uC774\\uAC00 \\uC788\\uC2B5\\uB2C8\\uB2E4.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\\uD568\\uC218\\uD615 \\uCEF4\\uD3EC\\uB10C\\uD2B8\\uC5D0\\uC11C \\uB9CC\\uB4E4\\uC5B4\\uC9C4 fiber\\uB294 DOM \\uB178\\uB4DC\\uAC00 \\uC5C6\\uC2B5\\uB2C8\\uB2E4.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\\uC790\\uC2DD\\uB4E4(\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"children\"), \")\\uC744 \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"props\"), \"\\uC5D0\\uC11C \\uC9C1\\uC811 \\uAC00\\uC838\\uC624\\uB294 \\uB300\\uC2E0 \\uD568\\uC218\\uB97C \\uC2E4\\uD589\\uD558\\uC5EC \\uC5BB\\uC2B5\\uB2C8\\uB2E4.\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./41.jsx\",\n    \"file\": \"./41.jsx\"\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children: children.map(child =>\\n        typeof child === \\\"object\\\"\\n          ? child\\n          : createTextElement(child)\\n      ),\\n    },\\n  }\\n}\\n\\nfunction createTextElement(text) {\\n  return {\\n    type: \\\"TEXT_ELEMENT\\\",\\n    props: {\\n      nodeValue: text,\\n      children: [],\\n    },\\n  }\\n}\\n\\nfunction createDom(fiber) {\\n  const dom =\\n    fiber.type == \\\"TEXT_ELEMENT\\\"\\n      ? document.createTextNode(\\\"\\\")\\n      : document.createElement(fiber.type)\\n\\n  updateDom(dom, {}, fiber.props)\\n\\n  return dom\\n}\\n\\nconst isEvent = key => key.startsWith(\\\"on\\\")\\nconst isProperty = key =>\\n  key !== \\\"children\\\" && !isEvent(key)\\nconst isNew = (prev, next) => key =>\\n  prev[key] !== next[key]\\nconst isGone = (prev, next) => key => !(key in next)\\nfunction updateDom(dom, prevProps, nextProps) {\\n  //Remove old or changed event listeners\\n  Object.keys(prevProps)\\n    .filter(isEvent)\\n    .filter(\\n      key =>\\n        !(key in nextProps) ||\\n        isNew(prevProps, nextProps)(key)\\n    )\\n    .forEach(name => {\\n      const eventType = name\\n        .toLowerCase()\\n        .substring(2)\\n      dom.removeEventListener(\\n        eventType,\\n        prevProps[name]\\n      )\\n    })\\n\\n  // Remove old properties\\n  Object.keys(prevProps)\\n    .filter(isProperty)\\n    .filter(isGone(prevProps, nextProps))\\n    .forEach(name => {\\n      dom[name] = \\\"\\\"\\n    })\\n\\n  // Set new or changed properties\\n  Object.keys(nextProps)\\n    .filter(isProperty)\\n    .filter(isNew(prevProps, nextProps))\\n    .forEach(name => {\\n      dom[name] = nextProps[name]\\n    })\\n\\n  // Add event listeners\\n  Object.keys(nextProps)\\n    .filter(isEvent)\\n    .filter(isNew(prevProps, nextProps))\\n    .forEach(name => {\\n      const eventType = name\\n        .toLowerCase()\\n        .substring(2)\\n      dom.addEventListener(\\n        eventType,\\n        nextProps[name]\\n      )\\n    })\\n}\\n\\nfunction commitRoot() {\\n  deletions.forEach(commitWork)\\n  commitWork(wipRoot.child)\\n  currentRoot = wipRoot\\n  wipRoot = null\\n}\\n\\nfunction commitWork(fiber) {\\n  if (!fiber) {\\n    return\\n  }\\n\\n  const domParent = fiber.parent.dom\\n  if (\\n    fiber.effectTag === \\\"PLACEMENT\\\" &&\\n    fiber.dom != null\\n  ) {\\n    domParent.appendChild(fiber.dom)\\n  } else if (\\n    fiber.effectTag === \\\"UPDATE\\\" &&\\n    fiber.dom != null\\n  ) {\\n    updateDom(\\n      fiber.dom,\\n      fiber.alternate.props,\\n      fiber.props\\n    )\\n  } else if (fiber.effectTag === \\\"DELETION\\\") {\\n    domParent.removeChild(fiber.dom)\\n  }\\n\\n  commitWork(fiber.child)\\n  commitWork(fiber.sibling)\\n}\\n\\nfunction render(element, container) {\\n  wipRoot = {\\n    dom: container,\\n    props: {\\n      children: [element],\\n    },\\n    alternate: currentRoot,\\n  }\\n  deletions = []\\n  nextUnitOfWork = wipRoot\\n}\\n\\nlet nextUnitOfWork = null\\nlet currentRoot = null\\nlet wipRoot = null\\nlet deletions = null\\n\\nfunction workLoop(deadline) {\\n  let shouldYield = false\\n  while (nextUnitOfWork && !shouldYield) {\\n    nextUnitOfWork = performUnitOfWork(\\n      nextUnitOfWork\\n    )\\n    shouldYield = deadline.timeRemaining() < 1\\n  }\\n\\n  if (!nextUnitOfWork && wipRoot) {\\n    commitRoot()\\n  }\\n\\n  requestIdleCallback(workLoop)\\n}\\n\\nrequestIdleCallback(workLoop)\\n\\nfunction performUnitOfWork(fiber) {\\n  const isFunctionComponent =\\n    fiber.type instanceof Function\\n  if (isFunctionComponent) {\\n    updateFunctionComponent(fiber)\\n  } else {\\n    updateHostComponent(fiber)\\n  }\\n  if (fiber.child) {\\n    return fiber.child\\n  }\\n  let nextFiber = fiber\\n  while (nextFiber) {\\n    if (nextFiber.sibling) {\\n      return nextFiber.sibling\\n    }\\n    nextFiber = nextFiber.parent\\n  }\\n}\\n\\nfunction updateFunctionComponent(fiber) {\\n  // TODO\\n}\\n\\nfunction updateHostComponent(fiber) {\\n  if (!fiber.dom) {\\n    fiber.dom = createDom(fiber)\\n  }\\n  reconcileChildren(fiber, fiber.props.children)\\n}\\n\\nfunction reconcileChildren(wipFiber, elements) {\\n  let index = 0\\n  let oldFiber =\\n    wipFiber.alternate && wipFiber.alternate.child\\n  let prevSibling = null\\n\\n  while (\\n    index < elements.length ||\\n    oldFiber != null\\n  ) {\\n    const element = elements[index]\\n    let newFiber = null\\n\\n    const sameType =\\n      oldFiber &&\\n      element &&\\n      element.type == oldFiber.type\\n\\n    if (sameType) {\\n      newFiber = {\\n        type: oldFiber.type,\\n        props: element.props,\\n        dom: oldFiber.dom,\\n        parent: wipFiber,\\n        alternate: oldFiber,\\n        effectTag: \\\"UPDATE\\\",\\n      }\\n    }\\n    if (element && !sameType) {\\n      newFiber = {\\n        type: element.type,\\n        props: element.props,\\n        dom: null,\\n        parent: wipFiber,\\n        alternate: null,\\n        effectTag: \\\"PLACEMENT\\\",\\n      }\\n    }\\n    if (oldFiber && !sameType) {\\n      oldFiber.effectTag = \\\"DELETION\\\"\\n      deletions.push(oldFiber)\\n    }\\n\\n    if (oldFiber) {\\n      oldFiber = oldFiber.sibling\\n    }\\n\\n    if (index === 0) {\\n      wipFiber.child = newFiber\\n    } else if (element) {\\n      prevSibling.sibling = newFiber\\n    }\\n\\n    prevSibling = newFiber\\n    index++\\n  }\\n}\\n\\nconst Didact = {\\n  createElement,\\n  render,\\n}\\n\\n/** @jsx Didact.createElement */\\nfunction App(props) {\\n  return <h1>Hi {props.name}</h1>\\n}\\nconst element = <App name=\\\"foo\\\" />\\nconst container = document.getElementById(\\\"root\\\")\\nDidact.render(element, container)\\n\")), mdx(\"p\", null, \"fiber \\uD0C0\\uC785\\uC774 \\uD568\\uC218\\uC778\\uC9C0 \\uCCB4\\uD06C\\uD55C \\uB2E4\\uC74C \\uADF8 \\uACB0\\uACFC\\uC5D0 \\uB530\\uB77C \\uB530\\uB77C \\uB2E4\\uC591\\uD55C \\uAC31\\uC2E0 \\uD568\\uC218\\uB85C \\uC774\\uB3D9\\uD569\\uB2C8\\uB2E4.\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"updateHostComponent\"), \" \\uC5D0\\uC11C\\uB294 \\uC774\\uC804\\uACFC \\uB3D9\\uC77C\\uD55C \\uC77C\\uC744 \\uD569\\uB2C8\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./42.jsx\",\n    \"file\": \"./42.jsx\"\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children: children.map(child =>\\n        typeof child === \\\"object\\\"\\n          ? child\\n          : createTextElement(child)\\n      ),\\n    },\\n  }\\n}\\n\\nfunction createTextElement(text) {\\n  return {\\n    type: \\\"TEXT_ELEMENT\\\",\\n    props: {\\n      nodeValue: text,\\n      children: [],\\n    },\\n  }\\n}\\n\\nfunction createDom(fiber) {\\n  const dom =\\n    fiber.type == \\\"TEXT_ELEMENT\\\"\\n      ? document.createTextNode(\\\"\\\")\\n      : document.createElement(fiber.type)\\n\\n  updateDom(dom, {}, fiber.props)\\n\\n  return dom\\n}\\n\\nconst isEvent = key => key.startsWith(\\\"on\\\")\\nconst isProperty = key =>\\n  key !== \\\"children\\\" && !isEvent(key)\\nconst isNew = (prev, next) => key =>\\n  prev[key] !== next[key]\\nconst isGone = (prev, next) => key => !(key in next)\\nfunction updateDom(dom, prevProps, nextProps) {\\n  //Remove old or changed event listeners\\n  Object.keys(prevProps)\\n    .filter(isEvent)\\n    .filter(\\n      key =>\\n        !(key in nextProps) ||\\n        isNew(prevProps, nextProps)(key)\\n    )\\n    .forEach(name => {\\n      const eventType = name\\n        .toLowerCase()\\n        .substring(2)\\n      dom.removeEventListener(\\n        eventType,\\n        prevProps[name]\\n      )\\n    })\\n\\n  // Remove old properties\\n  Object.keys(prevProps)\\n    .filter(isProperty)\\n    .filter(isGone(prevProps, nextProps))\\n    .forEach(name => {\\n      dom[name] = \\\"\\\"\\n    })\\n\\n  // Set new or changed properties\\n  Object.keys(nextProps)\\n    .filter(isProperty)\\n    .filter(isNew(prevProps, nextProps))\\n    .forEach(name => {\\n      dom[name] = nextProps[name]\\n    })\\n\\n  // Add event listeners\\n  Object.keys(nextProps)\\n    .filter(isEvent)\\n    .filter(isNew(prevProps, nextProps))\\n    .forEach(name => {\\n      const eventType = name\\n        .toLowerCase()\\n        .substring(2)\\n      dom.addEventListener(\\n        eventType,\\n        nextProps[name]\\n      )\\n    })\\n}\\n\\nfunction commitRoot() {\\n  deletions.forEach(commitWork)\\n  commitWork(wipRoot.child)\\n  currentRoot = wipRoot\\n  wipRoot = null\\n}\\n\\nfunction commitWork(fiber) {\\n  if (!fiber) {\\n    return\\n  }\\n\\n  const domParent = fiber.parent.dom\\n  if (\\n    fiber.effectTag === \\\"PLACEMENT\\\" &&\\n    fiber.dom != null\\n  ) {\\n    domParent.appendChild(fiber.dom)\\n  } else if (\\n    fiber.effectTag === \\\"UPDATE\\\" &&\\n    fiber.dom != null\\n  ) {\\n    updateDom(\\n      fiber.dom,\\n      fiber.alternate.props,\\n      fiber.props\\n    )\\n  } else if (fiber.effectTag === \\\"DELETION\\\") {\\n    domParent.removeChild(fiber.dom)\\n  }\\n\\n  commitWork(fiber.child)\\n  commitWork(fiber.sibling)\\n}\\n\\nfunction render(element, container) {\\n  wipRoot = {\\n    dom: container,\\n    props: {\\n      children: [element],\\n    },\\n    alternate: currentRoot,\\n  }\\n  deletions = []\\n  nextUnitOfWork = wipRoot\\n}\\n\\nlet nextUnitOfWork = null\\nlet currentRoot = null\\nlet wipRoot = null\\nlet deletions = null\\n\\nfunction workLoop(deadline) {\\n  let shouldYield = false\\n  while (nextUnitOfWork && !shouldYield) {\\n    nextUnitOfWork = performUnitOfWork(\\n      nextUnitOfWork\\n    )\\n    shouldYield = deadline.timeRemaining() < 1\\n  }\\n\\n  if (!nextUnitOfWork && wipRoot) {\\n    commitRoot()\\n  }\\n\\n  requestIdleCallback(workLoop)\\n}\\n\\nrequestIdleCallback(workLoop)\\n\\nfunction performUnitOfWork(fiber) {\\n  const isFunctionComponent =\\n    fiber.type instanceof Function\\n  if (isFunctionComponent) {\\n    updateFunctionComponent(fiber)\\n  } else {\\n    updateHostComponent(fiber)\\n  }\\n  if (fiber.child) {\\n    return fiber.child\\n  }\\n  let nextFiber = fiber\\n  while (nextFiber) {\\n    if (nextFiber.sibling) {\\n      return nextFiber.sibling\\n    }\\n    nextFiber = nextFiber.parent\\n  }\\n}\\n\\nfunction updateFunctionComponent(fiber) {\\n  const children = [fiber.type(fiber.props)]\\n  reconcileChildren(fiber, children)\\n}\\n\\nfunction updateHostComponent(fiber) {\\n  if (!fiber.dom) {\\n    fiber.dom = createDom(fiber)\\n  }\\n  reconcileChildren(fiber, fiber.props.children)\\n}\\n\\nfunction reconcileChildren(wipFiber, elements) {\\n  let index = 0\\n  let oldFiber =\\n    wipFiber.alternate && wipFiber.alternate.child\\n  let prevSibling = null\\n\\n  while (\\n    index < elements.length ||\\n    oldFiber != null\\n  ) {\\n    const element = elements[index]\\n    let newFiber = null\\n\\n    const sameType =\\n      oldFiber &&\\n      element &&\\n      element.type == oldFiber.type\\n\\n    if (sameType) {\\n      newFiber = {\\n        type: oldFiber.type,\\n        props: element.props,\\n        dom: oldFiber.dom,\\n        parent: wipFiber,\\n        alternate: oldFiber,\\n        effectTag: \\\"UPDATE\\\",\\n      }\\n    }\\n    if (element && !sameType) {\\n      newFiber = {\\n        type: element.type,\\n        props: element.props,\\n        dom: null,\\n        parent: wipFiber,\\n        alternate: null,\\n        effectTag: \\\"PLACEMENT\\\",\\n      }\\n    }\\n    if (oldFiber && !sameType) {\\n      oldFiber.effectTag = \\\"DELETION\\\"\\n      deletions.push(oldFiber)\\n    }\\n\\n    if (oldFiber) {\\n      oldFiber = oldFiber.sibling\\n    }\\n\\n    if (index === 0) {\\n      wipFiber.child = newFiber\\n    } else if (element) {\\n      prevSibling.sibling = newFiber\\n    }\\n\\n    prevSibling = newFiber\\n    index++\\n  }\\n}\\n\\nconst Didact = {\\n  createElement,\\n  render,\\n}\\n\\n/** @jsx Didact.createElement */\\nfunction App(props) {\\n  return <h1>Hi {props.name}</h1>\\n}\\nconst element = <App name=\\\"foo\\\" />\\nconst container = document.getElementById(\\\"root\\\")\\nDidact.render(element, container)\\n\")), mdx(\"p\", null, \"\\uADF8\\uB9AC\\uACE0 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"updateFunctionComponent\"), \" \\uC5D0\\uC11C\\uB294 \\uC790\\uC2DD \\uC694\\uC18C\\uB97C \\uC5BB\\uB294 \\uD568\\uC218\\uB97C \\uC2E4\\uD589\\uD569\\uB2C8\\uB2E4.\"), mdx(\"p\", null, \"\\uAC00\\uB839, \\uC5EC\\uAE30\\uC11C \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fiber.type\"), \"\\uC740 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"App\"), \" \\uD568\\uC218\\uC774\\uACE0, \\uC774\\uB97C \\uC2E4\\uD589\\uD558\\uBA74 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"h1\"), \" \\uC5D8\\uB9AC\\uBA3C\\uD2B8\\uB97C \\uBC18\\uD658\\uD569\\uB2C8\\uB2E4.\"), mdx(\"p\", null, \"\\uADF8 \\uB2E4\\uC74C \\uC790\\uC2DD\\uC744 \\uC5BB\\uAC8C \\uB418\\uBA74, \\uC7AC\\uC870\\uC815 \\uC791\\uC5C5\\uC740 \\uAC19\\uC740 \\uBC29\\uBC95\\uC73C\\uB85C \\uC218\\uD589\\uB418\\uBBC0\\uB85C \\uB354 \\uC774\\uC0C1 \\uCF54\\uB4DC\\uB97C \\uBC14\\uAFC0 \\uD544\\uC694\\uB294 \\uC5C6\\uC2B5\\uB2C8\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./42.jsx 99:125\",\n    \"file\": \"./42.jsx\",\n    \"99:125\": true\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children: children.map(child =>\\n        typeof child === \\\"object\\\"\\n          ? child\\n          : createTextElement(child)\\n      ),\\n    },\\n  }\\n}\\n\\nfunction createTextElement(text) {\\n  return {\\n    type: \\\"TEXT_ELEMENT\\\",\\n    props: {\\n      nodeValue: text,\\n      children: [],\\n    },\\n  }\\n}\\n\\nfunction createDom(fiber) {\\n  const dom =\\n    fiber.type == \\\"TEXT_ELEMENT\\\"\\n      ? document.createTextNode(\\\"\\\")\\n      : document.createElement(fiber.type)\\n\\n  updateDom(dom, {}, fiber.props)\\n\\n  return dom\\n}\\n\\nconst isEvent = key => key.startsWith(\\\"on\\\")\\nconst isProperty = key =>\\n  key !== \\\"children\\\" && !isEvent(key)\\nconst isNew = (prev, next) => key =>\\n  prev[key] !== next[key]\\nconst isGone = (prev, next) => key => !(key in next)\\nfunction updateDom(dom, prevProps, nextProps) {\\n  //Remove old or changed event listeners\\n  Object.keys(prevProps)\\n    .filter(isEvent)\\n    .filter(\\n      key =>\\n        !(key in nextProps) ||\\n        isNew(prevProps, nextProps)(key)\\n    )\\n    .forEach(name => {\\n      const eventType = name\\n        .toLowerCase()\\n        .substring(2)\\n      dom.removeEventListener(\\n        eventType,\\n        prevProps[name]\\n      )\\n    })\\n\\n  // Remove old properties\\n  Object.keys(prevProps)\\n    .filter(isProperty)\\n    .filter(isGone(prevProps, nextProps))\\n    .forEach(name => {\\n      dom[name] = \\\"\\\"\\n    })\\n\\n  // Set new or changed properties\\n  Object.keys(nextProps)\\n    .filter(isProperty)\\n    .filter(isNew(prevProps, nextProps))\\n    .forEach(name => {\\n      dom[name] = nextProps[name]\\n    })\\n\\n  // Add event listeners\\n  Object.keys(nextProps)\\n    .filter(isEvent)\\n    .filter(isNew(prevProps, nextProps))\\n    .forEach(name => {\\n      const eventType = name\\n        .toLowerCase()\\n        .substring(2)\\n      dom.addEventListener(\\n        eventType,\\n        nextProps[name]\\n      )\\n    })\\n}\\n\\nfunction commitRoot() {\\n  deletions.forEach(commitWork)\\n  commitWork(wipRoot.child)\\n  currentRoot = wipRoot\\n  wipRoot = null\\n}\\n\\nfunction commitWork(fiber) {\\n  if (!fiber) {\\n    return\\n  }\\n\\n  const domParent = fiber.parent.dom\\n  if (\\n    fiber.effectTag === \\\"PLACEMENT\\\" &&\\n    fiber.dom != null\\n  ) {\\n    domParent.appendChild(fiber.dom)\\n  } else if (\\n    fiber.effectTag === \\\"UPDATE\\\" &&\\n    fiber.dom != null\\n  ) {\\n    updateDom(\\n      fiber.dom,\\n      fiber.alternate.props,\\n      fiber.props\\n    )\\n  } else if (fiber.effectTag === \\\"DELETION\\\") {\\n    domParent.removeChild(fiber.dom)\\n  }\\n\\n  commitWork(fiber.child)\\n  commitWork(fiber.sibling)\\n}\\n\\nfunction render(element, container) {\\n  wipRoot = {\\n    dom: container,\\n    props: {\\n      children: [element],\\n    },\\n    alternate: currentRoot,\\n  }\\n  deletions = []\\n  nextUnitOfWork = wipRoot\\n}\\n\\nlet nextUnitOfWork = null\\nlet currentRoot = null\\nlet wipRoot = null\\nlet deletions = null\\n\\nfunction workLoop(deadline) {\\n  let shouldYield = false\\n  while (nextUnitOfWork && !shouldYield) {\\n    nextUnitOfWork = performUnitOfWork(\\n      nextUnitOfWork\\n    )\\n    shouldYield = deadline.timeRemaining() < 1\\n  }\\n\\n  if (!nextUnitOfWork && wipRoot) {\\n    commitRoot()\\n  }\\n\\n  requestIdleCallback(workLoop)\\n}\\n\\nrequestIdleCallback(workLoop)\\n\\nfunction performUnitOfWork(fiber) {\\n  const isFunctionComponent =\\n    fiber.type instanceof Function\\n  if (isFunctionComponent) {\\n    updateFunctionComponent(fiber)\\n  } else {\\n    updateHostComponent(fiber)\\n  }\\n  if (fiber.child) {\\n    return fiber.child\\n  }\\n  let nextFiber = fiber\\n  while (nextFiber) {\\n    if (nextFiber.sibling) {\\n      return nextFiber.sibling\\n    }\\n    nextFiber = nextFiber.parent\\n  }\\n}\\n\\nfunction updateFunctionComponent(fiber) {\\n  const children = [fiber.type(fiber.props)]\\n  reconcileChildren(fiber, children)\\n}\\n\\nfunction updateHostComponent(fiber) {\\n  if (!fiber.dom) {\\n    fiber.dom = createDom(fiber)\\n  }\\n  reconcileChildren(fiber, fiber.props.children)\\n}\\n\\nfunction reconcileChildren(wipFiber, elements) {\\n  let index = 0\\n  let oldFiber =\\n    wipFiber.alternate && wipFiber.alternate.child\\n  let prevSibling = null\\n\\n  while (\\n    index < elements.length ||\\n    oldFiber != null\\n  ) {\\n    const element = elements[index]\\n    let newFiber = null\\n\\n    const sameType =\\n      oldFiber &&\\n      element &&\\n      element.type == oldFiber.type\\n\\n    if (sameType) {\\n      newFiber = {\\n        type: oldFiber.type,\\n        props: element.props,\\n        dom: oldFiber.dom,\\n        parent: wipFiber,\\n        alternate: oldFiber,\\n        effectTag: \\\"UPDATE\\\",\\n      }\\n    }\\n    if (element && !sameType) {\\n      newFiber = {\\n        type: element.type,\\n        props: element.props,\\n        dom: null,\\n        parent: wipFiber,\\n        alternate: null,\\n        effectTag: \\\"PLACEMENT\\\",\\n      }\\n    }\\n    if (oldFiber && !sameType) {\\n      oldFiber.effectTag = \\\"DELETION\\\"\\n      deletions.push(oldFiber)\\n    }\\n\\n    if (oldFiber) {\\n      oldFiber = oldFiber.sibling\\n    }\\n\\n    if (index === 0) {\\n      wipFiber.child = newFiber\\n    } else if (element) {\\n      prevSibling.sibling = newFiber\\n    }\\n\\n    prevSibling = newFiber\\n    index++\\n  }\\n}\\n\\nconst Didact = {\\n  createElement,\\n  render,\\n}\\n\\n/** @jsx Didact.createElement */\\nfunction App(props) {\\n  return <h1>Hi {props.name}</h1>\\n}\\nconst element = <App name=\\\"foo\\\" />\\nconst container = document.getElementById(\\\"root\\\")\\nDidact.render(element, container)\\n\")), mdx(\"p\", null, \"\\uADF8 \\uB2E4\\uC74C \\uBCC0\\uACBD\\uC774 \\uD544\\uC694\\uD55C \\uAC83\\uC740 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"commitWork\"), \" \\uD568\\uC218\\uC785\\uB2C8\\uB2E4.\"), mdx(\"p\", null, \"\\uC9C0\\uAE08 \\uC6B0\\uB9AC\\uB294 DOM \\uB178\\uB4DC\\uAC00 \\uC5C6\\uB294 fiber\\uB97C \\uAC00\\uC9C0\\uACE0 \\uC788\\uAE30 \\uB54C\\uBB38\\uC5D0 \\uB450 \\uAC00\\uC9C0\\uB97C \\uBC14\\uAFD4\\uC57C \\uD569\\uB2C8\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./43.jsx 104:108,114\",\n    \"file\": \"./43.jsx\",\n    \"104:108,114\": true\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children: children.map(child =>\\n        typeof child === \\\"object\\\"\\n          ? child\\n          : createTextElement(child)\\n      ),\\n    },\\n  }\\n}\\n\\nfunction createTextElement(text) {\\n  return {\\n    type: \\\"TEXT_ELEMENT\\\",\\n    props: {\\n      nodeValue: text,\\n      children: [],\\n    },\\n  }\\n}\\n\\nfunction createDom(fiber) {\\n  const dom =\\n    fiber.type == \\\"TEXT_ELEMENT\\\"\\n      ? document.createTextNode(\\\"\\\")\\n      : document.createElement(fiber.type)\\n\\n  updateDom(dom, {}, fiber.props)\\n\\n  return dom\\n}\\n\\nconst isEvent = key => key.startsWith(\\\"on\\\")\\nconst isProperty = key =>\\n  key !== \\\"children\\\" && !isEvent(key)\\nconst isNew = (prev, next) => key =>\\n  prev[key] !== next[key]\\nconst isGone = (prev, next) => key => !(key in next)\\nfunction updateDom(dom, prevProps, nextProps) {\\n  //Remove old or changed event listeners\\n  Object.keys(prevProps)\\n    .filter(isEvent)\\n    .filter(\\n      key =>\\n        !(key in nextProps) ||\\n        isNew(prevProps, nextProps)(key)\\n    )\\n    .forEach(name => {\\n      const eventType = name\\n        .toLowerCase()\\n        .substring(2)\\n      dom.removeEventListener(\\n        eventType,\\n        prevProps[name]\\n      )\\n    })\\n\\n  // Remove old properties\\n  Object.keys(prevProps)\\n    .filter(isProperty)\\n    .filter(isGone(prevProps, nextProps))\\n    .forEach(name => {\\n      dom[name] = \\\"\\\"\\n    })\\n\\n  // Set new or changed properties\\n  Object.keys(nextProps)\\n    .filter(isProperty)\\n    .filter(isNew(prevProps, nextProps))\\n    .forEach(name => {\\n      dom[name] = nextProps[name]\\n    })\\n\\n  // Add event listeners\\n  Object.keys(nextProps)\\n    .filter(isEvent)\\n    .filter(isNew(prevProps, nextProps))\\n    .forEach(name => {\\n      const eventType = name\\n        .toLowerCase()\\n        .substring(2)\\n      dom.addEventListener(\\n        eventType,\\n        nextProps[name]\\n      )\\n    })\\n}\\n\\nfunction commitRoot() {\\n  deletions.forEach(commitWork)\\n  commitWork(wipRoot.child)\\n  currentRoot = wipRoot\\n  wipRoot = null\\n}\\n\\nfunction commitWork(fiber) {\\n  if (!fiber) {\\n    return\\n  }\\n\\n  let domParentFiber = fiber.parent\\n  while (!domParentFiber.dom) {\\n    domParentFiber = domParentFiber.parent\\n  }\\n  const domParent = domParentFiber.dom\\n\\n  if (\\n    fiber.effectTag === \\\"PLACEMENT\\\" &&\\n    fiber.dom != null\\n  ) {\\n    domParent.appendChild(fiber.dom)\\n  } else if (\\n    fiber.effectTag === \\\"UPDATE\\\" &&\\n    fiber.dom != null\\n  ) {\\n    updateDom(\\n      fiber.dom,\\n      fiber.alternate.props,\\n      fiber.props\\n    )\\n  } else if (fiber.effectTag === \\\"DELETION\\\") {\\n    domParent.removeChild(fiber.dom)\\n  }\\n\\n  commitWork(fiber.child)\\n  commitWork(fiber.sibling)\\n}\\n\\nfunction render(element, container) {\\n  wipRoot = {\\n    dom: container,\\n    props: {\\n      children: [element],\\n    },\\n    alternate: currentRoot,\\n  }\\n  deletions = []\\n  nextUnitOfWork = wipRoot\\n}\\n\\nlet nextUnitOfWork = null\\nlet currentRoot = null\\nlet wipRoot = null\\nlet deletions = null\\n\\nfunction workLoop(deadline) {\\n  let shouldYield = false\\n  while (nextUnitOfWork && !shouldYield) {\\n    nextUnitOfWork = performUnitOfWork(\\n      nextUnitOfWork\\n    )\\n    shouldYield = deadline.timeRemaining() < 1\\n  }\\n\\n  if (!nextUnitOfWork && wipRoot) {\\n    commitRoot()\\n  }\\n\\n  requestIdleCallback(workLoop)\\n}\\n\\nrequestIdleCallback(workLoop)\\n\\nfunction performUnitOfWork(fiber) {\\n  const isFunctionComponent =\\n    fiber.type instanceof Function\\n  if (isFunctionComponent) {\\n    updateFunctionComponent(fiber)\\n  } else {\\n    updateHostComponent(fiber)\\n  }\\n  if (fiber.child) {\\n    return fiber.child\\n  }\\n  let nextFiber = fiber\\n  while (nextFiber) {\\n    if (nextFiber.sibling) {\\n      return nextFiber.sibling\\n    }\\n    nextFiber = nextFiber.parent\\n  }\\n}\\n\\nfunction updateFunctionComponent(fiber) {\\n  const children = [fiber.type(fiber.props)]\\n  reconcileChildren(fiber, children)\\n}\\n\\nfunction updateHostComponent(fiber) {\\n  if (!fiber.dom) {\\n    fiber.dom = createDom(fiber)\\n  }\\n  reconcileChildren(fiber, fiber.props.children)\\n}\\n\\nfunction reconcileChildren(wipFiber, elements) {\\n  let index = 0\\n  let oldFiber =\\n    wipFiber.alternate && wipFiber.alternate.child\\n  let prevSibling = null\\n\\n  while (\\n    index < elements.length ||\\n    oldFiber != null\\n  ) {\\n    const element = elements[index]\\n    let newFiber = null\\n\\n    const sameType =\\n      oldFiber &&\\n      element &&\\n      element.type == oldFiber.type\\n\\n    if (sameType) {\\n      newFiber = {\\n        type: oldFiber.type,\\n        props: element.props,\\n        dom: oldFiber.dom,\\n        parent: wipFiber,\\n        alternate: oldFiber,\\n        effectTag: \\\"UPDATE\\\",\\n      }\\n    }\\n    if (element && !sameType) {\\n      newFiber = {\\n        type: element.type,\\n        props: element.props,\\n        dom: null,\\n        parent: wipFiber,\\n        alternate: null,\\n        effectTag: \\\"PLACEMENT\\\",\\n      }\\n    }\\n    if (oldFiber && !sameType) {\\n      oldFiber.effectTag = \\\"DELETION\\\"\\n      deletions.push(oldFiber)\\n    }\\n\\n    if (oldFiber) {\\n      oldFiber = oldFiber.sibling\\n    }\\n\\n    if (index === 0) {\\n      wipFiber.child = newFiber\\n    } else if (element) {\\n      prevSibling.sibling = newFiber\\n    }\\n\\n    prevSibling = newFiber\\n    index++\\n  }\\n}\\n\\nconst Didact = {\\n  createElement,\\n  render,\\n}\\n\\n/** @jsx Didact.createElement */\\nfunction App(props) {\\n  return <h1>Hi {props.name}</h1>\\n}\\nconst element = <App name=\\\"foo\\\" />\\nconst container = document.getElementById(\\\"root\\\")\\nDidact.render(element, container)\\n\")), mdx(\"p\", null, \"\\uBA3C\\uC800, DOM \\uB178\\uB4DC\\uC758 \\uBD80\\uBAA8\\uB97C \\uCC3E\\uC73C\\uB824\\uBA74 DOM \\uB178\\uB4DC\\uB97C \\uAC00\\uC9C4 fiber\\uB97C \\uCC3E\\uC744 \\uB54C\\uAE4C\\uC9C0 fiber \\uD2B8\\uB9AC\\uC758 \\uC0C1\\uB2E8\\uC73C\\uB85C \\uC62C\\uB77C\\uAC11\\uB2C8\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./44.jsx\",\n    \"file\": \"./44.jsx\"\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children: children.map(child =>\\n        typeof child === \\\"object\\\"\\n          ? child\\n          : createTextElement(child)\\n      ),\\n    },\\n  }\\n}\\n\\nfunction createTextElement(text) {\\n  return {\\n    type: \\\"TEXT_ELEMENT\\\",\\n    props: {\\n      nodeValue: text,\\n      children: [],\\n    },\\n  }\\n}\\n\\nfunction createDom(fiber) {\\n  const dom =\\n    fiber.type == \\\"TEXT_ELEMENT\\\"\\n      ? document.createTextNode(\\\"\\\")\\n      : document.createElement(fiber.type)\\n\\n  updateDom(dom, {}, fiber.props)\\n\\n  return dom\\n}\\n\\nconst isEvent = key => key.startsWith(\\\"on\\\")\\nconst isProperty = key =>\\n  key !== \\\"children\\\" && !isEvent(key)\\nconst isNew = (prev, next) => key =>\\n  prev[key] !== next[key]\\nconst isGone = (prev, next) => key => !(key in next)\\nfunction updateDom(dom, prevProps, nextProps) {\\n  //Remove old or changed event listeners\\n  Object.keys(prevProps)\\n    .filter(isEvent)\\n    .filter(\\n      key =>\\n        !(key in nextProps) ||\\n        isNew(prevProps, nextProps)(key)\\n    )\\n    .forEach(name => {\\n      const eventType = name\\n        .toLowerCase()\\n        .substring(2)\\n      dom.removeEventListener(\\n        eventType,\\n        prevProps[name]\\n      )\\n    })\\n\\n  // Remove old properties\\n  Object.keys(prevProps)\\n    .filter(isProperty)\\n    .filter(isGone(prevProps, nextProps))\\n    .forEach(name => {\\n      dom[name] = \\\"\\\"\\n    })\\n\\n  // Set new or changed properties\\n  Object.keys(nextProps)\\n    .filter(isProperty)\\n    .filter(isNew(prevProps, nextProps))\\n    .forEach(name => {\\n      dom[name] = nextProps[name]\\n    })\\n\\n  // Add event listeners\\n  Object.keys(nextProps)\\n    .filter(isEvent)\\n    .filter(isNew(prevProps, nextProps))\\n    .forEach(name => {\\n      const eventType = name\\n        .toLowerCase()\\n        .substring(2)\\n      dom.addEventListener(\\n        eventType,\\n        nextProps[name]\\n      )\\n    })\\n}\\n\\nfunction commitRoot() {\\n  deletions.forEach(commitWork)\\n  commitWork(wipRoot.child)\\n  currentRoot = wipRoot\\n  wipRoot = null\\n}\\n\\nfunction commitWork(fiber) {\\n  if (!fiber) {\\n    return\\n  }\\n\\n  let domParentFiber = fiber.parent\\n  while (!domParentFiber.dom) {\\n    domParentFiber = domParentFiber.parent\\n  }\\n  const domParent = domParentFiber.dom\\n\\n  if (\\n    fiber.effectTag === \\\"PLACEMENT\\\" &&\\n    fiber.dom != null\\n  ) {\\n    domParent.appendChild(fiber.dom)\\n  } else if (\\n    fiber.effectTag === \\\"UPDATE\\\" &&\\n    fiber.dom != null\\n  ) {\\n    updateDom(\\n      fiber.dom,\\n      fiber.alternate.props,\\n      fiber.props\\n    )\\n  } else if (fiber.effectTag === \\\"DELETION\\\") {\\n    commitDeletion(fiber, domParent)\\n  }\\n\\n  commitWork(fiber.child)\\n  commitWork(fiber.sibling)\\n}\\n\\nfunction commitDeletion(fiber, domParent) {\\n  if (fiber.dom) {\\n    domParent.removeChild(fiber.dom)\\n  } else {\\n    commitDeletion(fiber.child, domParent)\\n  }\\n}\\n\\nfunction render(element, container) {\\n  wipRoot = {\\n    dom: container,\\n    props: {\\n      children: [element],\\n    },\\n    alternate: currentRoot,\\n  }\\n  deletions = []\\n  nextUnitOfWork = wipRoot\\n}\\n\\nlet nextUnitOfWork = null\\nlet currentRoot = null\\nlet wipRoot = null\\nlet deletions = null\\n\\nfunction workLoop(deadline) {\\n  let shouldYield = false\\n  while (nextUnitOfWork && !shouldYield) {\\n    nextUnitOfWork = performUnitOfWork(\\n      nextUnitOfWork\\n    )\\n    shouldYield = deadline.timeRemaining() < 1\\n  }\\n\\n  if (!nextUnitOfWork && wipRoot) {\\n    commitRoot()\\n  }\\n\\n  requestIdleCallback(workLoop)\\n}\\n\\nrequestIdleCallback(workLoop)\\n\\nfunction performUnitOfWork(fiber) {\\n  const isFunctionComponent =\\n    fiber.type instanceof Function\\n  if (isFunctionComponent) {\\n    updateFunctionComponent(fiber)\\n  } else {\\n    updateHostComponent(fiber)\\n  }\\n  if (fiber.child) {\\n    return fiber.child\\n  }\\n  let nextFiber = fiber\\n  while (nextFiber) {\\n    if (nextFiber.sibling) {\\n      return nextFiber.sibling\\n    }\\n    nextFiber = nextFiber.parent\\n  }\\n}\\n\\nfunction updateFunctionComponent(fiber) {\\n  const children = [fiber.type(fiber.props)]\\n  reconcileChildren(fiber, children)\\n}\\n\\nfunction updateHostComponent(fiber) {\\n  if (!fiber.dom) {\\n    fiber.dom = createDom(fiber)\\n  }\\n  reconcileChildren(fiber, fiber.props.children)\\n}\\n\\nfunction reconcileChildren(wipFiber, elements) {\\n  let index = 0\\n  let oldFiber =\\n    wipFiber.alternate && wipFiber.alternate.child\\n  let prevSibling = null\\n\\n  while (\\n    index < elements.length ||\\n    oldFiber != null\\n  ) {\\n    const element = elements[index]\\n    let newFiber = null\\n\\n    const sameType =\\n      oldFiber &&\\n      element &&\\n      element.type == oldFiber.type\\n\\n    if (sameType) {\\n      newFiber = {\\n        type: oldFiber.type,\\n        props: element.props,\\n        dom: oldFiber.dom,\\n        parent: wipFiber,\\n        alternate: oldFiber,\\n        effectTag: \\\"UPDATE\\\",\\n      }\\n    }\\n    if (element && !sameType) {\\n      newFiber = {\\n        type: element.type,\\n        props: element.props,\\n        dom: null,\\n        parent: wipFiber,\\n        alternate: null,\\n        effectTag: \\\"PLACEMENT\\\",\\n      }\\n    }\\n    if (oldFiber && !sameType) {\\n      oldFiber.effectTag = \\\"DELETION\\\"\\n      deletions.push(oldFiber)\\n    }\\n\\n    if (oldFiber) {\\n      oldFiber = oldFiber.sibling\\n    }\\n\\n    if (index === 0) {\\n      wipFiber.child = newFiber\\n    } else if (element) {\\n      prevSibling.sibling = newFiber\\n    }\\n\\n    prevSibling = newFiber\\n    index++\\n  }\\n}\\n\\nconst Didact = {\\n  createElement,\\n  render,\\n}\\n\\n/** @jsx Didact.createElement */\\nfunction App(props) {\\n  return <h1>Hi {props.name}</h1>\\n}\\nconst element = <App name=\\\"foo\\\" />\\nconst container = document.getElementById(\\\"root\\\")\\nDidact.render(element, container)\\n\")), mdx(\"p\", null, \"\\uADF8\\uB9AC\\uACE0 \\uB178\\uB4DC\\uB97C \\uC81C\\uAC70\\uD560 \\uB54C\\uB3C4 \\uB3D9\\uC77C\\uD558\\uAC8C, DOM \\uB178\\uB4DC\\uB97C \\uAC00\\uC9C4 \\uC790\\uC2DD\\uC744 \\uCC3E\\uC744 \\uB54C\\uAE4C\\uC9C0 \\uD0D0\\uC0C9\\uC744 \\uC218\\uD589\\uD569\\uB2C8\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./44.jsx 270:276\",\n    \"file\": \"./44.jsx\",\n    \"270:276\": true\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children: children.map(child =>\\n        typeof child === \\\"object\\\"\\n          ? child\\n          : createTextElement(child)\\n      ),\\n    },\\n  }\\n}\\n\\nfunction createTextElement(text) {\\n  return {\\n    type: \\\"TEXT_ELEMENT\\\",\\n    props: {\\n      nodeValue: text,\\n      children: [],\\n    },\\n  }\\n}\\n\\nfunction createDom(fiber) {\\n  const dom =\\n    fiber.type == \\\"TEXT_ELEMENT\\\"\\n      ? document.createTextNode(\\\"\\\")\\n      : document.createElement(fiber.type)\\n\\n  updateDom(dom, {}, fiber.props)\\n\\n  return dom\\n}\\n\\nconst isEvent = key => key.startsWith(\\\"on\\\")\\nconst isProperty = key =>\\n  key !== \\\"children\\\" && !isEvent(key)\\nconst isNew = (prev, next) => key =>\\n  prev[key] !== next[key]\\nconst isGone = (prev, next) => key => !(key in next)\\nfunction updateDom(dom, prevProps, nextProps) {\\n  //Remove old or changed event listeners\\n  Object.keys(prevProps)\\n    .filter(isEvent)\\n    .filter(\\n      key =>\\n        !(key in nextProps) ||\\n        isNew(prevProps, nextProps)(key)\\n    )\\n    .forEach(name => {\\n      const eventType = name\\n        .toLowerCase()\\n        .substring(2)\\n      dom.removeEventListener(\\n        eventType,\\n        prevProps[name]\\n      )\\n    })\\n\\n  // Remove old properties\\n  Object.keys(prevProps)\\n    .filter(isProperty)\\n    .filter(isGone(prevProps, nextProps))\\n    .forEach(name => {\\n      dom[name] = \\\"\\\"\\n    })\\n\\n  // Set new or changed properties\\n  Object.keys(nextProps)\\n    .filter(isProperty)\\n    .filter(isNew(prevProps, nextProps))\\n    .forEach(name => {\\n      dom[name] = nextProps[name]\\n    })\\n\\n  // Add event listeners\\n  Object.keys(nextProps)\\n    .filter(isEvent)\\n    .filter(isNew(prevProps, nextProps))\\n    .forEach(name => {\\n      const eventType = name\\n        .toLowerCase()\\n        .substring(2)\\n      dom.addEventListener(\\n        eventType,\\n        nextProps[name]\\n      )\\n    })\\n}\\n\\nfunction commitRoot() {\\n  deletions.forEach(commitWork)\\n  commitWork(wipRoot.child)\\n  currentRoot = wipRoot\\n  wipRoot = null\\n}\\n\\nfunction commitWork(fiber) {\\n  if (!fiber) {\\n    return\\n  }\\n\\n  let domParentFiber = fiber.parent\\n  while (!domParentFiber.dom) {\\n    domParentFiber = domParentFiber.parent\\n  }\\n  const domParent = domParentFiber.dom\\n\\n  if (\\n    fiber.effectTag === \\\"PLACEMENT\\\" &&\\n    fiber.dom != null\\n  ) {\\n    domParent.appendChild(fiber.dom)\\n  } else if (\\n    fiber.effectTag === \\\"UPDATE\\\" &&\\n    fiber.dom != null\\n  ) {\\n    updateDom(\\n      fiber.dom,\\n      fiber.alternate.props,\\n      fiber.props\\n    )\\n  } else if (fiber.effectTag === \\\"DELETION\\\") {\\n    commitDeletion(fiber, domParent)\\n  }\\n\\n  commitWork(fiber.child)\\n  commitWork(fiber.sibling)\\n}\\n\\nfunction commitDeletion(fiber, domParent) {\\n  if (fiber.dom) {\\n    domParent.removeChild(fiber.dom)\\n  } else {\\n    commitDeletion(fiber.child, domParent)\\n  }\\n}\\n\\nfunction render(element, container) {\\n  wipRoot = {\\n    dom: container,\\n    props: {\\n      children: [element],\\n    },\\n    alternate: currentRoot,\\n  }\\n  deletions = []\\n  nextUnitOfWork = wipRoot\\n}\\n\\nlet nextUnitOfWork = null\\nlet currentRoot = null\\nlet wipRoot = null\\nlet deletions = null\\n\\nfunction workLoop(deadline) {\\n  let shouldYield = false\\n  while (nextUnitOfWork && !shouldYield) {\\n    nextUnitOfWork = performUnitOfWork(\\n      nextUnitOfWork\\n    )\\n    shouldYield = deadline.timeRemaining() < 1\\n  }\\n\\n  if (!nextUnitOfWork && wipRoot) {\\n    commitRoot()\\n  }\\n\\n  requestIdleCallback(workLoop)\\n}\\n\\nrequestIdleCallback(workLoop)\\n\\nfunction performUnitOfWork(fiber) {\\n  const isFunctionComponent =\\n    fiber.type instanceof Function\\n  if (isFunctionComponent) {\\n    updateFunctionComponent(fiber)\\n  } else {\\n    updateHostComponent(fiber)\\n  }\\n  if (fiber.child) {\\n    return fiber.child\\n  }\\n  let nextFiber = fiber\\n  while (nextFiber) {\\n    if (nextFiber.sibling) {\\n      return nextFiber.sibling\\n    }\\n    nextFiber = nextFiber.parent\\n  }\\n}\\n\\nfunction updateFunctionComponent(fiber) {\\n  const children = [fiber.type(fiber.props)]\\n  reconcileChildren(fiber, children)\\n}\\n\\nfunction updateHostComponent(fiber) {\\n  if (!fiber.dom) {\\n    fiber.dom = createDom(fiber)\\n  }\\n  reconcileChildren(fiber, fiber.props.children)\\n}\\n\\nfunction reconcileChildren(wipFiber, elements) {\\n  let index = 0\\n  let oldFiber =\\n    wipFiber.alternate && wipFiber.alternate.child\\n  let prevSibling = null\\n\\n  while (\\n    index < elements.length ||\\n    oldFiber != null\\n  ) {\\n    const element = elements[index]\\n    let newFiber = null\\n\\n    const sameType =\\n      oldFiber &&\\n      element &&\\n      element.type == oldFiber.type\\n\\n    if (sameType) {\\n      newFiber = {\\n        type: oldFiber.type,\\n        props: element.props,\\n        dom: oldFiber.dom,\\n        parent: wipFiber,\\n        alternate: oldFiber,\\n        effectTag: \\\"UPDATE\\\",\\n      }\\n    }\\n    if (element && !sameType) {\\n      newFiber = {\\n        type: element.type,\\n        props: element.props,\\n        dom: null,\\n        parent: wipFiber,\\n        alternate: null,\\n        effectTag: \\\"PLACEMENT\\\",\\n      }\\n    }\\n    if (oldFiber && !sameType) {\\n      oldFiber.effectTag = \\\"DELETION\\\"\\n      deletions.push(oldFiber)\\n    }\\n\\n    if (oldFiber) {\\n      oldFiber = oldFiber.sibling\\n    }\\n\\n    if (index === 0) {\\n      wipFiber.child = newFiber\\n    } else if (element) {\\n      prevSibling.sibling = newFiber\\n    }\\n\\n    prevSibling = newFiber\\n    index++\\n  }\\n}\\n\\nconst Didact = {\\n  createElement,\\n  render,\\n}\\n\\n/** @jsx Didact.createElement */\\nfunction App(props) {\\n  return <h1>Hi {props.name}</h1>\\n}\\nconst element = <App name=\\\"foo\\\" />\\nconst container = document.getElementById(\\\"root\\\")\\nDidact.render(element, container)\\n\")), mdx(\"h2\", {\n    \"id\": \"step-viii-훅-hooks\"\n  }, \"Step VIII: \\uD6C5 (Hooks)\"), mdx(\"p\", null, \"\\uB9C8\\uC9C0\\uB9C9 \\uB2E8\\uACC4\\uC785\\uB2C8\\uB2E4. \\uC774\\uC81C \\uD568\\uC218\\uD615 \\uCEF4\\uD3EC\\uB10C\\uD2B8\\uC5D0 \\uC0C1\\uD0DC\\uB97C \\uCD94\\uAC00\\uD574 \\uBD05\\uC2DC\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./45.jsx\",\n    \"file\": \"./45.jsx\"\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children: children.map(child =>\\n        typeof child === \\\"object\\\"\\n          ? child\\n          : createTextElement(child)\\n      ),\\n    },\\n  }\\n}\\n\\nfunction createTextElement(text) {\\n  return {\\n    type: \\\"TEXT_ELEMENT\\\",\\n    props: {\\n      nodeValue: text,\\n      children: [],\\n    },\\n  }\\n}\\n\\nfunction createDom(fiber) {\\n  const dom =\\n    fiber.type == \\\"TEXT_ELEMENT\\\"\\n      ? document.createTextNode(\\\"\\\")\\n      : document.createElement(fiber.type)\\n\\n  updateDom(dom, {}, fiber.props)\\n\\n  return dom\\n}\\n\\nconst isEvent = key => key.startsWith(\\\"on\\\")\\nconst isProperty = key =>\\n  key !== \\\"children\\\" && !isEvent(key)\\nconst isNew = (prev, next) => key =>\\n  prev[key] !== next[key]\\nconst isGone = (prev, next) => key => !(key in next)\\nfunction updateDom(dom, prevProps, nextProps) {\\n  //Remove old or changed event listeners\\n  Object.keys(prevProps)\\n    .filter(isEvent)\\n    .filter(\\n      key =>\\n        !(key in nextProps) ||\\n        isNew(prevProps, nextProps)(key)\\n    )\\n    .forEach(name => {\\n      const eventType = name\\n        .toLowerCase()\\n        .substring(2)\\n      dom.removeEventListener(\\n        eventType,\\n        prevProps[name]\\n      )\\n    })\\n\\n  // Remove old properties\\n  Object.keys(prevProps)\\n    .filter(isProperty)\\n    .filter(isGone(prevProps, nextProps))\\n    .forEach(name => {\\n      dom[name] = \\\"\\\"\\n    })\\n\\n  // Set new or changed properties\\n  Object.keys(nextProps)\\n    .filter(isProperty)\\n    .filter(isNew(prevProps, nextProps))\\n    .forEach(name => {\\n      dom[name] = nextProps[name]\\n    })\\n\\n  // Add event listeners\\n  Object.keys(nextProps)\\n    .filter(isEvent)\\n    .filter(isNew(prevProps, nextProps))\\n    .forEach(name => {\\n      const eventType = name\\n        .toLowerCase()\\n        .substring(2)\\n      dom.addEventListener(\\n        eventType,\\n        nextProps[name]\\n      )\\n    })\\n}\\n\\nfunction commitRoot() {\\n  deletions.forEach(commitWork)\\n  commitWork(wipRoot.child)\\n  currentRoot = wipRoot\\n  wipRoot = null\\n}\\n\\nfunction commitWork(fiber) {\\n  if (!fiber) {\\n    return\\n  }\\n\\n  let domParentFiber = fiber.parent\\n  while (!domParentFiber.dom) {\\n    domParentFiber = domParentFiber.parent\\n  }\\n  const domParent = domParentFiber.dom\\n\\n  if (\\n    fiber.effectTag === \\\"PLACEMENT\\\" &&\\n    fiber.dom != null\\n  ) {\\n    domParent.appendChild(fiber.dom)\\n  } else if (\\n    fiber.effectTag === \\\"UPDATE\\\" &&\\n    fiber.dom != null\\n  ) {\\n    updateDom(\\n      fiber.dom,\\n      fiber.alternate.props,\\n      fiber.props\\n    )\\n  } else if (fiber.effectTag === \\\"DELETION\\\") {\\n    commitDeletion(fiber, domParent)\\n  }\\n\\n  commitWork(fiber.child)\\n  commitWork(fiber.sibling)\\n}\\n\\nfunction commitDeletion(fiber, domParent) {\\n  if (fiber.dom) {\\n    domParent.removeChild(fiber.dom)\\n  } else {\\n    commitDeletion(fiber.child, domParent)\\n  }\\n}\\n\\nfunction render(element, container) {\\n  wipRoot = {\\n    dom: container,\\n    props: {\\n      children: [element],\\n    },\\n    alternate: currentRoot,\\n  }\\n  deletions = []\\n  nextUnitOfWork = wipRoot\\n}\\n\\nlet nextUnitOfWork = null\\nlet currentRoot = null\\nlet wipRoot = null\\nlet deletions = null\\n\\nfunction workLoop(deadline) {\\n  let shouldYield = false\\n  while (nextUnitOfWork && !shouldYield) {\\n    nextUnitOfWork = performUnitOfWork(\\n      nextUnitOfWork\\n    )\\n    shouldYield = deadline.timeRemaining() < 1\\n  }\\n\\n  if (!nextUnitOfWork && wipRoot) {\\n    commitRoot()\\n  }\\n\\n  requestIdleCallback(workLoop)\\n}\\n\\nrequestIdleCallback(workLoop)\\n\\nfunction performUnitOfWork(fiber) {\\n  const isFunctionComponent =\\n    fiber.type instanceof Function\\n  if (isFunctionComponent) {\\n    updateFunctionComponent(fiber)\\n  } else {\\n    updateHostComponent(fiber)\\n  }\\n  if (fiber.child) {\\n    return fiber.child\\n  }\\n  let nextFiber = fiber\\n  while (nextFiber) {\\n    if (nextFiber.sibling) {\\n      return nextFiber.sibling\\n    }\\n    nextFiber = nextFiber.parent\\n  }\\n}\\n\\nfunction updateFunctionComponent(fiber) {\\n  const children = [fiber.type(fiber.props)]\\n  reconcileChildren(fiber, children)\\n}\\n\\nfunction updateHostComponent(fiber) {\\n  if (!fiber.dom) {\\n    fiber.dom = createDom(fiber)\\n  }\\n  reconcileChildren(fiber, fiber.props.children)\\n}\\n\\nfunction reconcileChildren(wipFiber, elements) {\\n  let index = 0\\n  let oldFiber =\\n    wipFiber.alternate && wipFiber.alternate.child\\n  let prevSibling = null\\n\\n  while (\\n    index < elements.length ||\\n    oldFiber != null\\n  ) {\\n    const element = elements[index]\\n    let newFiber = null\\n\\n    const sameType =\\n      oldFiber &&\\n      element &&\\n      element.type == oldFiber.type\\n\\n    if (sameType) {\\n      newFiber = {\\n        type: oldFiber.type,\\n        props: element.props,\\n        dom: oldFiber.dom,\\n        parent: wipFiber,\\n        alternate: oldFiber,\\n        effectTag: \\\"UPDATE\\\",\\n      }\\n    }\\n    if (element && !sameType) {\\n      newFiber = {\\n        type: element.type,\\n        props: element.props,\\n        dom: null,\\n        parent: wipFiber,\\n        alternate: null,\\n        effectTag: \\\"PLACEMENT\\\",\\n      }\\n    }\\n    if (oldFiber && !sameType) {\\n      oldFiber.effectTag = \\\"DELETION\\\"\\n      deletions.push(oldFiber)\\n    }\\n\\n    if (oldFiber) {\\n      oldFiber = oldFiber.sibling\\n    }\\n\\n    if (index === 0) {\\n      wipFiber.child = newFiber\\n    } else if (element) {\\n      prevSibling.sibling = newFiber\\n    }\\n\\n    prevSibling = newFiber\\n    index++\\n  }\\n}\\n\\nconst Didact = {\\n  createElement,\\n  render,\\n  useState,\\n}\\n\\n/** @jsx Didact.createElement */\\nfunction Counter() {\\n  const [state, setState] = Didact.useState(1)\\n  return (\\n    <h1 onClick={() => setState(c => c + 1)}>\\n      Count: {state}\\n    </h1>\\n  )\\n}\\nconst element = <Counter />\\nconst container = document.getElementById(\\\"root\\\")\\nDidact.render(element, container)\\n\")), mdx(\"p\", null, \"\\uC608\\uC81C\\uB97C \\uACE0\\uC804\\uC801\\uC778 \\uCE74\\uC6B4\\uD130 \\uCEF4\\uD3EC\\uB10C\\uD2B8\\uB85C \\uBC14\\uAFD4 \\uBCF4\\uACA0\\uC2B5\\uB2C8\\uB2E4. \\uC6B0\\uB9AC\\uAC00 \\uCE74\\uC6B4\\uD130\\uB97C \\uD074\\uB9AD\\uD560 \\uB54C\\uB9C8\\uB2E4, state\\uB97C 1\\uC529 \\uCD94\\uAC00\\uD558\\uAC8C \\uB429\\uB2C8\\uB2E4.\"), mdx(\"p\", null, \"\\uC5EC\\uAE30\\uC11C \\uC6B0\\uB9AC\\uB294 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Didact.useState\"), \"\\uB97C \\uC0AC\\uC6A9\\uD574\\uC11C \\uCE74\\uC6B4\\uD130\\uC758 \\uAC12\\uC744 \\uC5BB\\uAC70\\uB098 \\uAC31\\uC2E0\\uD569\\uB2C8\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./46.jsx 195,196,198:202\",\n    \"file\": \"./46.jsx\",\n    \"195,196,198:202\": true\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children: children.map(child =>\\n        typeof child === \\\"object\\\"\\n          ? child\\n          : createTextElement(child)\\n      ),\\n    },\\n  }\\n}\\n\\nfunction createTextElement(text) {\\n  return {\\n    type: \\\"TEXT_ELEMENT\\\",\\n    props: {\\n      nodeValue: text,\\n      children: [],\\n    },\\n  }\\n}\\n\\nfunction createDom(fiber) {\\n  const dom =\\n    fiber.type == \\\"TEXT_ELEMENT\\\"\\n      ? document.createTextNode(\\\"\\\")\\n      : document.createElement(fiber.type)\\n\\n  updateDom(dom, {}, fiber.props)\\n\\n  return dom\\n}\\n\\nconst isEvent = key => key.startsWith(\\\"on\\\")\\nconst isProperty = key =>\\n  key !== \\\"children\\\" && !isEvent(key)\\nconst isNew = (prev, next) => key =>\\n  prev[key] !== next[key]\\nconst isGone = (prev, next) => key => !(key in next)\\nfunction updateDom(dom, prevProps, nextProps) {\\n  //Remove old or changed event listeners\\n  Object.keys(prevProps)\\n    .filter(isEvent)\\n    .filter(\\n      key =>\\n        !(key in nextProps) ||\\n        isNew(prevProps, nextProps)(key)\\n    )\\n    .forEach(name => {\\n      const eventType = name\\n        .toLowerCase()\\n        .substring(2)\\n      dom.removeEventListener(\\n        eventType,\\n        prevProps[name]\\n      )\\n    })\\n\\n  // Remove old properties\\n  Object.keys(prevProps)\\n    .filter(isProperty)\\n    .filter(isGone(prevProps, nextProps))\\n    .forEach(name => {\\n      dom[name] = \\\"\\\"\\n    })\\n\\n  // Set new or changed properties\\n  Object.keys(nextProps)\\n    .filter(isProperty)\\n    .filter(isNew(prevProps, nextProps))\\n    .forEach(name => {\\n      dom[name] = nextProps[name]\\n    })\\n\\n  // Add event listeners\\n  Object.keys(nextProps)\\n    .filter(isEvent)\\n    .filter(isNew(prevProps, nextProps))\\n    .forEach(name => {\\n      const eventType = name\\n        .toLowerCase()\\n        .substring(2)\\n      dom.addEventListener(\\n        eventType,\\n        nextProps[name]\\n      )\\n    })\\n}\\n\\nfunction commitRoot() {\\n  deletions.forEach(commitWork)\\n  commitWork(wipRoot.child)\\n  currentRoot = wipRoot\\n  wipRoot = null\\n}\\n\\nfunction commitWork(fiber) {\\n  if (!fiber) {\\n    return\\n  }\\n\\n  let domParentFiber = fiber.parent\\n  while (!domParentFiber.dom) {\\n    domParentFiber = domParentFiber.parent\\n  }\\n  const domParent = domParentFiber.dom\\n\\n  if (\\n    fiber.effectTag === \\\"PLACEMENT\\\" &&\\n    fiber.dom != null\\n  ) {\\n    domParent.appendChild(fiber.dom)\\n  } else if (\\n    fiber.effectTag === \\\"UPDATE\\\" &&\\n    fiber.dom != null\\n  ) {\\n    updateDom(\\n      fiber.dom,\\n      fiber.alternate.props,\\n      fiber.props\\n    )\\n  } else if (fiber.effectTag === \\\"DELETION\\\") {\\n    commitDeletion(fiber, domParent)\\n  }\\n\\n  commitWork(fiber.child)\\n  commitWork(fiber.sibling)\\n}\\n\\nfunction commitDeletion(fiber, domParent) {\\n  if (fiber.dom) {\\n    domParent.removeChild(fiber.dom)\\n  } else {\\n    commitDeletion(fiber.child, domParent)\\n  }\\n}\\n\\nfunction render(element, container) {\\n  wipRoot = {\\n    dom: container,\\n    props: {\\n      children: [element],\\n    },\\n    alternate: currentRoot,\\n  }\\n  deletions = []\\n  nextUnitOfWork = wipRoot\\n}\\n\\nlet nextUnitOfWork = null\\nlet currentRoot = null\\nlet wipRoot = null\\nlet deletions = null\\n\\nfunction workLoop(deadline) {\\n  let shouldYield = false\\n  while (nextUnitOfWork && !shouldYield) {\\n    nextUnitOfWork = performUnitOfWork(\\n      nextUnitOfWork\\n    )\\n    shouldYield = deadline.timeRemaining() < 1\\n  }\\n\\n  if (!nextUnitOfWork && wipRoot) {\\n    commitRoot()\\n  }\\n\\n  requestIdleCallback(workLoop)\\n}\\n\\nrequestIdleCallback(workLoop)\\n\\nfunction performUnitOfWork(fiber) {\\n  const isFunctionComponent =\\n    fiber.type instanceof Function\\n  if (isFunctionComponent) {\\n    updateFunctionComponent(fiber)\\n  } else {\\n    updateHostComponent(fiber)\\n  }\\n  if (fiber.child) {\\n    return fiber.child\\n  }\\n  let nextFiber = fiber\\n  while (nextFiber) {\\n    if (nextFiber.sibling) {\\n      return nextFiber.sibling\\n    }\\n    nextFiber = nextFiber.parent\\n  }\\n}\\n\\nfunction updateFunctionComponent(fiber) {\\n  const children = [fiber.type(fiber.props)]\\n  reconcileChildren(fiber, children)\\n}\\n\\nfunction useState(initial) {\\n  // TODO\\n}\\n\\nfunction updateHostComponent(fiber) {\\n  if (!fiber.dom) {\\n    fiber.dom = createDom(fiber)\\n  }\\n  reconcileChildren(fiber, fiber.props.children)\\n}\\n\\nfunction reconcileChildren(wipFiber, elements) {\\n  let index = 0\\n  let oldFiber =\\n    wipFiber.alternate && wipFiber.alternate.child\\n  let prevSibling = null\\n\\n  while (\\n    index < elements.length ||\\n    oldFiber != null\\n  ) {\\n    const element = elements[index]\\n    let newFiber = null\\n\\n    const sameType =\\n      oldFiber &&\\n      element &&\\n      element.type == oldFiber.type\\n\\n    if (sameType) {\\n      newFiber = {\\n        type: oldFiber.type,\\n        props: element.props,\\n        dom: oldFiber.dom,\\n        parent: wipFiber,\\n        alternate: oldFiber,\\n        effectTag: \\\"UPDATE\\\",\\n      }\\n    }\\n    if (element && !sameType) {\\n      newFiber = {\\n        type: element.type,\\n        props: element.props,\\n        dom: null,\\n        parent: wipFiber,\\n        alternate: null,\\n        effectTag: \\\"PLACEMENT\\\",\\n      }\\n    }\\n    if (oldFiber && !sameType) {\\n      oldFiber.effectTag = \\\"DELETION\\\"\\n      deletions.push(oldFiber)\\n    }\\n\\n    if (oldFiber) {\\n      oldFiber = oldFiber.sibling\\n    }\\n\\n    if (index === 0) {\\n      wipFiber.child = newFiber\\n    } else if (element) {\\n      prevSibling.sibling = newFiber\\n    }\\n\\n    prevSibling = newFiber\\n    index++\\n  }\\n}\\n\\nconst Didact = {\\n  createElement,\\n  render,\\n  useState,\\n}\\n\\n/** @jsx Didact.createElement */\\nfunction Counter() {\\n  const [state, setState] = Didact.useState(1)\\n  return (\\n    <h1 onClick={() => setState(c => c + 1)}>\\n      Count: {state}\\n    </h1>\\n  )\\n}\\nconst element = <Counter />\\nconst container = document.getElementById(\\\"root\\\")\\nDidact.render(element, container)\\n\")), mdx(\"p\", null, \"\\uC774\\uACF3\\uC774 \\uC608\\uC81C\\uC5D0\\uC11C \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Counter\"), \" \\uD568\\uC218\\uB97C \\uD638\\uCD9C\\uD558\\uB294 \\uBD80\\uBD84\\uC785\\uB2C8\\uB2E4. \\uADF8\\uB9AC\\uACE0 \\uADF8 \\uD568\\uC218 \\uB0B4\\uBD80\\uC5D0\\uC11C \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useState\"), \"\\uB97C \\uD638\\uCD9C\\uD569\\uB2C8\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./47.jsx 195:201,202[21:43],204\",\n    \"file\": \"./47.jsx\",\n    \"195:201,202[21:43],204\": true\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children: children.map(child =>\\n        typeof child === \\\"object\\\"\\n          ? child\\n          : createTextElement(child)\\n      ),\\n    },\\n  }\\n}\\n\\nfunction createTextElement(text) {\\n  return {\\n    type: \\\"TEXT_ELEMENT\\\",\\n    props: {\\n      nodeValue: text,\\n      children: [],\\n    },\\n  }\\n}\\n\\nfunction createDom(fiber) {\\n  const dom =\\n    fiber.type == \\\"TEXT_ELEMENT\\\"\\n      ? document.createTextNode(\\\"\\\")\\n      : document.createElement(fiber.type)\\n\\n  updateDom(dom, {}, fiber.props)\\n\\n  return dom\\n}\\n\\nconst isEvent = key => key.startsWith(\\\"on\\\")\\nconst isProperty = key =>\\n  key !== \\\"children\\\" && !isEvent(key)\\nconst isNew = (prev, next) => key =>\\n  prev[key] !== next[key]\\nconst isGone = (prev, next) => key => !(key in next)\\nfunction updateDom(dom, prevProps, nextProps) {\\n  //Remove old or changed event listeners\\n  Object.keys(prevProps)\\n    .filter(isEvent)\\n    .filter(\\n      key =>\\n        !(key in nextProps) ||\\n        isNew(prevProps, nextProps)(key)\\n    )\\n    .forEach(name => {\\n      const eventType = name\\n        .toLowerCase()\\n        .substring(2)\\n      dom.removeEventListener(\\n        eventType,\\n        prevProps[name]\\n      )\\n    })\\n\\n  // Remove old properties\\n  Object.keys(prevProps)\\n    .filter(isProperty)\\n    .filter(isGone(prevProps, nextProps))\\n    .forEach(name => {\\n      dom[name] = \\\"\\\"\\n    })\\n\\n  // Set new or changed properties\\n  Object.keys(nextProps)\\n    .filter(isProperty)\\n    .filter(isNew(prevProps, nextProps))\\n    .forEach(name => {\\n      dom[name] = nextProps[name]\\n    })\\n\\n  // Add event listeners\\n  Object.keys(nextProps)\\n    .filter(isEvent)\\n    .filter(isNew(prevProps, nextProps))\\n    .forEach(name => {\\n      const eventType = name\\n        .toLowerCase()\\n        .substring(2)\\n      dom.addEventListener(\\n        eventType,\\n        nextProps[name]\\n      )\\n    })\\n}\\n\\nfunction commitRoot() {\\n  deletions.forEach(commitWork)\\n  commitWork(wipRoot.child)\\n  currentRoot = wipRoot\\n  wipRoot = null\\n}\\n\\nfunction commitWork(fiber) {\\n  if (!fiber) {\\n    return\\n  }\\n\\n  let domParentFiber = fiber.parent\\n  while (!domParentFiber.dom) {\\n    domParentFiber = domParentFiber.parent\\n  }\\n  const domParent = domParentFiber.dom\\n\\n  if (\\n    fiber.effectTag === \\\"PLACEMENT\\\" &&\\n    fiber.dom != null\\n  ) {\\n    domParent.appendChild(fiber.dom)\\n  } else if (\\n    fiber.effectTag === \\\"UPDATE\\\" &&\\n    fiber.dom != null\\n  ) {\\n    updateDom(\\n      fiber.dom,\\n      fiber.alternate.props,\\n      fiber.props\\n    )\\n  } else if (fiber.effectTag === \\\"DELETION\\\") {\\n    commitDeletion(fiber, domParent)\\n  }\\n\\n  commitWork(fiber.child)\\n  commitWork(fiber.sibling)\\n}\\n\\nfunction commitDeletion(fiber, domParent) {\\n  if (fiber.dom) {\\n    domParent.removeChild(fiber.dom)\\n  } else {\\n    commitDeletion(fiber.child, domParent)\\n  }\\n}\\n\\nfunction render(element, container) {\\n  wipRoot = {\\n    dom: container,\\n    props: {\\n      children: [element],\\n    },\\n    alternate: currentRoot,\\n  }\\n  deletions = []\\n  nextUnitOfWork = wipRoot\\n}\\n\\nlet nextUnitOfWork = null\\nlet currentRoot = null\\nlet wipRoot = null\\nlet deletions = null\\n\\nfunction workLoop(deadline) {\\n  let shouldYield = false\\n  while (nextUnitOfWork && !shouldYield) {\\n    nextUnitOfWork = performUnitOfWork(\\n      nextUnitOfWork\\n    )\\n    shouldYield = deadline.timeRemaining() < 1\\n  }\\n\\n  if (!nextUnitOfWork && wipRoot) {\\n    commitRoot()\\n  }\\n\\n  requestIdleCallback(workLoop)\\n}\\n\\nrequestIdleCallback(workLoop)\\n\\nfunction performUnitOfWork(fiber) {\\n  const isFunctionComponent =\\n    fiber.type instanceof Function\\n  if (isFunctionComponent) {\\n    updateFunctionComponent(fiber)\\n  } else {\\n    updateHostComponent(fiber)\\n  }\\n  if (fiber.child) {\\n    return fiber.child\\n  }\\n  let nextFiber = fiber\\n  while (nextFiber) {\\n    if (nextFiber.sibling) {\\n      return nextFiber.sibling\\n    }\\n    nextFiber = nextFiber.parent\\n  }\\n}\\n\\nlet wipFiber = null\\nlet hookIndex = null\\n\\nfunction updateFunctionComponent(fiber) {\\n  wipFiber = fiber\\n  hookIndex = 0\\n  wipFiber.hooks = []\\n  const children = [fiber.type(fiber.props)]\\n  reconcileChildren(fiber, children)\\n}\\n\\nfunction useState(initial) {\\n  // TODO\\n}\\n\\nfunction updateHostComponent(fiber) {\\n  if (!fiber.dom) {\\n    fiber.dom = createDom(fiber)\\n  }\\n  reconcileChildren(fiber, fiber.props.children)\\n}\\n\\nfunction reconcileChildren(wipFiber, elements) {\\n  let index = 0\\n  let oldFiber =\\n    wipFiber.alternate && wipFiber.alternate.child\\n  let prevSibling = null\\n\\n  while (\\n    index < elements.length ||\\n    oldFiber != null\\n  ) {\\n    const element = elements[index]\\n    let newFiber = null\\n\\n    const sameType =\\n      oldFiber &&\\n      element &&\\n      element.type == oldFiber.type\\n\\n    if (sameType) {\\n      newFiber = {\\n        type: oldFiber.type,\\n        props: element.props,\\n        dom: oldFiber.dom,\\n        parent: wipFiber,\\n        alternate: oldFiber,\\n        effectTag: \\\"UPDATE\\\",\\n      }\\n    }\\n    if (element && !sameType) {\\n      newFiber = {\\n        type: element.type,\\n        props: element.props,\\n        dom: null,\\n        parent: wipFiber,\\n        alternate: null,\\n        effectTag: \\\"PLACEMENT\\\",\\n      }\\n    }\\n    if (oldFiber && !sameType) {\\n      oldFiber.effectTag = \\\"DELETION\\\"\\n      deletions.push(oldFiber)\\n    }\\n\\n    if (oldFiber) {\\n      oldFiber = oldFiber.sibling\\n    }\\n\\n    if (index === 0) {\\n      wipFiber.child = newFiber\\n    } else if (element) {\\n      prevSibling.sibling = newFiber\\n    }\\n\\n    prevSibling = newFiber\\n    index++\\n  }\\n}\\n\\nconst Didact = {\\n  createElement,\\n  render,\\n  useState,\\n}\\n\\n/** @jsx Didact.createElement */\\nfunction Counter() {\\n  const [state, setState] = Didact.useState(1)\\n  return (\\n    <h1 onClick={() => setState(c => c + 1)}>\\n      Count: {state}\\n    </h1>\\n  )\\n}\\nconst element = <Counter />\\nconst container = document.getElementById(\\\"root\\\")\\nDidact.render(element, container)\\n\")), mdx(\"p\", null, \"\\uD568\\uC218\\uD615 \\uCEF4\\uD3EC\\uB10C\\uD2B8\\uB97C \\uD638\\uCD9C\\uD558\\uAE30 \\uC804\\uC5D0 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useState\"), \" \\uD568\\uC218\\uC758 \\uB0B4\\uBD80\\uC5D0\\uC11C \\uC0AC\\uC6A9\\uD558\\uAE30 \\uC704\\uD55C \\uBA87\\uBA87 \\uC804\\uC5ED \\uBCC0\\uC218\\uB4E4\\uC744 \\uCD08\\uAE30\\uD654\\uD574\\uC57C \\uD569\\uB2C8\\uB2E4.\"), mdx(\"p\", null, \"\\uBA3C\\uC800 \\uC791\\uC5C5 \\uC911\\uC778 fiber\\uB97C \\uC124\\uC815\\uD569\\uB2C8\\uB2E4.\"), mdx(\"p\", null, \"\\uB610\\uD55C \\uADF8 fiber\\uC5D0 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"hooks\"), \" \\uBC30\\uC5F4\\uC744 \\uCD94\\uAC00\\uD568\\uC73C\\uB85C\\uC11C \\uB3D9\\uC77C\\uD55C \\uCEF4\\uD3EC\\uB10C\\uD2B8\\uC5D0\\uC11C \\uC5EC\\uB7EC \\uBC88 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useState\"), \" \\uD568\\uC218\\uB97C \\uD638\\uCD9C \\uD560 \\uC218 \\uC788\\uB3C4\\uB85D \\uD569\\uB2C8\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./48.jsx 206:218\",\n    \"file\": \"./48.jsx\",\n    \"206:218\": true\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children: children.map(child =>\\n        typeof child === \\\"object\\\"\\n          ? child\\n          : createTextElement(child)\\n      ),\\n    },\\n  }\\n}\\n\\nfunction createTextElement(text) {\\n  return {\\n    type: \\\"TEXT_ELEMENT\\\",\\n    props: {\\n      nodeValue: text,\\n      children: [],\\n    },\\n  }\\n}\\n\\nfunction createDom(fiber) {\\n  const dom =\\n    fiber.type == \\\"TEXT_ELEMENT\\\"\\n      ? document.createTextNode(\\\"\\\")\\n      : document.createElement(fiber.type)\\n\\n  updateDom(dom, {}, fiber.props)\\n\\n  return dom\\n}\\n\\nconst isEvent = key => key.startsWith(\\\"on\\\")\\nconst isProperty = key =>\\n  key !== \\\"children\\\" && !isEvent(key)\\nconst isNew = (prev, next) => key =>\\n  prev[key] !== next[key]\\nconst isGone = (prev, next) => key => !(key in next)\\nfunction updateDom(dom, prevProps, nextProps) {\\n  //Remove old or changed event listeners\\n  Object.keys(prevProps)\\n    .filter(isEvent)\\n    .filter(\\n      key =>\\n        !(key in nextProps) ||\\n        isNew(prevProps, nextProps)(key)\\n    )\\n    .forEach(name => {\\n      const eventType = name\\n        .toLowerCase()\\n        .substring(2)\\n      dom.removeEventListener(\\n        eventType,\\n        prevProps[name]\\n      )\\n    })\\n\\n  // Remove old properties\\n  Object.keys(prevProps)\\n    .filter(isProperty)\\n    .filter(isGone(prevProps, nextProps))\\n    .forEach(name => {\\n      dom[name] = \\\"\\\"\\n    })\\n\\n  // Set new or changed properties\\n  Object.keys(nextProps)\\n    .filter(isProperty)\\n    .filter(isNew(prevProps, nextProps))\\n    .forEach(name => {\\n      dom[name] = nextProps[name]\\n    })\\n\\n  // Add event listeners\\n  Object.keys(nextProps)\\n    .filter(isEvent)\\n    .filter(isNew(prevProps, nextProps))\\n    .forEach(name => {\\n      const eventType = name\\n        .toLowerCase()\\n        .substring(2)\\n      dom.addEventListener(\\n        eventType,\\n        nextProps[name]\\n      )\\n    })\\n}\\n\\nfunction commitRoot() {\\n  deletions.forEach(commitWork)\\n  commitWork(wipRoot.child)\\n  currentRoot = wipRoot\\n  wipRoot = null\\n}\\n\\nfunction commitWork(fiber) {\\n  if (!fiber) {\\n    return\\n  }\\n\\n  let domParentFiber = fiber.parent\\n  while (!domParentFiber.dom) {\\n    domParentFiber = domParentFiber.parent\\n  }\\n  const domParent = domParentFiber.dom\\n\\n  if (\\n    fiber.effectTag === \\\"PLACEMENT\\\" &&\\n    fiber.dom != null\\n  ) {\\n    domParent.appendChild(fiber.dom)\\n  } else if (\\n    fiber.effectTag === \\\"UPDATE\\\" &&\\n    fiber.dom != null\\n  ) {\\n    updateDom(\\n      fiber.dom,\\n      fiber.alternate.props,\\n      fiber.props\\n    )\\n  } else if (fiber.effectTag === \\\"DELETION\\\") {\\n    commitDeletion(fiber, domParent)\\n  }\\n\\n  commitWork(fiber.child)\\n  commitWork(fiber.sibling)\\n}\\n\\nfunction commitDeletion(fiber, domParent) {\\n  if (fiber.dom) {\\n    domParent.removeChild(fiber.dom)\\n  } else {\\n    commitDeletion(fiber.child, domParent)\\n  }\\n}\\n\\nfunction render(element, container) {\\n  wipRoot = {\\n    dom: container,\\n    props: {\\n      children: [element],\\n    },\\n    alternate: currentRoot,\\n  }\\n  deletions = []\\n  nextUnitOfWork = wipRoot\\n}\\n\\nlet nextUnitOfWork = null\\nlet currentRoot = null\\nlet wipRoot = null\\nlet deletions = null\\n\\nfunction workLoop(deadline) {\\n  let shouldYield = false\\n  while (nextUnitOfWork && !shouldYield) {\\n    nextUnitOfWork = performUnitOfWork(\\n      nextUnitOfWork\\n    )\\n    shouldYield = deadline.timeRemaining() < 1\\n  }\\n\\n  if (!nextUnitOfWork && wipRoot) {\\n    commitRoot()\\n  }\\n\\n  requestIdleCallback(workLoop)\\n}\\n\\nrequestIdleCallback(workLoop)\\n\\nfunction performUnitOfWork(fiber) {\\n  const isFunctionComponent =\\n    fiber.type instanceof Function\\n  if (isFunctionComponent) {\\n    updateFunctionComponent(fiber)\\n  } else {\\n    updateHostComponent(fiber)\\n  }\\n  if (fiber.child) {\\n    return fiber.child\\n  }\\n  let nextFiber = fiber\\n  while (nextFiber) {\\n    if (nextFiber.sibling) {\\n      return nextFiber.sibling\\n    }\\n    nextFiber = nextFiber.parent\\n  }\\n}\\n\\nlet wipFiber = null\\nlet hookIndex = null\\n\\nfunction updateFunctionComponent(fiber) {\\n  wipFiber = fiber\\n  hookIndex = 0\\n  wipFiber.hooks = []\\n  const children = [fiber.type(fiber.props)]\\n  reconcileChildren(fiber, children)\\n}\\n\\nfunction useState(initial) {\\n  const oldHook =\\n    wipFiber.alternate &&\\n    wipFiber.alternate.hooks &&\\n    wipFiber.alternate.hooks[hookIndex]\\n  const hook = {\\n    state: oldHook ? oldHook.state : initial,\\n  }\\n\\n  wipFiber.hooks.push(hook)\\n  hookIndex++\\n  return [hook.state]\\n}\\n\\nfunction updateHostComponent(fiber) {\\n  if (!fiber.dom) {\\n    fiber.dom = createDom(fiber)\\n  }\\n  reconcileChildren(fiber, fiber.props.children)\\n}\\n\\nfunction reconcileChildren(wipFiber, elements) {\\n  let index = 0\\n  let oldFiber =\\n    wipFiber.alternate && wipFiber.alternate.child\\n  let prevSibling = null\\n\\n  while (\\n    index < elements.length ||\\n    oldFiber != null\\n  ) {\\n    const element = elements[index]\\n    let newFiber = null\\n\\n    const sameType =\\n      oldFiber &&\\n      element &&\\n      element.type == oldFiber.type\\n\\n    if (sameType) {\\n      newFiber = {\\n        type: oldFiber.type,\\n        props: element.props,\\n        dom: oldFiber.dom,\\n        parent: wipFiber,\\n        alternate: oldFiber,\\n        effectTag: \\\"UPDATE\\\",\\n      }\\n    }\\n    if (element && !sameType) {\\n      newFiber = {\\n        type: element.type,\\n        props: element.props,\\n        dom: null,\\n        parent: wipFiber,\\n        alternate: null,\\n        effectTag: \\\"PLACEMENT\\\",\\n      }\\n    }\\n    if (oldFiber && !sameType) {\\n      oldFiber.effectTag = \\\"DELETION\\\"\\n      deletions.push(oldFiber)\\n    }\\n\\n    if (oldFiber) {\\n      oldFiber = oldFiber.sibling\\n    }\\n\\n    if (index === 0) {\\n      wipFiber.child = newFiber\\n    } else if (element) {\\n      prevSibling.sibling = newFiber\\n    }\\n\\n    prevSibling = newFiber\\n    index++\\n  }\\n}\\n\\nconst Didact = {\\n  createElement,\\n  render,\\n  useState,\\n}\\n\\n/** @jsx Didact.createElement */\\nfunction Counter() {\\n  const [state, setState] = Didact.useState(1)\\n  return (\\n    <h1 onClick={() => setState(c => c + 1)}>\\n      Count: {state}\\n    </h1>\\n  )\\n}\\nconst element = <Counter />\\nconst container = document.getElementById(\\\"root\\\")\\nDidact.render(element, container)\\n\")), mdx(\"p\", null, \"\\uD568\\uC218\\uD615 \\uCEF4\\uD3EC\\uB10C\\uD2B8\\uAC00 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useState\"), \"\\uB97C \\uD638\\uCD9C\\uD560 \\uB54C \\uC774\\uAC83\\uC774 \\uC624\\uB798\\uB41C hook\\uC778\\uC9C0\\uB97C \\uCCB4\\uD06C\\uD558\\uB294\\uB370, \\uC774\\uB54C \\uD6C5 \\uC778\\uB371\\uC2A4\\uB97C \\uC0AC\\uC6A9\\uD558\\uC5EC fiber\\uC758 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"alternate\"), \"\\uB97C \\uCCB4\\uD06C\\uD569\\uB2C8\\uB2E4.\"), mdx(\"p\", null, \"\\uB9CC\\uC57D \\uC6B0\\uB9AC\\uAC00 \\uAC00\\uC9C0\\uACE0 \\uC788\\uB294 \\uAC83\\uC774 \\uC624\\uB798\\uB41C hook\\uC774\\uB77C\\uBA74 \\uC0C1\\uD0DC\\uB97C \\uCD08\\uAE30\\uD654\\uD558\\uC9C0 \\uC54A\\uC558\\uC744 \\uACBD\\uC6B0 \\uC774 \\uD6C5\\uC758 \\uC0C1\\uD0DC\\uB97C \\uC0C8\\uB85C\\uC6B4 \\uD6C5\\uC73C\\uB85C \\uBCF5\\uC0AC\\uD569\\uB2C8\\uB2E4.\"), mdx(\"p\", null, \"\\uADF8\\uB9AC\\uACE0 \\uC0C8\\uB85C\\uC6B4 \\uD6C5\\uC744 fiber\\uC5D0 \\uCD94\\uAC00\\uD55C \\uB4A4 \\uD6C5 \\uC778\\uB371\\uC2A4 \\uAC12\\uC744 \\uC99D\\uAC00\\uC2DC\\uD0A8 \\uB2E4\\uC74C state\\uB97C \\uBC18\\uD658\\uD569\\uB2C8\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./49.jsx 211,213:225,229\",\n    \"file\": \"./49.jsx\",\n    \"211,213:225,229\": true\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children: children.map(child =>\\n        typeof child === \\\"object\\\"\\n          ? child\\n          : createTextElement(child)\\n      ),\\n    },\\n  }\\n}\\n\\nfunction createTextElement(text) {\\n  return {\\n    type: \\\"TEXT_ELEMENT\\\",\\n    props: {\\n      nodeValue: text,\\n      children: [],\\n    },\\n  }\\n}\\n\\nfunction createDom(fiber) {\\n  const dom =\\n    fiber.type == \\\"TEXT_ELEMENT\\\"\\n      ? document.createTextNode(\\\"\\\")\\n      : document.createElement(fiber.type)\\n\\n  updateDom(dom, {}, fiber.props)\\n\\n  return dom\\n}\\n\\nconst isEvent = key => key.startsWith(\\\"on\\\")\\nconst isProperty = key =>\\n  key !== \\\"children\\\" && !isEvent(key)\\nconst isNew = (prev, next) => key =>\\n  prev[key] !== next[key]\\nconst isGone = (prev, next) => key => !(key in next)\\nfunction updateDom(dom, prevProps, nextProps) {\\n  //Remove old or changed event listeners\\n  Object.keys(prevProps)\\n    .filter(isEvent)\\n    .filter(\\n      key =>\\n        !(key in nextProps) ||\\n        isNew(prevProps, nextProps)(key)\\n    )\\n    .forEach(name => {\\n      const eventType = name\\n        .toLowerCase()\\n        .substring(2)\\n      dom.removeEventListener(\\n        eventType,\\n        prevProps[name]\\n      )\\n    })\\n\\n  // Remove old properties\\n  Object.keys(prevProps)\\n    .filter(isProperty)\\n    .filter(isGone(prevProps, nextProps))\\n    .forEach(name => {\\n      dom[name] = \\\"\\\"\\n    })\\n\\n  // Set new or changed properties\\n  Object.keys(nextProps)\\n    .filter(isProperty)\\n    .filter(isNew(prevProps, nextProps))\\n    .forEach(name => {\\n      dom[name] = nextProps[name]\\n    })\\n\\n  // Add event listeners\\n  Object.keys(nextProps)\\n    .filter(isEvent)\\n    .filter(isNew(prevProps, nextProps))\\n    .forEach(name => {\\n      const eventType = name\\n        .toLowerCase()\\n        .substring(2)\\n      dom.addEventListener(\\n        eventType,\\n        nextProps[name]\\n      )\\n    })\\n}\\n\\nfunction commitRoot() {\\n  deletions.forEach(commitWork)\\n  commitWork(wipRoot.child)\\n  currentRoot = wipRoot\\n  wipRoot = null\\n}\\n\\nfunction commitWork(fiber) {\\n  if (!fiber) {\\n    return\\n  }\\n\\n  let domParentFiber = fiber.parent\\n  while (!domParentFiber.dom) {\\n    domParentFiber = domParentFiber.parent\\n  }\\n  const domParent = domParentFiber.dom\\n\\n  if (\\n    fiber.effectTag === \\\"PLACEMENT\\\" &&\\n    fiber.dom != null\\n  ) {\\n    domParent.appendChild(fiber.dom)\\n  } else if (\\n    fiber.effectTag === \\\"UPDATE\\\" &&\\n    fiber.dom != null\\n  ) {\\n    updateDom(\\n      fiber.dom,\\n      fiber.alternate.props,\\n      fiber.props\\n    )\\n  } else if (fiber.effectTag === \\\"DELETION\\\") {\\n    commitDeletion(fiber, domParent)\\n  }\\n\\n  commitWork(fiber.child)\\n  commitWork(fiber.sibling)\\n}\\n\\nfunction commitDeletion(fiber, domParent) {\\n  if (fiber.dom) {\\n    domParent.removeChild(fiber.dom)\\n  } else {\\n    commitDeletion(fiber.child, domParent)\\n  }\\n}\\n\\nfunction render(element, container) {\\n  wipRoot = {\\n    dom: container,\\n    props: {\\n      children: [element],\\n    },\\n    alternate: currentRoot,\\n  }\\n  deletions = []\\n  nextUnitOfWork = wipRoot\\n}\\n\\nlet nextUnitOfWork = null\\nlet currentRoot = null\\nlet wipRoot = null\\nlet deletions = null\\n\\nfunction workLoop(deadline) {\\n  let shouldYield = false\\n  while (nextUnitOfWork && !shouldYield) {\\n    nextUnitOfWork = performUnitOfWork(\\n      nextUnitOfWork\\n    )\\n    shouldYield = deadline.timeRemaining() < 1\\n  }\\n\\n  if (!nextUnitOfWork && wipRoot) {\\n    commitRoot()\\n  }\\n\\n  requestIdleCallback(workLoop)\\n}\\n\\nrequestIdleCallback(workLoop)\\n\\nfunction performUnitOfWork(fiber) {\\n  const isFunctionComponent =\\n    fiber.type instanceof Function\\n  if (isFunctionComponent) {\\n    updateFunctionComponent(fiber)\\n  } else {\\n    updateHostComponent(fiber)\\n  }\\n  if (fiber.child) {\\n    return fiber.child\\n  }\\n  let nextFiber = fiber\\n  while (nextFiber) {\\n    if (nextFiber.sibling) {\\n      return nextFiber.sibling\\n    }\\n    nextFiber = nextFiber.parent\\n  }\\n}\\n\\nlet wipFiber = null\\nlet hookIndex = null\\n\\nfunction updateFunctionComponent(fiber) {\\n  wipFiber = fiber\\n  hookIndex = 0\\n  wipFiber.hooks = []\\n  const children = [fiber.type(fiber.props)]\\n  reconcileChildren(fiber, children)\\n}\\n\\nfunction useState(initial) {\\n  const oldHook =\\n    wipFiber.alternate &&\\n    wipFiber.alternate.hooks &&\\n    wipFiber.alternate.hooks[hookIndex]\\n  const hook = {\\n    state: oldHook ? oldHook.state : initial,\\n    queue: [],\\n  }\\n\\n  const setState = action => {\\n    hook.queue.push(action)\\n    wipRoot = {\\n      dom: currentRoot.dom,\\n      props: currentRoot.props,\\n      alternate: currentRoot,\\n    }\\n    nextUnitOfWork = wipRoot\\n    deletions = []\\n  }\\n\\n  wipFiber.hooks.push(hook)\\n  hookIndex++\\n  return [hook.state, setState]\\n}\\n\\nfunction updateHostComponent(fiber) {\\n  if (!fiber.dom) {\\n    fiber.dom = createDom(fiber)\\n  }\\n  reconcileChildren(fiber, fiber.props.children)\\n}\\n\\nfunction reconcileChildren(wipFiber, elements) {\\n  let index = 0\\n  let oldFiber =\\n    wipFiber.alternate && wipFiber.alternate.child\\n  let prevSibling = null\\n\\n  while (\\n    index < elements.length ||\\n    oldFiber != null\\n  ) {\\n    const element = elements[index]\\n    let newFiber = null\\n\\n    const sameType =\\n      oldFiber &&\\n      element &&\\n      element.type == oldFiber.type\\n\\n    if (sameType) {\\n      newFiber = {\\n        type: oldFiber.type,\\n        props: element.props,\\n        dom: oldFiber.dom,\\n        parent: wipFiber,\\n        alternate: oldFiber,\\n        effectTag: \\\"UPDATE\\\",\\n      }\\n    }\\n    if (element && !sameType) {\\n      newFiber = {\\n        type: element.type,\\n        props: element.props,\\n        dom: null,\\n        parent: wipFiber,\\n        alternate: null,\\n        effectTag: \\\"PLACEMENT\\\",\\n      }\\n    }\\n    if (oldFiber && !sameType) {\\n      oldFiber.effectTag = \\\"DELETION\\\"\\n      deletions.push(oldFiber)\\n    }\\n\\n    if (oldFiber) {\\n      oldFiber = oldFiber.sibling\\n    }\\n\\n    if (index === 0) {\\n      wipFiber.child = newFiber\\n    } else if (element) {\\n      prevSibling.sibling = newFiber\\n    }\\n\\n    prevSibling = newFiber\\n    index++\\n  }\\n}\\n\\nconst Didact = {\\n  createElement,\\n  render,\\n  useState,\\n}\\n\\n/** @jsx Didact.createElement */\\nfunction Counter() {\\n  const [state, setState] = Didact.useState(1)\\n  return (\\n    <h1 onClick={() => setState(c => c + 1)}>\\n      Count: {state}\\n    </h1>\\n  )\\n}\\nconst element = <Counter />\\nconst container = document.getElementById(\\\"root\\\")\\nDidact.render(element, container)\\n\")), mdx(\"p\", null, \"\\uB610\\uD55C \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useState\"), \"\\uB294 \\uC0C1\\uD0DC\\uB97C \\uAC31\\uC2E0\\uD558\\uB294 \\uD568\\uC218 \\uC5ED\\uC2DC \\uB9AC\\uD134\\uD574\\uC57C \\uD558\\uBBC0\\uB85C, \\uC561\\uC158\\uC744 \\uBC1B\\uB294 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"setState\"), \" \\uD568\\uC218\\uB97C \\uC815\\uC758\\uD569\\uB2C8\\uB2E4. (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Counter\"), \" \\uC608\\uC81C\\uC758 \\uACBD\\uC6B0, \\uC561\\uC158\\uC740 \\uC0C1\\uD0DC\\uB97C 1 \\uC99D\\uAC00\\uC2DC\\uD0A4\\uB294 \\uB3D9\\uC791\\uC785\\uB2C8\\uB2E4)\"), mdx(\"p\", null, \"\\uC774 \\uC561\\uC158\\uC744 \\uC6B0\\uB9AC\\uAC00 \\uD6C5\\uC5D0 \\uCD94\\uAC00\\uD55C \\uD050\\uC5D0 \\uB123\\uC2B5\\uB2C8\\uB2E4.\"), mdx(\"p\", null, \"And then we do something similar to what we did in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"render\"), \" function, set a new work in progress root as the next unit of work so the work loop can start a new render phase.\"), mdx(\"p\", null, \"\\uADF8\\uB9AC\\uACE0 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"render\"), \" \\uD568\\uC218\\uC5D0\\uC11C \\uD588\\uB358 \\uAC83\\uACFC \\uBE44\\uC2B7\\uD55C \\uC791\\uC5C5\\uC744 \\uD558\\uB294\\uB370, \\uC0C8\\uB85C\\uC6B4 \\uC791\\uC5C5 \\uC911(wip)\\uC778 \\uB8E8\\uD2B8\\uB97C \\uB2E4\\uC74C \\uC791\\uC5C5\\uD560 \\uB2E8\\uC704\\uB85C \\uC124\\uC815\\uD558\\uC5EC \\uBC18\\uBCF5\\uBB38\\uC5D0\\uC11C \\uC0C8\\uB85C\\uC6B4 \\uB80C\\uB354 \\uB2E8\\uACC4\\uB97C \\uC2DC\\uC791\\uD560 \\uC218 \\uC788\\uB3C4\\uB85D \\uD569\\uB2C8\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./50.jsx\",\n    \"file\": \"./50.jsx\"\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children: children.map(child =>\\n        typeof child === \\\"object\\\"\\n          ? child\\n          : createTextElement(child)\\n      ),\\n    },\\n  }\\n}\\n\\nfunction createTextElement(text) {\\n  return {\\n    type: \\\"TEXT_ELEMENT\\\",\\n    props: {\\n      nodeValue: text,\\n      children: [],\\n    },\\n  }\\n}\\n\\nfunction createDom(fiber) {\\n  const dom =\\n    fiber.type == \\\"TEXT_ELEMENT\\\"\\n      ? document.createTextNode(\\\"\\\")\\n      : document.createElement(fiber.type)\\n\\n  updateDom(dom, {}, fiber.props)\\n\\n  return dom\\n}\\n\\nconst isEvent = key => key.startsWith(\\\"on\\\")\\nconst isProperty = key =>\\n  key !== \\\"children\\\" && !isEvent(key)\\nconst isNew = (prev, next) => key =>\\n  prev[key] !== next[key]\\nconst isGone = (prev, next) => key => !(key in next)\\nfunction updateDom(dom, prevProps, nextProps) {\\n  //Remove old or changed event listeners\\n  Object.keys(prevProps)\\n    .filter(isEvent)\\n    .filter(\\n      key =>\\n        !(key in nextProps) ||\\n        isNew(prevProps, nextProps)(key)\\n    )\\n    .forEach(name => {\\n      const eventType = name\\n        .toLowerCase()\\n        .substring(2)\\n      dom.removeEventListener(\\n        eventType,\\n        prevProps[name]\\n      )\\n    })\\n\\n  // Remove old properties\\n  Object.keys(prevProps)\\n    .filter(isProperty)\\n    .filter(isGone(prevProps, nextProps))\\n    .forEach(name => {\\n      dom[name] = \\\"\\\"\\n    })\\n\\n  // Set new or changed properties\\n  Object.keys(nextProps)\\n    .filter(isProperty)\\n    .filter(isNew(prevProps, nextProps))\\n    .forEach(name => {\\n      dom[name] = nextProps[name]\\n    })\\n\\n  // Add event listeners\\n  Object.keys(nextProps)\\n    .filter(isEvent)\\n    .filter(isNew(prevProps, nextProps))\\n    .forEach(name => {\\n      const eventType = name\\n        .toLowerCase()\\n        .substring(2)\\n      dom.addEventListener(\\n        eventType,\\n        nextProps[name]\\n      )\\n    })\\n}\\n\\nfunction commitRoot() {\\n  deletions.forEach(commitWork)\\n  commitWork(wipRoot.child)\\n  currentRoot = wipRoot\\n  wipRoot = null\\n}\\n\\nfunction commitWork(fiber) {\\n  if (!fiber) {\\n    return\\n  }\\n\\n  let domParentFiber = fiber.parent\\n  while (!domParentFiber.dom) {\\n    domParentFiber = domParentFiber.parent\\n  }\\n  const domParent = domParentFiber.dom\\n\\n  if (\\n    fiber.effectTag === \\\"PLACEMENT\\\" &&\\n    fiber.dom != null\\n  ) {\\n    domParent.appendChild(fiber.dom)\\n  } else if (\\n    fiber.effectTag === \\\"UPDATE\\\" &&\\n    fiber.dom != null\\n  ) {\\n    updateDom(\\n      fiber.dom,\\n      fiber.alternate.props,\\n      fiber.props\\n    )\\n  } else if (fiber.effectTag === \\\"DELETION\\\") {\\n    commitDeletion(fiber, domParent)\\n  }\\n\\n  commitWork(fiber.child)\\n  commitWork(fiber.sibling)\\n}\\n\\nfunction commitDeletion(fiber, domParent) {\\n  if (fiber.dom) {\\n    domParent.removeChild(fiber.dom)\\n  } else {\\n    commitDeletion(fiber.child, domParent)\\n  }\\n}\\n\\nfunction render(element, container) {\\n  wipRoot = {\\n    dom: container,\\n    props: {\\n      children: [element],\\n    },\\n    alternate: currentRoot,\\n  }\\n  deletions = []\\n  nextUnitOfWork = wipRoot\\n}\\n\\nlet nextUnitOfWork = null\\nlet currentRoot = null\\nlet wipRoot = null\\nlet deletions = null\\n\\nfunction workLoop(deadline) {\\n  let shouldYield = false\\n  while (nextUnitOfWork && !shouldYield) {\\n    nextUnitOfWork = performUnitOfWork(\\n      nextUnitOfWork\\n    )\\n    shouldYield = deadline.timeRemaining() < 1\\n  }\\n\\n  if (!nextUnitOfWork && wipRoot) {\\n    commitRoot()\\n  }\\n\\n  requestIdleCallback(workLoop)\\n}\\n\\nrequestIdleCallback(workLoop)\\n\\nfunction performUnitOfWork(fiber) {\\n  const isFunctionComponent =\\n    fiber.type instanceof Function\\n  if (isFunctionComponent) {\\n    updateFunctionComponent(fiber)\\n  } else {\\n    updateHostComponent(fiber)\\n  }\\n  if (fiber.child) {\\n    return fiber.child\\n  }\\n  let nextFiber = fiber\\n  while (nextFiber) {\\n    if (nextFiber.sibling) {\\n      return nextFiber.sibling\\n    }\\n    nextFiber = nextFiber.parent\\n  }\\n}\\n\\nlet wipFiber = null\\nlet hookIndex = null\\n\\nfunction updateFunctionComponent(fiber) {\\n  wipFiber = fiber\\n  hookIndex = 0\\n  wipFiber.hooks = []\\n  const children = [fiber.type(fiber.props)]\\n  reconcileChildren(fiber, children)\\n}\\n\\nfunction useState(initial) {\\n  const oldHook =\\n    wipFiber.alternate &&\\n    wipFiber.alternate.hooks &&\\n    wipFiber.alternate.hooks[hookIndex]\\n  const hook = {\\n    state: oldHook ? oldHook.state : initial,\\n    queue: [],\\n  }\\n\\n  const actions = oldHook ? oldHook.queue : []\\n  actions.forEach(action => {\\n    hook.state = action(hook.state)\\n  })\\n\\n  const setState = action => {\\n    hook.queue.push(action)\\n    wipRoot = {\\n      dom: currentRoot.dom,\\n      props: currentRoot.props,\\n      alternate: currentRoot,\\n    }\\n    nextUnitOfWork = wipRoot\\n    deletions = []\\n  }\\n\\n  wipFiber.hooks.push(hook)\\n  hookIndex++\\n  return [hook.state, setState]\\n}\\n\\nfunction updateHostComponent(fiber) {\\n  if (!fiber.dom) {\\n    fiber.dom = createDom(fiber)\\n  }\\n  reconcileChildren(fiber, fiber.props.children)\\n}\\n\\nfunction reconcileChildren(wipFiber, elements) {\\n  let index = 0\\n  let oldFiber =\\n    wipFiber.alternate && wipFiber.alternate.child\\n  let prevSibling = null\\n\\n  while (\\n    index < elements.length ||\\n    oldFiber != null\\n  ) {\\n    const element = elements[index]\\n    let newFiber = null\\n\\n    const sameType =\\n      oldFiber &&\\n      element &&\\n      element.type == oldFiber.type\\n\\n    if (sameType) {\\n      newFiber = {\\n        type: oldFiber.type,\\n        props: element.props,\\n        dom: oldFiber.dom,\\n        parent: wipFiber,\\n        alternate: oldFiber,\\n        effectTag: \\\"UPDATE\\\",\\n      }\\n    }\\n    if (element && !sameType) {\\n      newFiber = {\\n        type: element.type,\\n        props: element.props,\\n        dom: null,\\n        parent: wipFiber,\\n        alternate: null,\\n        effectTag: \\\"PLACEMENT\\\",\\n      }\\n    }\\n    if (oldFiber && !sameType) {\\n      oldFiber.effectTag = \\\"DELETION\\\"\\n      deletions.push(oldFiber)\\n    }\\n\\n    if (oldFiber) {\\n      oldFiber = oldFiber.sibling\\n    }\\n\\n    if (index === 0) {\\n      wipFiber.child = newFiber\\n    } else if (element) {\\n      prevSibling.sibling = newFiber\\n    }\\n\\n    prevSibling = newFiber\\n    index++\\n  }\\n}\\n\\nconst Didact = {\\n  createElement,\\n  render,\\n  useState,\\n}\\n\\n/** @jsx Didact.createElement */\\nfunction Counter() {\\n  const [state, setState] = Didact.useState(1)\\n  return (\\n    <h1 onClick={() => setState(c => c + 1)}>\\n      Count: {state}\\n    </h1>\\n  )\\n}\\nconst element = <Counter />\\nconst container = document.getElementById(\\\"root\\\")\\nDidact.render(element, container)\\n\")), mdx(\"p\", null, \"\\uC544\\uC9C1 \\uC561\\uC158\\uC744 \\uC2E4\\uD589\\uD558\\uC9C0\\uB294 \\uC54A\\uC558\\uC2B5\\uB2C8\\uB2E4.\"), mdx(\"p\", null, \"\\uC774\\uB294 \\uCEF4\\uD3EC\\uB10C\\uD2B8 \\uB80C\\uB354\\uB9C1 \\uB2E4\\uC74C\\uC5D0 \\uC218\\uD589\\uD558\\uB294\\uB370, \\uC624\\uB798\\uB41C \\uD6C5\\uC758 \\uD050\\uC5D0\\uC11C \\uBAA8\\uB4E0 \\uC561\\uC158\\uC744 \\uAC00\\uC838\\uC628 \\uB2E4\\uC74C \\uC774\\uB97C \\uC0C8\\uB85C\\uC6B4 \\uD6C5 state\\uC5D0 \\uD558\\uB098\\uC529 \\uC801\\uC6A9\\uD558\\uBA74 \\uAC31\\uC2E0\\uB41C state\\uB97C \\uC5BB\\uC744 \\uC218 \\uC788\\uAC8C \\uB429\\uB2C8\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"file=./50.jsx 1:319\",\n    \"file\": \"./50.jsx\",\n    \"1:319\": true\n  }), \"function createElement(type, props, ...children) {\\n  return {\\n    type,\\n    props: {\\n      ...props,\\n      children: children.map(child =>\\n        typeof child === \\\"object\\\"\\n          ? child\\n          : createTextElement(child)\\n      ),\\n    },\\n  }\\n}\\n\\nfunction createTextElement(text) {\\n  return {\\n    type: \\\"TEXT_ELEMENT\\\",\\n    props: {\\n      nodeValue: text,\\n      children: [],\\n    },\\n  }\\n}\\n\\nfunction createDom(fiber) {\\n  const dom =\\n    fiber.type == \\\"TEXT_ELEMENT\\\"\\n      ? document.createTextNode(\\\"\\\")\\n      : document.createElement(fiber.type)\\n\\n  updateDom(dom, {}, fiber.props)\\n\\n  return dom\\n}\\n\\nconst isEvent = key => key.startsWith(\\\"on\\\")\\nconst isProperty = key =>\\n  key !== \\\"children\\\" && !isEvent(key)\\nconst isNew = (prev, next) => key =>\\n  prev[key] !== next[key]\\nconst isGone = (prev, next) => key => !(key in next)\\nfunction updateDom(dom, prevProps, nextProps) {\\n  //Remove old or changed event listeners\\n  Object.keys(prevProps)\\n    .filter(isEvent)\\n    .filter(\\n      key =>\\n        !(key in nextProps) ||\\n        isNew(prevProps, nextProps)(key)\\n    )\\n    .forEach(name => {\\n      const eventType = name\\n        .toLowerCase()\\n        .substring(2)\\n      dom.removeEventListener(\\n        eventType,\\n        prevProps[name]\\n      )\\n    })\\n\\n  // Remove old properties\\n  Object.keys(prevProps)\\n    .filter(isProperty)\\n    .filter(isGone(prevProps, nextProps))\\n    .forEach(name => {\\n      dom[name] = \\\"\\\"\\n    })\\n\\n  // Set new or changed properties\\n  Object.keys(nextProps)\\n    .filter(isProperty)\\n    .filter(isNew(prevProps, nextProps))\\n    .forEach(name => {\\n      dom[name] = nextProps[name]\\n    })\\n\\n  // Add event listeners\\n  Object.keys(nextProps)\\n    .filter(isEvent)\\n    .filter(isNew(prevProps, nextProps))\\n    .forEach(name => {\\n      const eventType = name\\n        .toLowerCase()\\n        .substring(2)\\n      dom.addEventListener(\\n        eventType,\\n        nextProps[name]\\n      )\\n    })\\n}\\n\\nfunction commitRoot() {\\n  deletions.forEach(commitWork)\\n  commitWork(wipRoot.child)\\n  currentRoot = wipRoot\\n  wipRoot = null\\n}\\n\\nfunction commitWork(fiber) {\\n  if (!fiber) {\\n    return\\n  }\\n\\n  let domParentFiber = fiber.parent\\n  while (!domParentFiber.dom) {\\n    domParentFiber = domParentFiber.parent\\n  }\\n  const domParent = domParentFiber.dom\\n\\n  if (\\n    fiber.effectTag === \\\"PLACEMENT\\\" &&\\n    fiber.dom != null\\n  ) {\\n    domParent.appendChild(fiber.dom)\\n  } else if (\\n    fiber.effectTag === \\\"UPDATE\\\" &&\\n    fiber.dom != null\\n  ) {\\n    updateDom(\\n      fiber.dom,\\n      fiber.alternate.props,\\n      fiber.props\\n    )\\n  } else if (fiber.effectTag === \\\"DELETION\\\") {\\n    commitDeletion(fiber, domParent)\\n  }\\n\\n  commitWork(fiber.child)\\n  commitWork(fiber.sibling)\\n}\\n\\nfunction commitDeletion(fiber, domParent) {\\n  if (fiber.dom) {\\n    domParent.removeChild(fiber.dom)\\n  } else {\\n    commitDeletion(fiber.child, domParent)\\n  }\\n}\\n\\nfunction render(element, container) {\\n  wipRoot = {\\n    dom: container,\\n    props: {\\n      children: [element],\\n    },\\n    alternate: currentRoot,\\n  }\\n  deletions = []\\n  nextUnitOfWork = wipRoot\\n}\\n\\nlet nextUnitOfWork = null\\nlet currentRoot = null\\nlet wipRoot = null\\nlet deletions = null\\n\\nfunction workLoop(deadline) {\\n  let shouldYield = false\\n  while (nextUnitOfWork && !shouldYield) {\\n    nextUnitOfWork = performUnitOfWork(\\n      nextUnitOfWork\\n    )\\n    shouldYield = deadline.timeRemaining() < 1\\n  }\\n\\n  if (!nextUnitOfWork && wipRoot) {\\n    commitRoot()\\n  }\\n\\n  requestIdleCallback(workLoop)\\n}\\n\\nrequestIdleCallback(workLoop)\\n\\nfunction performUnitOfWork(fiber) {\\n  const isFunctionComponent =\\n    fiber.type instanceof Function\\n  if (isFunctionComponent) {\\n    updateFunctionComponent(fiber)\\n  } else {\\n    updateHostComponent(fiber)\\n  }\\n  if (fiber.child) {\\n    return fiber.child\\n  }\\n  let nextFiber = fiber\\n  while (nextFiber) {\\n    if (nextFiber.sibling) {\\n      return nextFiber.sibling\\n    }\\n    nextFiber = nextFiber.parent\\n  }\\n}\\n\\nlet wipFiber = null\\nlet hookIndex = null\\n\\nfunction updateFunctionComponent(fiber) {\\n  wipFiber = fiber\\n  hookIndex = 0\\n  wipFiber.hooks = []\\n  const children = [fiber.type(fiber.props)]\\n  reconcileChildren(fiber, children)\\n}\\n\\nfunction useState(initial) {\\n  const oldHook =\\n    wipFiber.alternate &&\\n    wipFiber.alternate.hooks &&\\n    wipFiber.alternate.hooks[hookIndex]\\n  const hook = {\\n    state: oldHook ? oldHook.state : initial,\\n    queue: [],\\n  }\\n\\n  const actions = oldHook ? oldHook.queue : []\\n  actions.forEach(action => {\\n    hook.state = action(hook.state)\\n  })\\n\\n  const setState = action => {\\n    hook.queue.push(action)\\n    wipRoot = {\\n      dom: currentRoot.dom,\\n      props: currentRoot.props,\\n      alternate: currentRoot,\\n    }\\n    nextUnitOfWork = wipRoot\\n    deletions = []\\n  }\\n\\n  wipFiber.hooks.push(hook)\\n  hookIndex++\\n  return [hook.state, setState]\\n}\\n\\nfunction updateHostComponent(fiber) {\\n  if (!fiber.dom) {\\n    fiber.dom = createDom(fiber)\\n  }\\n  reconcileChildren(fiber, fiber.props.children)\\n}\\n\\nfunction reconcileChildren(wipFiber, elements) {\\n  let index = 0\\n  let oldFiber =\\n    wipFiber.alternate && wipFiber.alternate.child\\n  let prevSibling = null\\n\\n  while (\\n    index < elements.length ||\\n    oldFiber != null\\n  ) {\\n    const element = elements[index]\\n    let newFiber = null\\n\\n    const sameType =\\n      oldFiber &&\\n      element &&\\n      element.type == oldFiber.type\\n\\n    if (sameType) {\\n      newFiber = {\\n        type: oldFiber.type,\\n        props: element.props,\\n        dom: oldFiber.dom,\\n        parent: wipFiber,\\n        alternate: oldFiber,\\n        effectTag: \\\"UPDATE\\\",\\n      }\\n    }\\n    if (element && !sameType) {\\n      newFiber = {\\n        type: element.type,\\n        props: element.props,\\n        dom: null,\\n        parent: wipFiber,\\n        alternate: null,\\n        effectTag: \\\"PLACEMENT\\\",\\n      }\\n    }\\n    if (oldFiber && !sameType) {\\n      oldFiber.effectTag = \\\"DELETION\\\"\\n      deletions.push(oldFiber)\\n    }\\n\\n    if (oldFiber) {\\n      oldFiber = oldFiber.sibling\\n    }\\n\\n    if (index === 0) {\\n      wipFiber.child = newFiber\\n    } else if (element) {\\n      prevSibling.sibling = newFiber\\n    }\\n\\n    prevSibling = newFiber\\n    index++\\n  }\\n}\\n\\nconst Didact = {\\n  createElement,\\n  render,\\n  useState,\\n}\\n\\n/** @jsx Didact.createElement */\\nfunction Counter() {\\n  const [state, setState] = Didact.useState(1)\\n  return (\\n    <h1 onClick={() => setState(c => c + 1)}>\\n      Count: {state}\\n    </h1>\\n  )\\n}\\nconst element = <Counter />\\nconst container = document.getElementById(\\\"root\\\")\\nDidact.render(element, container)\\n\")), mdx(\"p\", null, \"\\uC790 \\uC774\\uC81C \\uB05D\\uB0AC\\uC2B5\\uB2C8\\uB2E4. \\uC6B0\\uB9AC\\uB294 \\uC9C1\\uC811 \\uB098\\uB9CC\\uC758 \\uBC84\\uC804\\uC73C\\uB85C \\uB9AC\\uC561\\uD2B8\\uB97C \\uB9CC\\uB4E4\\uC5B4\\uBCF4\\uC558\\uC2B5\\uB2C8\\uB2E4. \"), mdx(\"p\", null, \"\\uC774\\uB97C \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://codesandbox.io/s/didact-8-21ost\"\n  }), \"codesandbox\"), \" \\uD639\\uC740 \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/pomber/didact\"\n  }), \"github\"), \"\\uC5D0\\uC11C \\uC2E4\\uD589\\uD574\\uBCFC \\uC218 \\uC788\\uC2B5\\uB2C8\\uB2E4.\")), mdx(\"h2\", {\n    \"id\": \"에필로그\"\n  }, \"\\uC5D0\\uD544\\uB85C\\uADF8\"), mdx(\"p\", null, \"\\uC774 \\uD3EC\\uC2A4\\uD2B8\\uC758 \\uBAA9\\uC801\\uC740 \\uB9AC\\uC561\\uD2B8\\uAC00 \\uC5B4\\uB5BB\\uAC8C \\uB3D9\\uC791\\uD558\\uB294\\uC9C0 \\uC54C\\uAE30 \\uC27D\\uB3C4\\uB85D \\uB3D5\\uB294 \\uAC83 \\uC678\\uC5D0\\uB3C4, \\uB9AC\\uC561\\uD2B8 \\uCF54\\uB4DC\\uBCA0\\uC774\\uC2A4\\uB97C \\uAE4A\\uC774 \\uD0D0\\uAD6C\\uD558\\uAE30 \\uC6A9\\uC774\\uD558\\uAC8C \\uD558\\uB824\\uB294 \\uC758\\uB3C4\\uB3C4 \\uC788\\uC2B5\\uB2C8\\uB2E4. \\uADF8\\uB807\\uAE30\\uC5D0 \\uAC70\\uC758 \\uB300\\uBD80\\uBD84 \\uB3D9\\uC77C\\uD55C \\uBCC0\\uC218\\uC640 \\uD568\\uC218\\uBA85\\uC744 \\uC0AC\\uC6A9\\uD55C \\uAC83\\uC785\\uB2C8\\uB2E4.\"), mdx(\"p\", null, \"\\uAC00\\uB839, \\uC2E4\\uC81C \\uB9AC\\uC561\\uD2B8 \\uC571\\uC5D0\\uC11C \\uD568\\uC218\\uD615 \\uCEF4\\uD3EC\\uB10C\\uD2B8\\uC5D0 \\uC911\\uB2E8\\uC810\\uC744 \\uCD94\\uAC00\\uD55C\\uB2E4\\uACE0 \\uD588\\uC744 \\uB54C, \\uCF5C \\uC2A4\\uD0DD\\uC740 \\uB2E4\\uC74C\\uC744 \\uD45C\\uC2DC\\uD569\\uB2C8\\uB2E4:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"workLoop\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"performUnitOfWork\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"updateFunctionComponent\"))), mdx(\"p\", null, \"\\uB610\\uD55C \\uB9AC\\uC561\\uD2B8\\uC758 \\uBAA8\\uB4E0 \\uAE30\\uB2A5\\uB4E4\\uACFC \\uCD5C\\uC801\\uD654 \\uC694\\uC18C\\uB4E4\\uC774 \\uD3EC\\uD568\\uB418\\uC9C0\\uB294 \\uC54A\\uC558\\uC2B5\\uB2C8\\uB2E4. \\uAC00\\uB839, \\uB2E4\\uC74C\\uC740 \\uB9AC\\uC561\\uD2B8\\uC640\\uB294 \\uB2E4\\uB974\\uAC8C \\uB3D9\\uC791\\uD558\\uB294 \\uAC83\\uB4E4\\uC785\\uB2C8\\uB2E4\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\\uB514\\uC561\\uD2B8\\uC5D0\\uC11C\\uB294 \\uB80C\\uB354 \\uB2E8\\uACC4\\uC758 \\uBAA8\\uB4E0 \\uD2B8\\uB9AC\\uB97C \\uC21C\\uD68C\\uD558\\uC9C0\\uB9CC \\uC2E4\\uC81C \\uB9AC\\uC561\\uD2B8\\uB294 \\uB300\\uC2E0 \\uD2B9\\uC815\\uD55C \\uD78C\\uD2B8\\uB9CC\\uC744 \\uB530\\uB77C\\uAC00\\uBA70 \\uBCC0\\uD558\\uC9C0 \\uC54A\\uC740 \\uC11C\\uBE0C \\uD2B8\\uB9AC\\uB294 \\uD734\\uB9AC\\uC2A4\\uD2F1\\uD558\\uAC8C \\uB6F0\\uC5B4\\uB118\\uC2B5\\uB2C8\\uB2E4.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\\uB514\\uC561\\uD2B8\\uB294 \\uCEE4\\uBC0B \\uB2E8\\uACC4\\uC5D0\\uC11C\\uB3C4 \\uBAA8\\uB4E0 \\uD2B8\\uB9AC\\uB97C \\uC21C\\uD68C\\uD569\\uB2C8\\uB2E4. \\uD558\\uC9C0\\uB9CC \\uB9AC\\uC561\\uD2B8\\uB294 \\uC601\\uD5A5\\uC774 \\uAC00\\uB294 fiber\\uB4E4\\uC758 \\uC5F0\\uACB0 \\uB9AC\\uC2A4\\uD2B8\\uB97C \\uC720\\uC9C0\\uD558\\uC5EC \\uD574\\uB2F9 fiber\\uB9CC \\uBC29\\uBB38\\uD569\\uB2C8\\uB2E4.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\\uC791\\uC5C5 \\uC911(wip)\\uC778 \\uD2B8\\uB9AC\\uB97C \\uC0DD\\uC131\\uD560 \\uB54C\\uB9C8\\uB2E4 \\uC6B0\\uB9AC\\uB294 \\uAC01 fiber\\uC5D0 \\uC0C8\\uB85C\\uC6B4 \\uAC1D\\uCCB4\\uB97C \\uC0DD\\uC131\\uD588\\uC9C0\\uB9CC, \\uB9AC\\uC561\\uD2B8\\uB294 \\uC774\\uC804\\uC758 \\uD2B8\\uB9AC\\uC5D0\\uC11C \\uAC00\\uC838\\uC628 fiber\\uB97C \\uC7AC\\uC0AC\\uC6A9\\uD569\\uB2C8\\uB2E4.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\\uB514\\uC561\\uD2B8\\uB294 \\uB80C\\uB354 \\uB2E8\\uACC4\\uC5D0\\uC11C \\uC0C8\\uB85C\\uC6B4 \\uAC31\\uC2E0\\uC744 \\uC5BB\\uC744 \\uB54C \\uC791\\uC5C5 \\uC911(wip)\\uC778 \\uD2B8\\uB9AC\\uB97C \\uBC84\\uB9AC\\uACE0 \\uB8E8\\uD2B8\\uC5D0\\uC11C\\uBD80\\uD130 \\uC0C8\\uB85C \\uC2DC\\uC791\\uD558\\uC9C0\\uB9CC, \\uB9AC\\uC561\\uD2B8\\uB294 \\uAC01 \\uAC31\\uC2E0\\uC758 \\uB9CC\\uB8CC \\uD0C0\\uC784\\uC2A4\\uD0EC\\uD504\\uB97C \\uD45C\\uC2DC\\uD574\\uB450\\uACE0, \\uAC31\\uC2E0 \\uC2DC \\uC774\\uB97C \\uB192\\uC740 \\uC6B0\\uC120\\uC21C\\uC704\\uB85C \\uCC38\\uACE0\\uD558\\uC5EC \\uACB0\\uC815\\uD569\\uB2C8\\uB2E4.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\\uADF8 \\uC678\\uC5D0\\uB3C4 \\uB9CE\\uC740 \\uAC83\\uB4E4\\uC774 \\uB2E4\\uB985\\uB2C8\\uB2E4.\")));\n}\n;\nMDXContent.isMDXComponent = true;","slug":"/build-your-own-react/","title":"나만의 리액트 라이브러리 만들기","tags":[],"keywords":[],"date":"April 05, 2020","fields":{"langKey":"ko","filePath":"/content/posts/build-your-own-react/index.mdx"},"parent":{"__typename":"Mdx","frontmatter":{"max_width":"58rem"}}},"previous":{"id":"6b995841-3eeb-5337-b8b5-1f416a30b532","excerpt":"아들과 함께 진행한 여름방학 프로젝트: 두뇌 트레이닝 - 계산 20회 시작하기 클릭 후, 화면에 표시되는 문제의 답을 키보드로 입력하세요. 👍","slug":"/brain-age-calculations/","title":"두뇌 트레이닝 - 계산 20회","date":"August 21, 2019"},"next":null},"pageContext":{"id":"d1a1f32d-dcff-56ce-83c8-e82aa1065fd9","previousId":"6b995841-3eeb-5337-b8b5-1f416a30b532","translations":[{"origin":"/build-your-own-react/","slug":"/build-your-own-react/","langKey":"ko"}],"editOnGithub":"https://github.com/bluewings/dev-dad/edit/master","disqusShortname":"dev-dad","langKey":"ko","langKeyDefault":"ko"}}}